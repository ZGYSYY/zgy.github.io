<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小甲鱼汇编学习笔记</title>
      <link href="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<center><h1>day01（2020年2月28日）</h1></center><h1 id="视频01"><a href="#视频01" class="headerlink" title="视频01"></a>视频01</h1><p>1、汇编语言的主体是汇编指令。<br>2、汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式，汇编指令是机器指令的助记符。<br>3、寄存器，寄存器是cpu中可以存储数据的器件，相当于嵌入到cpu中的内存，处理数据的速度仅次于cpu。一个cpu中有很多个寄存器，AX是其中一个寄存器的代号，BX也是其中一个寄存器的代号。<br>4、查看某个软件的汇编指令工具可以使用Ollydbg软件。</p><a id="more"></a><h1 id="视频02"><a href="#视频02" class="headerlink" title="视频02"></a>视频02</h1><p>1、汇编语言由3部分组成，分别是： </p><ul><li>汇编指令：机器码的助记符。</li><li>伪指令：由编译器执行。</li><li>其他符号：由编译器识别。</li></ul><p>2、存储器</p><ul><li>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供<code>指令</code>和<code>数据</code>。</li><li>指令和数据都是存储在存储器中，我们通常说的存储器其实就是内存。</li><li>在一台PC机中内存的作用仅次于CPU，离开了内存，再强悍的CPU也没有什么用。磁盘不同于内存，磁盘的读写速度比较慢，通常将磁盘的数据读取到内存中，然后CPU和内存进行数据交互。</li></ul><p>3、指令和数据</p><ul><li>指令和数据是应用上的概率，在内存或磁盘上，指令和数据之间没有任何的区别，都是二进制信息。所以定义指令和数据是由程序员决定的。</li></ul><p>4、存储单元</p><ul><li>存储器被划分为若干个存储单元，存储单元从0开始顺序编号。例如，一个存储器有128个存储单元，编号就是0~127。</li></ul><p>5、CPU对存储器的读写</p><ul><li><p>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息交互：</p></li><li><p>存储单元的地址。（地址信息）</p></li><li><p>器件的选择，读或写命令。（控制信息）</p></li><li><p>读或写的数据。（数据信息）<br>CPU读数据的步骤为：</p><ol><li>获取地址信息。</li><li>确定是读操作操作。</li><li>将数据从指定地址中读取出来。</li></ol></li><li><p>CPU写数据的步骤为：</p><ol><li>获取地址信息。</li><li>确定是写操作操作。</li><li>将数据写入指定地址中。</li></ol></li></ul><p>6、CPU是通过什么将地址、数据和控制信息传到存储芯片上的。</p><p>CPU传输数据实质上是通过电信号传输的，电信号传输需要导线，通常将CPU和其它芯片之间的连接的导线称为<code>总线</code>。总线物理上其实就是一个导线的集合，逻辑上可以分为3类，如下：</p><ol><li>地址总线：确定地址。</li><li>数据总线：确定传输数据。</li><li>控制总线：确定是读还是写。</li></ol><h1 id="视频03"><a href="#视频03" class="headerlink" title="视频03"></a>视频03</h1><p>1、地址总线<br>一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元。<br>2、数据总线<br>数据总线的宽度决定了CPU和外界的数据传输速度，宽度越大，速度越快；反之，速度越慢。<br>3、8088CPU和8086CPU的区别<br>8088CPU一次能处理的数据为8位，8086CPU一次能处理的数据为16位，所以8086CPU比8088CPU快。<br>4、控制总线<br>有多少根控制总线，就意味着CPU提供了对外部器件有多少种控制，一位代表一种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p><h1 id="视频04"><a href="#视频04" class="headerlink" title="视频04"></a>视频04</h1><p>1、小结</p><ol><li>汇编指令是机器指令的助记符，同机器指令一一对应。</li><li>每一种CPU都有自己的汇编指令集。</li><li>CPU可以直接使用的信息在存储器中存放。</li><li>在存储器中指令和数据没有任何区别，都是二进制信息。</li></ol><center><h1>day02（2020年3月1日）</h1></center><h1 id="视频05"><a href="#视频05" class="headerlink" title="视频05"></a>视频05</h1><p>1、内存地址空间<br>一个CPU的地址线宽度为10，那么可以寻址2的10次方即1024个内存单元，这1024个内存单元就构成了这个CPU的内存地址空间。<br>2、主板<br>在每台PC机中，都有一个主板，主板上有核心器件和一些主要器件。这些器件通过总线（地址总线、数据总线、控制总线）相连。<br>3、接口卡<br>CPU对外部设备不能直接控制，如显示器、音响、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。<br>4、各类存储器芯片</p><ul><li>从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）。</li><li>从功能和连接上可以分为三类：随机存储器（RAM），装有BOIS的ROM，接口卡上的RAM。</li><li>RAM就是我们常说的内存，只读存储器就是一些硬件在出厂时，厂家用特殊手段将程序刷进ROM的存储器，该存储器一般是只能读不能写的，所以称为只读存储器，比如BOIS就是在ROM中的一个程序，是厂家出厂时刷进去的。</li></ul><p>5、对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制，这个逻辑存储器就是我们所说的内存地址空间。</p><h1 id="视频06"><a href="#视频06" class="headerlink" title="视频06"></a>视频06</h1><p>1、一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。<br>2、内部总线和外部总线的区别如下：</p><ul><li>内部总线实现CPU内部各个器件之间的联系。</li><li>外部总线实现CPU和主板上其它器件的联系。</li></ul><p>3、8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。<br>4、8086CPU所有的寄存器都是16位的，可以存放两个字节（一个字节是8位）。<br>5、AX、BX、CX、DX通常用来存放一般性数据，所以被称为通用寄存器。<br>6、一个16位寄存器能存储的数据的最大值为2的16次方减1。<br>7、因为8086上一代CPU中的寄存器都是8位的，为了保证兼容性，8086CPU上的寄存器16位可以分成两个8位来使用，左边8位称为高8位，右边8位称为低8位。所以有如下表示法：</p><ul><li>AX可以分为AH和AL。H表示高，L表示低，下面的意思也相同。</li><li>BX可以分为BH和BL。</li><li>CX可以分为CH和CL。</li><li>DX可以分为DH和DL。</li></ul><h1 id="视频07"><a href="#视频07" class="headerlink" title="视频07"></a>视频07</h1><p>1、一个字可以储存在一个16位寄存器中，这个字的<code>高位字节</code>和<code>低位字节</code>自然就存在这个寄存器的高8位寄存器和低8位寄存器中。<br>2、由于一个内存单元可以存放8位数据，CPU中的寄存器又可以存放n个8位数据。也就是说，计算机中的大多数数据是由1~n个8位数据构成的。<br>3、用十六进制来表示数据可以直观的看出这个数据是由哪些8位数据构成的。每两位对应一个8位数据（一个16进制占4位）。3位能表示一个8进制（2的3次方等于8），4位能表示一个16进制（2的4次方等于16）。<br>4、几条汇编指令</p><ul><li>mov ax,18：将18送入AX寄存器中。 ax = 8。</li><li>mov ah,78：将78送入AH寄存器中。 ah = 78。</li><li>add ax,8：将AX寄存器中的值加上8。 ax = ax + 8。</li><li>mov ax,bx：将BX寄存器中的值送入AX寄存器中。 ax = bx。</li><li>add ax,bx：将AX寄存器中的值加上BX寄存器中的值。 ax = ax + bx。</li></ul><p>5、存在数据丢失，值得是进制位不能再8位寄存器中保存，但是CPU并不是正真的丢弃了这个进位值。</p><h1 id="视频08"><a href="#视频08" class="headerlink" title="视频08"></a>视频08</h1><p>1、物理地址：CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成一个一维的线性空间。我们将这个唯一的地址称为物理地址。<br>2、16位CPU具有以下几个方面的特征：</p><ul><li>运算器一次最多可以处理16位的数据。</li><li>寄存器最大宽度为16位。</li><li>寄存器和运算器之间的通路是16位。</li></ul><p>3、8086CPU一次能处理20位数据，可以传送20位地址，寻址能力为1M（2的20次方）。但是8086CPU的寄存器只能处理16位数据，因此它的寻址能力为64K（2的16次方）。为了让其能达到1M的寻址能力，8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。<br>4、将两个16位地址加工成20位的步骤如下：</p><ol><li>CPU内部提供两个16位的地址，把第一个16位地址称为<code>段地址</code>，另一个称为<code>偏移地址</code>。</li><li>将段地址和偏移地址通过内部总线送入一个称为地址加法器的部件。</li><li>地址加法器将两个16位地址合并成一个20位地址。</li></ol><p>5、地址加法器工作原理：物理地址 = 段地址 * 16 + 偏移地址。（以16进制算就是数据向左移动一位，以2进制算就是数据向左移动4位，因为2的4次方等于16）<br>6、通过观察移位次数和各种形式数据的关系如下：</p><ul><li>一个数据的二进制形式左移1位，相当于该数据乘以2。</li><li>一个数据的二进制形式左移N位，相当于该数据乘以2的N次方。</li></ul><p>7、十六进制移位关系如下：</p><ul><li>一个十六进制形式左移1位，相当于该数据乘以16。</li><li>一个十六进制形式左移N位，相当于该数据乘以16的N次方。</li></ul><p>8、段地址和偏移地址的比喻：一个数为2080，但是我一次只能写3个数字，所以不够，然后我就将第一位乘以1000表示段地址，后面三位数字表示偏移地址，当地址加法器拿到数据后，就会将段地址的第一位乘以1000，然后加上偏移地址，于是就有，物理地址 = 段地址 * 进制位 + 偏移地址。</p><h1 id="视频09"><a href="#视频09" class="headerlink" title="视频09"></a>视频09</h1><p>1、段的概念：内存并没有分段，段的划分来自于CPU，由于8086CPU用“段地址 * 16 + 偏移地址 = 服务地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用 段地址*16 定位段的起始地址也称基础地址，用偏移地址定位段中内存单元。<br>2、注意两点</p><ol><li>因为 段地址*16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数。</li><li>偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k。</li></ol><p>3、CPU可以用不同的段地址和偏移地址形成同一个物理地址。<br>4、如果给定一个段地址，仅通过变化偏移地址来寻址，最多可以定位64K个内存单元，因为偏移地址占16位，2的16次方等于64K。<br>5、数据在21F60H内存单元中，8086PC机的两种描述：</p><ol><li>数据存储在内存2000：1F60单元中。</li><li>数据存储在内存的2000段中的1F60单元中。</li></ol><center><h1>day03（2020年3月2日）</h1></center><h1 id="视频10"><a href="#视频10" class="headerlink" title="视频10"></a>视频10</h1><ol><li><p>段寄存器就是提供段地址的寄存器，8086CPU有4个段寄存器。分别为：CS、DS、SS、ES。当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。</p></li><li><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取的指令地址。CS为代码寄存器，IP为指令指针数据。</p></li><li><p>8086CPU工作过程的简要描述</p><ol><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器。</li><li>IP = IP + 所读取指令的长度，从而指向下一条指令。</li><li>执行指令。跳转到步骤1，重复这个过程。</li></ol></li><li><p>在8086CPU加电启动或复位后（即CPU刚开始工作的时候），CS和IP被置为CS=FFFFH，IP=0000H。即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行。所以FFFF0H单元中的指令就是8086PC开机后执行的第一条指令。</p></li><li><p>在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。</p></li><li><p>修改CS、IP的指令</p><ul><li>同时CS、IP的内容，使用<code>jmp</code>指令，格式为：<code>jmp 段地址 : 偏移地址</code>，例如：jmp 2AE3:3。</li><li>只修改IP的内容，首相将要设置的值使用指令<code>mov</code>将其送入到一个合法寄存器中，然后再使用指令<code>jmp</code>后边跟那个被设置值得寄存器，例如：mov AX,2AE3H 然后 jmp AX。</li></ul></li><li><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。可以将长度为N（N&lt;=64KB）的一组代码，存在一组<b>地址连续</b>、<b>起始地址为16的倍数</b>的内存单元中，这段内存是用来存放代码的，从而定义一个代码段。</p><p>例如，假如有一串汇编指令，占用10个字节，他们存在123B0H~123B9H的一组内存单元中，我们就可以认为，123B0H~123B9H这段内存单元是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10字节。</p></li></ol><h1 id="视频11"><a href="#视频11" class="headerlink" title="视频11"></a>视频11</h1><ol><li>使用Debug调试汇编。常用命令如下：<ul><li>R命令查看、改变CPU寄存器的内容。</li><li>D命令查看内存中的内容。</li><li>E命令改写内存中的内容。</li><li>U命令将内存中的机器指令翻译成汇编指令。</li><li>T命令执行一条机器命令。</li><li>A命令以汇编指令的格式在内存中写入一条机器指令。</li></ul></li></ol><center><h1>day04（2020年3月3日）</h1></center><h1 id="视频13（第三章-寄存器（内存访问一））"><a href="#视频13（第三章-寄存器（内存访问一））" class="headerlink" title="视频13（第三章 寄存器（内存访问一））"></a>视频13（第三章 寄存器（内存访问一））</h1><ol><li><p>任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它看成两个内存单元，也可以看成一个地址为N的<code>字单元</code>中高位字节单元和地位字节单元。</p></li><li><p>8086CPU中有一个DS寄存器，通常用来存放要访问的数据的<b>段地址</b>。例子如下：</p><p>要读取10000H单元的内容，可以用如下程序段进行：</p><ol><li>mov bx,1000H</li><li>mov ds,bx</li><li>mov al,[0]</li></ol><p>上面三条指令将10000H（1000:0）中的数据读取到了AL寄存器中。</p></li><li><p>mov现在的功能如下：</p><ol><li>将数据直接送入寄存器。</li><li>将一个寄存器中的内容送入另一个寄存器中。</li><li>将一个内存单元中的内容送入一个寄存器。</li></ol></li><li><p>如何从内存单元地址为10000H中读取数据到寄存器中，步骤如下：</p><ol><li>10000H表示为1000:0（段地址:偏移地址）。</li><li>将段地址1000H放入DS寄存器。</li><li>用mov al,[0]完成传送（mov指令中的[]说明操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的段地址默认已经放入了DS寄存器中了）。</li></ol></li><li><p>如何把内存单元地址10000H中的数据送入DS中？</p><p>8086CPU不支持将数据直接送入段寄存器，所以<code>mov ds,1000H</code>是错误的，正确的方法是，将地址1000H中的数据送入通用寄存器，然后将通用寄存器中的数据送入段寄存器（数据 –&gt; 通用寄存器 –&gt; 段寄存器）。</p></li><li><p>将al中的数据送入地址为10000H的内存单元中。</p><ol><li>mov bx,1000H; 将段地址送入通用寄存器BX中。</li><li>mov ds,bs；将通用寄存器中的地址送入段寄存器DS中。</li><li>mov [0],al；将AL通用低位寄存器中的偏移地址送入内存单元。</li></ol></li><li><p>字的概念</p><p>16位等于2个字节等于一个字。在8086CPU中，该CPU是一个16位结构，有16根数据线，所以一次性要传送16位的数据，也就是一次性传送一个字。</p><p>所以，当使用汇编指令<code>mov ax,[0]</code>时，指定的是AX而不是AL或者AH，这时，数据是16位，即一个字。当为AL或则AH时，数据是8位，即一个字节。</p></li></ol><h1 id="视频14（第三章-寄存器（内存访问二）"><a href="#视频14（第三章-寄存器（内存访问二）" class="headerlink" title="视频14（第三章 寄存器（内存访问二）"></a>视频14（第三章 寄存器（内存访问二）</h1><blockquote><p>视频13的练习题讲解。</p></blockquote><h1 id="视频15（第三章-寄存器（内存访问三））"><a href="#视频15（第三章-寄存器（内存访问三））" class="headerlink" title="视频15（第三章 寄存器（内存访问三））"></a>视频15（第三章 寄存器（内存访问三））</h1><blockquote><p>视频13和视频14的总结。</p></blockquote><ol><li>mov指令的几种形式：<ul><li>mov 寄存器,数据</li><li>mov 寄存器,寄存器</li><li>mov 寄存器,内存单元</li><li>mov 内存单元,寄存器</li><li>mov 段寄存器,寄存器</li><li>mov 寄存器,段寄存器</li><li>mov 内存单元,段寄存器</li><li>mov 段寄存器,内存单元</li></ul></li><li>add、sub指令，用法和mov指令相同。</li><li>小结<ol><li>字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</li><li>计算机一个内存单元为一个字节。</li><li>用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。</li><li>[address]表示一个偏移地址位address的内存单元。</li><li>在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。</li><li>mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。</li></ol></li></ol><h1 id="视频16（第三章-寄存器（内存访问四））"><a href="#视频16（第三章-寄存器（内存访问四））" class="headerlink" title="视频16（第三章 寄存器（内存访问四））"></a>视频16（第三章 寄存器（内存访问四））</h1><blockquote><p>讲述什么是栈，理解栈的结构，掌握栈的使用。</p></blockquote><ol><li><p>栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p></li><li><p>栈有两个基本操作，即入栈和出栈。</p><ul><li>入栈：将一个新的元素放入栈顶。</li><li>出栈：从栈顶取出一个元素。</li></ul><p>栈顶的元素总是最后入栈，需要出栈时，又最想被从栈中取出。我们称这种规则为LIFO（Last In First Out，后进先出）。</p></li><li><p>如今的CPU都提供相关的指令来以栈的方式访问内存空间，这意味着，我们在基于8086CPU编程的时候，可以将一段内存当做栈来使用。</p></li><li><p>CPU提供入栈和出栈的指令（最基本的）：</p><ul><li>push：入栈。push ax：将寄存器AX中的数据送入栈中。</li><li>pop：出栈。pop ax：从栈顶取出数据送入AX寄存器中。</li></ul></li><li><p>8086CPU入栈和出栈操作都是以字为单位进行的。</p></li><li><p>8086CPU中，有两个寄存器：</p><ol><li>段寄存器：SS，用来存放栈顶的段地址。</li><li>寄存器：SP，存放栈顶的偏移地址。</li></ol><p>在任意时刻，SS:SP指向栈顶元素。所以计算机用SS寄存器和SP寄存器来表示栈内存结构。</p></li><li><p>栈结构数据是从内存地址大的内存单元开始存放数据的，push的时候，SP = SP - 2，pop的时候，SP = SP + 2。所以，如果我们将10000H~1000FH这段空间当作栈，初始状态为空的，此时，SS = 1000H，SP = 0010H（当栈中有一个数据时，SP = 000EH，数据为空，相当于在有一个数据的时候，使用pop，所以SP = SP + 2  = 000EH + 2H = 0010H）。</p></li><li><p>任意时刻，SS:SP指向栈顶，当栈中只有一个元素时，SP = 000EH。在10000H ~ 1000FH这段空间用作栈来使用，并且该栈中只有一个元素时（一个元素是一个字，占16位，一个内存单元是8位），所以SP = 000EH。</p></li></ol><center><h1>day05（2020年3月8日）</h1></center><h1 id="视频17（第三章-寄存器（内存访问五））"><a href="#视频17（第三章-寄存器（内存访问五））" class="headerlink" title="视频17（第三章 寄存器（内存访问五））"></a>视频17（第三章 寄存器（内存访问五））</h1><blockquote><p>讲解了pop指令的执行过程，栈超界问题，push和pop的指令格式。</p></blockquote><ol><li><p>pop指令的执行过程</p><p>pop ax</p><ol><li>将SS:SP指向的内存单元处的数据送入AX中。</li><li>SP = SP + 2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li></ol></li><li><p>注意</p><ol><li>出栈后，pop操作前的栈顶元素是依然存在的，只是SP:SP指向的地址变成了SP + 2的地址，因此数据是可以恢复的，所以有磁盘恢复数据一说。</li><li>入栈后，push操作会覆盖以前pop操作但是没有真正删除的数据，所以要想数据不能被恢复，就是用专用的软件覆盖以前的数据。</li></ol></li><li><p>栈顶超界问题</p><p>8086CPU现在没有记录栈顶超界的专用寄存器，所以8086CPU是允许栈顶超界的，在现在新的CPU应该是有专用的栈顶超界专用寄存器的。</p><p>栈顶超界是一个相当危险的问题，可以通过栈顶超界获取到内存上的其它数据，导致数据泄露。</p><p>我们在编程的时候要自己注意栈顶超界问题，要根据可以用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致超界。</p><p>执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。</p></li><li><p>push和pop指令是可以在寄存器和内存之间传送数据的</p><p>栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。</p><p>push和pop的指令格式如下：</p><ol><li><p>格式一</p><ul><li>push 寄存器：将一个寄存器中的数据入栈。</li><li>pop 寄存器：出栈，用一个寄存器接收出栈的数据。</li></ul><p>例如：</p><ul><li>push ax</li><li>pop bx</li></ul></li><li><p>格式二</p><ul><li>push 段寄存器：将一个段寄存器中的数据入栈。</li><li>pop 段寄存器：出栈，用一个段寄存器接收出栈的数据。</li></ul><p>例如：</p><ul><li>push ds</li><li>pop es</li></ul></li><li><p>格式三</p><ul><li>push 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）。</li><li>pop 内存单元：出栈，用一个内存字单元接收出栈的数据</li></ul><p>例如：</p><ul><li>push [0]</li><li>pop [2]</li></ul><p>指令执行时，CPU要知道内存单元的地址，可以在push，pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从DS寄存器中取得。</p></li></ol></li></ol><h1 id="视频18（第三章-寄存器（内存访问六））"><a href="#视频18（第三章-寄存器（内存访问六））" class="headerlink" title="视频18（第三章 寄存器（内存访问六））"></a>视频18（第三章 寄存器（内存访问六））</h1><blockquote><p>例题讲解，栈的总结</p></blockquote><ol><li><p>8086CPU提供了栈操作机制，方案如下：</p><p>在SS，SP中存放栈顶的段地址和偏移地址。</p><p>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元。</p></li><li><p>push指令的执行步骤</p><ol><li>SP = SP - 2 。</li><li>想 SS:SP指向的字单元中送入数据。</li></ol></li><li><p>pop指令的执行步骤</p><ol><li>从SS:SP指向的字单元中读取数据。</li><li>SP = SP +2 。</li></ol></li><li><p>任意时刻，SS:SP指向栈顶元素。</p></li><li><p>8086CPU只记录栈顶，栈空间的大小我们要自己管理。</p></li><li><p>用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。</p></li><li><p>push，pop实质上是一种内存传送指令，注意它们的灵活应用。</p></li><li><p>栈是一种非常重要的机制，一定要深入理解，灵活掌握。</p></li></ol><h1 id="视频19（第三章-寄存器（内存访问七））"><a href="#视频19（第三章-寄存器（内存访问七））" class="headerlink" title="视频19（第三章 寄存器（内存访问七））"></a>视频19（第三章 寄存器（内存访问七））</h1><blockquote><p>当用栈来存储数据的时候，SP的地址范围从 0000H~FFFFH的注意事项。</p></blockquote><ol><li><p>当用10000H~1FFFFH当作栈时，栈段SS = 1000H，栈空间大小为64KB，如果栈为空，则SP = 0000F。我们可以这样理解，栈为空，实际就是栈中的唯一元素出栈，即SP = SP + 2，当栈中只有一个元素时，偏移地址为FFFE（一个内存单元是8位，能放2个十六进制数，但是栈的操作单位是字）。所以SP = FFFEH + 2H = 10000H，因为16位寄存器一次能存储4位十六进制，高位被舍弃，所以SP = 0000H。</p></li><li><p>当SP的范围为0000H~FFFFH时，从栈空时候SP = 0000H，一直压栈操作，知道栈满的时候 SP 会从 0000H 到</p><p>FFFEH 到 … 到 0000H，最终形成一个循环，导致原来栈中的内容被新内容覆盖。</p></li></ol><h1 id="视频20（第四章-第一个程序01）"><a href="#视频20（第四章-第一个程序01）" class="headerlink" title="视频20（第四章 第一个程序01）"></a>视频20（第四章 第一个程序01）</h1><ol><li><p>一个汇编语言程序从写出到最终执行的简要过程为：</p><ol><li>编写源代码。</li><li>编译和连接。</li><li>执行。</li></ol></li><li><p>汇编指令：编译器将对应的汇编指令一一对应成机器码。</p></li><li><p>伪指令：是给编译器看的，告诉编译器如何编译源代码。</p></li><li><p>定义一个段</p><p>segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。格式为 <code>段名称 segment</code>，<code>段名称 ends</code>，例如：<code>code segment</code>，<code>段名称 ends</code></p></li><li><p>end 伪指令，告诉编译器汇编程序的源代码在这个位置就结束了，就不需要编译了。</p></li><li><p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。</p></li><li><p>一个有意义的汇编程序中至少有一个段，这个段是用来存放代码的。</p></li><li><p>assume关键字的作用是将某一段寄存器和程序中的某个段相关联，例如<code>assume cs:code</code>，意思就是将 code 段与CS寄存器进行关联。</p></li><li><p>汇编源代码是由<b>伪指令</b>和<b>汇编指令</b>组成的。</p></li></ol><h1 id="视频21（第四章-第一个程序02）"><a href="#视频21（第四章-第一个程序02）" class="headerlink" title="视频21（第四章 第一个程序02）"></a>视频21（第四章 第一个程序02）</h1><ol><li><p>放在伪指令<code>segment</code>前面的自定义字符串就是标号。</p></li><li><p>程序返回值固定格式：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,4c00H<br>int 21H<br></code></pre></td></tr></table></figure></li><li><p>程序源代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:abc<br>abc segment<br>mov ax,2<br>add ax,ax<br>add ax,ax<br>mov ax,4c00H<br>int 21H<br>abc ends<br>end<br></code></pre></td></tr></table></figure></li><li><p>编译链接的作用</p><ul><li>当程序很大时，可以将它们分为多个源程序文件来编译，每个源程序编译成目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件。</li><li>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件。</li><li>一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能用来直接生成可执行文件，连接程序将这些内容处理为最终可执行信息。所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</li></ul></li></ol><h1 id="视频22（第四章-第一个程序03）"><a href="#视频22（第四章-第一个程序03）" class="headerlink" title="视频22（第四章 第一个程序03）"></a>视频22（第四章 第一个程序03）</h1><ol><li><p>在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2，将P1从可执行文件中加载入内存，将CPU的控制权交给它，P1才得以运行。当P1运行完毕后，应该将CPU的控制权交还给使它得以运行的P2。</p></li><li><p>操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作。</p></li><li><p>DOS中有一个程序command.com（cmd），这个程序在DOS中称为命令解释器，也就是DOS系统的shell。</p></li><li><p>在执行demo.exe程序的时候，是正在运行的command程序将demo.exe中的程序加载入内存中，然后command程序设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序得以运行。</p></li><li><p>汇编程序从写出到执行的过程如下</p><ol><li>编辑源代码，文件名为demo.asm。</li><li>使用masm程序编译源代码，生成demo.obj文件。</li><li>使用link程序连接程序，生成demo.exe文件。</li><li>使用command程序将demo.exe加载入内存。</li><li>CPU运行demo.exe程序。</li></ol></li><li><p>可以使用Debug程序来对我们写的的程序进行单步调试，格式为<code>debug demo.exe</code>。</p></li><li><p>带入口地址的汇编程序</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:abc<br>abc segment<br>start:mov ax,2<br>add ax,ax<br>add ax,ax<br>mov ax,4c00H<br>int 21H<br>abc ends<br>end start<br></code></pre></td></tr></table></figure><p><code>start</code>是可以任意定义的，注意<code>end</code>后面也要添加对应的相同的字符串。</p></li><li><p>CX寄存器中存放的是程序的长度，单位是字节。</p></li><li><p>DS寄存器是是存储数据的，程序加载后，DS中存放着程序所在内存区的段地址，本来DS应该和CS指向同一个地方，但是实际不是这样的，在DS中会用256个字节来存放PSP的数据，PSP可以理解为DOS要利用PSP来和被加载程序进行通信的区域。所以DS的内存地址是原地址 + 10H的地址，即用10H大小的内存来存储PSP，换算成物理地址是 256个字节来存储PSP。</p></li><li><p>当程序执行到 <code>int 21</code>的时候表示程序即将运行结束，这个时候，在debug模式下不能使用T指令了，要用P指令，当使用P指令后，被调试程序退出，回到debug程序。</p></li><li><p>需要注意，在DOS中运行程序时，是command将程序加入内存的。所以程序运行结束后会返回到command中，而使用debug将程序载入内存时，程序运行结束后要返回到debug中。</p></li><li><p>在DOS中使用debug时，程序加载的顺序是：command加载debug，debug加载我们自己写的程序。</p></li></ol><h1 id="视频23（第五章-bx-和loop指令01）"><a href="#视频23（第五章-bx-和loop指令01）" class="headerlink" title="视频23（第五章 [bx]和loop指令01）"></a>视频23（第五章 [bx]和loop指令01）</h1><ol><li><p>当要完整的描述一个内存单元，需要两种信息：</p><ol><li>内存单元地址。</li><li>内存单元的长度。</li></ol><p>我们用[0]表示一个内存单元时，0表示内存单元的偏移地址，段地址默认在DS中，单元长度可以由具体指令中其它操作对象（比如寄存器）指出，如AX表示一个字，AL表示一个字节。</p></li><li><p>[bx]的表示含义，[bx]同样也表示一个内存单元，只是它的偏移地址在BX寄存器中。之所以出现[bx]这种表示法，是因为在MSAM编译器中，无法识别<code>mov ax,[0]</code>，编译器会识别为<code>mov ax,0</code>，为了解决这个问题，我们可以修改为<code>mov bx,0</code>，然后<code>mov ax,[bx]</code>达到目的。</p></li><li><p>loop指令，该指令就是一个循环指令。</p></li></ol><h1 id="视频24（第五章-bx-和loop指令02）"><a href="#视频24（第五章-bx-和loop指令02）" class="headerlink" title="视频24（第五章 [bx]和loop指令02）"></a>视频24（第五章 [bx]和loop指令02）</h1><ol><li><p>loop指令的格式为：loop:标号，CPU执行loop指令的时候，要进行如下两步操作：</p><ol><li><p>CX = CX - 1。</p></li><li><p>判断CX中的值，不为0则转至标号处执行程序，如果为0则向下执行。</p></li><li><p>通常我们用loop指令来实现循环功能，CX寄存器在没有使用loop指令的时候，存储的是运行程序的长度，单位为字节。当使用loop指令时，存储的是循环次数。</p></li><li><p>使用loop指令实现计算2的12次方的值</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>start:mov ax,2<br>mov cx,11<br>s:add ax,ax<br>loop s<br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="视频25（第五章-bx-和loop指令03）"><a href="#视频25（第五章-bx-和loop指令03）" class="headerlink" title="视频25（第五章 [bx]和loop指令03）"></a>视频25（第五章 [bx]和loop指令03）</h1><ol><li><p>CX寄存器和loop指令相配合实现循环功能的三个要点如下：</p><ol><li>在CX寄存器中存放循环次数。</li><li>loop指令中的标号所标识的地址要在前面。</li><li>要循环执行的程序段，要写在标号loop指令的中间。</li></ol></li><li><p>在使用debug调试循环体的时候的技巧</p><p>当循环次数过多时，我们不可能一次一次的去使用<code>t</code>来执行单步指令，这个时候可以使用<code>g 偏移地址</code>来实现指定偏移地址的跳转，从而跳过循环体。也可以使用<code>p</code>来跳出循环体。</p></li><li><p>在给寄存器设置值的时候，如果值得第一位是英文字母，汇编是不会识别的，解决的办法就是在设置值得前面添加一个<code>0</code>。</p></li><li><p>在汇编中进行数据运算时，一定要考虑计算后的值是否会超出内存的最多容量。</p></li></ol><h1 id="视频26（第五章-bx-和loop指令04）"><a href="#视频26（第五章-bx-和loop指令04）" class="headerlink" title="视频26（第五章 [bx]和loop指令04）"></a>视频26（第五章 [bx]和loop指令04）</h1><ol><li>[bx]的作用：作为偏移地址与DS配合。[bx]在debug中的含义和在MASM中的含义。</li><li>loop和CX达到循环效果。</li><li>debug的<code>g</code>和<code>p</code>的作用。</li></ol><center><h1>day06（2020年3月11日）</h1></center><h1 id="视频27（第五章-bx-和loop指令05）"><a href="#视频27（第五章-bx-和loop指令05）" class="headerlink" title="视频27（第五章 [bx]和loop指令05）"></a>视频27（第五章 [bx]和loop指令05）</h1><ol><li><p>不能将位数不同的数据，进行计算。比如内存单元是8位，8086CPU的寄存器是16位，所以不能直接把内存单元中的数据直接与寄存器中的数据进行运算。解决办法是将内存单元中的数据先存入通用寄存器中，比如AX或者BX中，然后在用通用寄存器中的数据与8086CPU中的另一个寄存器进行运算，这样就间接成了两个寄存器进行运算，两个寄存器都是16位的，所以可以进行运算。</p></li><li><p>利用通用寄存器，实现变量的自增或自减，结合loop指令来实现更为复杂的元素。比如用AX寄存器来存储一个内存单元地址，这样就可以把AX中存储的内存单元地址当作一个变量，我们可以随时更改AX中的内存单元的地址来改变值。</p></li><li><p>段前缀的使用，在以前我们为了解决MASM编译不解析<code>mov ax,[0]</code>这种语法，而使用如下代码：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,0<br>mov ax,[bx]<br></code></pre></td></tr></table></figure><p>这种写法过于麻烦，因此我们可以使用段前缀来表示，代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,ds:[0]<br></code></pre></td></tr></table></figure><p>上面代码中的<code>ds:</code>就是段前缀。</p></li></ol><h1 id="视频28（第五章-bx-和loop指令06）"><a href="#视频28（第五章-bx-和loop指令06）" class="headerlink" title="视频28（第五章 [bx]和loop指令06）"></a>视频28（第五章 [bx]和loop指令06）</h1><ol><li>我们需要向一段内存中写入内容的时候，这段内存空间不应存放系统或其它程序的数据或代码，否则写入操作很可能引发错误。</li><li>DOS方式下，一般情况，0000H:0200H~0000H:0:02FFH空间中没有系统或其它程序的数据或代码。</li><li>在我们测试的时候，就可以用0000H:0200H~0000H:0:02FFH这段空间。</li><li>利用ES寄存器和DS寄存器形成两个段寄存器加loop指令来实现将多个数据从一个地址一一复制到另一个地址。</li></ol><h1 id="视频29（第六章-包含多个段的程序01）"><a href="#视频29（第六章-包含多个段的程序01）" class="headerlink" title="视频29（第六章 包含多个段的程序01）"></a>视频29（第六章 包含多个段的程序01）</h1><ol><li><p>使用一个段来实现8个数据相加的和，代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code<br>code segment<br>dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H<br>start:mov bx,0<br>mov ax,0<br>mov cx,8<br>s:add ax,cs:[bx]<br>add bx,2<br>loop s<br>mov ax,4cooH<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure><ul><li><p>dw命令的作用是定义字型数据，dw即define word。多个数据用<code>,</code>分开。</p></li><li><p>上面的程序定义了8个数据，每个数据占用2个内存单元，所以一共占用16个内存单元，即16个字节。</p></li><li><p>程序中<code>cs:code</code>表示程序的是存放在CS寄存器中的，所以用<code>dw</code>定义的数据也是存放在CS寄存器中的，因为<code>dw</code>是在代码开头定义的，所以对应的数据应该是从cs:0000H开始的，因为1个数据占用两个字节，所以每两字节单元表示一个数。所以偏移地址是0000H到0000EH表示这8个数据</p></li><li><p>从程序中可以看出，end伪指令不仅可以告诉MSAM编译器程序到这里结束，还可告诉MASM编译器程序从哪个地方开始，就是从start标号处开始。为什么不是start来标识程序开始，因为start可以是其它任意字符串，编译器MASM并不认识，但是编译器MASM认识<code>end</code>伪指令。</p></li></ul></li><li><p>从上面的代码可以看出，用一个段的程序，十分麻烦，因为一个段既存有数据，又存有代码。</p></li></ol><center><h1>day07（2020年3月12日）</h1></center><h1 id="视频30（第六章-包含多个段的程序02）"><a href="#视频30（第六章-包含多个段的程序02）" class="headerlink" title="视频30（第六章 包含多个段的程序02）"></a>视频30（第六章 包含多个段的程序02）</h1><ol><li><p>使用汇编语言，并用一个段来实现数据0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H的逆向存放。</p><p>思路：程序运行时，定义数据存放在cs:0~cs:15的内存单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆向存放。</p><p>问题是，我们首先要有一段可以当作栈的内存空间。这段空间应该由系统来分配。</p><p>我们可以在程序中通过定义数据来获得一段空间，然后将这段空间当作栈空间来用。</p><p>代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:codesg; 设置codesg段为cs段。<br>codesg segment<br>dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H;用dw来定义8个字型数据，在程序加载后，将取得8个字的内存空间，并将定义的数据放入其中。<br>dw 0,0,0,0,0,0,0,0;与上面的注释相同，在后面的程序中我们将用这段空间来当作栈使用。<br>start:mov ax,cs<br>mov ss,ax<br>mov sp,32;设置栈底的偏移地址为32，因为前面定义了两组8个字型数据，占用30个字节，当栈为空时，sp &#x3D; sp + 2，所以sp &#x3D; 32。<br>mov bx,0<br>mov cx,8;循环8次<br>s:push cs:[bx]<br>add bx,2<br>loop s;循环将数据入栈<br><br>mov bx,0<br>mov cx,8;<br>s2:pop cs:[bx]<br>add bx,2<br>loop s2<br><br>mov ax,4c00H<br>int 21H<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure><p>在代码中，<code>dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</code>，有两种说法：</p><ol><li>定义了8个字型数据。</li><li>开辟了8个字的内存空间，这段空间中的每个字单元中的数据依次是：0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H。</li></ol></li><li><p>为什么要将数据、代码、栈放入不同的段中？</p><p>因为将数据、代码、栈都放到一个段里面，我们在编程的时候，要注意何处是数据，何处是代码，何处是栈。这样就显然出现了两个问题：</p><ol><li>把它们放到一个段中使程序显得混乱。</li><li>当程序处理的数据很大，导致不能放到一个段中的时候，就出现了问题。</li></ol></li><li><p>使用汇编语言，并用多个段来实现数据0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H的逆向存放。</p><p>代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data,ss:stack<br>data segment<br>dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H<br>data ends<br><br>stack segment<br>dw 0,0,0,0,0,0,0,0<br>data ends<br><br>code segment<br>start:mov ax,stack<br>mov ss,ax<br>mov sp,16<br>mov ax,data<br>mov ds,ax<br>mov bx,0<br>mov cx,8<br>s:push [bx]<br>add bx,2<br>loop s<br><br>mov bx,0<br>mov cx,8<br>s2:pop [bx]<br>add bx,2<br>loop s2<br><br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ol><h1 id="视频31（第六章-包含多个段的程序03）"><a href="#视频31（第六章-包含多个段的程序03）" class="headerlink" title="视频31（第六章 包含多个段的程序03）"></a>视频31（第六章 包含多个段的程序03）</h1><ol><li>练习题和实践。</li></ol><h1 id="视频32（第七章-更灵活定位内存地址01）"><a href="#视频32（第七章-更灵活定位内存地址01）" class="headerlink" title="视频32（第七章 更灵活定位内存地址01）"></a>视频32（第七章 更灵活定位内存地址01）</h1><ol><li><p>and指令：逻辑与指令，按位进行与运算。</p><p>如：mov al,01100011B</p><p>​         and al,00111011B</p><p>执行后：al=00100011B </p><p>即同为真为真，其余都是假。</p><p>作用：可以将某个二进制数据指定位设置为0,如要把第3位设置为0，就and 11110111B。</p></li><li><p>or指令：逻辑或指令，按位进行或运算。</p><p>如：mov al,01100011B</p><p>​            or al,00111011B</p><p>执行后：al=01111011B</p><p>即同为假为假，其余都为真。</p><p>作用：可以将某个二进制数据指定位设置为1，如要把第3位设置为1，就or 00001000B。</p></li><li><p>ASCII码，是计算机系统中被采用的通用编码，能将字符与2个16进制数进行一一对应，但是无法表示中文，要表示中文要用UNCODE码（另一种编码）。</p></li><li><p>在ASCII码中，找到小写字母和大写字母之间的转化规律为：小写字母比大写字母大20H（十进制是32）。</p></li><li><p>编译器能够直接将字符串，转化为对应的ASCII码，定义格式为：<code>db 'AB'</code>，等同于：<code>db 65H,66H</code></p></li><li><p>利用<code>or</code>和<code>and</code>来实现字母大小写的转化，将大写字母和对应小写字母对应ASCII码中的数字转化为二进制后，发现一个规律，大写字母的第六位是0，其余都不变，小写字母的第五位是1，其余都不变。</p><p>因此，可以使用<code>or</code>指令将大写字母转化为小写字母，只需要大写字母的二进制数据<b>逻辑或</b>00100000B即可。</p><p>可以使用<code>and</code>指令将小写字母转化为大写字母，只需要小写字母的二进制数据<b>逻辑与</b>11011111B即可。</p></li><li><p>大小写字母转化例子，代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data<br><br>data segment<br>db &#39;BaSiC&#39;<br>db &#39;aBc&#39;<br>data ends<br><br>code segment<br>start:mov ax,data<br>mov ds,ax<br><br>mov bx,0<br>mov cx,5<br>s:mov al,[bx]<br>and al,11011111B<br>mov [bx],al<br>inc bx<br>loop s<br><br>mov bx,5<br>mov cx,3<br>s2:mov al,[bx]<br>or al,00100000B<br>mov [bx],al<br>inc bx<br>loop s2<br><br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ol><h1 id="视频33（第七章-更灵活定位内存地址02）"><a href="#视频33（第七章-更灵活定位内存地址02）" class="headerlink" title="视频33（第七章 更灵活定位内存地址02）"></a>视频33（第七章 更灵活定位内存地址02）</h1><ol><li><p>利用[bx + idata]表示一个内存单元，表示偏移地址是bx的值加上一个常量的值。</p><p>例如：mov ax,[bx + 200]的含义为：将一个内存单元的内容送入AX，这个内存单元的长度为2字节（一个字单元），能存放一个字，偏移地址为bx中的数值加上200，段地址在DS中。</p></li><li><p>mov ax,[bx + 200]可以写成如下几种格式：</p><ul><li>mov ax,[200 + bx]</li><li>mov ax,200[bx]</li><li>mov ax,[bx].200</li></ul></li><li><p>利用[bx + idata]代码示例，将定义的大写字符串转化为小写，将小写字符串转化为大写</p><p>代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data<br><br>data segment<br>db &#39;BASIC&#39;<br>db &#39;abcde&#39;<br>data ends<br><br>code segment<br>start:mov ax,data<br>mov ds,ax<br><br>mov bx,0<br>mov cx,5<br>s:mov al,[bx]<br>and al,11011111B<br>mov [bx],al<br><br>mov al,[5+bx]<br>or al,00100000B<br>mov [5+bx],al<br>inc bx<br>loop s<br><br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ol><h1 id="视频34（第七章-更灵活定位内存地址03）"><a href="#视频34（第七章-更灵活定位内存地址03）" class="headerlink" title="视频34（第七章 更灵活定位内存地址03）"></a>视频34（第七章 更灵活定位内存地址03）</h1><ol><li><p>SI和DI寄存器，SI和DI是8086CPU中和BX寄存器功能相近的寄存器，但是SI和DI不能够分成两个8位寄存器来使用。</p><p>下面三组指令实现了相同的功能：</p><ol><li><p>第一组</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,0<br>mov ax,[bx+123]<br></code></pre></td></tr></table></figure><ol start="2"><li><p>第二组</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov si,0<br>mov ax,[si+123]<br></code></pre></td></tr></table></figure></li><li><p>第三组</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov di,0<br>mov ax,[di+123]<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>[bx + si + idata]和[bx +di + idata]格式的灵活应用。</p></li></ol><h1 id="视频35（第七章-更灵活定位内存地址04）"><a href="#视频35（第七章-更灵活定位内存地址04）" class="headerlink" title="视频35（第七章 更灵活定位内存地址04）"></a>视频35（第七章 更灵活定位内存地址04）</h1><ol><li><p>几种定位内存地址的方法，也称为寻址方式如下：</p><ol><li>[idata]用一个常量来表示地址，可用于直接定义一个内存单元。</li><li>[bx]用一个变量来保存内存地址，可用于间接定位一个内存单元。</li><li>[bx + idata]用一个变量和常量来表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元。</li><li>[bx + si]用两个变量表示地址。</li><li>[bx + si + idata]用两个变量和一个常量来表示地址。</li></ol></li><li><p>[bx + idata]的示例，将程序中的数据段中的数据的第一个字母改成大写，其中每个字符串占16字节，代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data<br>data segment<br>db &#39;1. file    &#39;<br>db &#39;2. edit    &#39;<br>db &#39;3. search  &#39;<br>db &#39;4. view    &#39;<br>db &#39;5. options &#39;<br>db &#39;6. help    &#39;<br>data ends<br><br>code segment<br>start:mov ax,data<br>mov ds,ax<br>mov bx,0<br><br>mov cx,6<br>s:mov al,[bx + 3]<br>and al,1101111B<br>mov [bx + 3],al<br>add bx,16<br>loop s<br><br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ol><center><h1>day08（2020年3月13日）</h1></center><h1 id="视频36（第七章-更灵活定位内存地址05）"><a href="#视频36（第七章-更灵活定位内存地址05）" class="headerlink" title="视频36（第七章 更灵活定位内存地址05）"></a>视频36（第七章 更灵活定位内存地址05）</h1><blockquote><p>使用栈的数据结构来存储临时数据，用[bx + si]这种定位内存地址方法实现将程序中的数据段中的数据的所有字母改成大写，其中每个字符串占16字节。</p></blockquote><ol><li><p>使用DX寄存器来临时保存CX中的值，代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data<br>data segment<br>db &#39;ibm.............&#39;<br>db &#39;dec.............&#39;<br>db &#39;dos.............&#39;<br>db &#39;vax.............&#39;<br>db 0<br>data ends<br><br>code segment<br>start:mov ax,data<br>mov ds,ax<br><br>mov bx,0<br>mov cx,4<br><br>s:mov ds:[40H],cx<br>mov si,0<br>mov cx,3<br>s2:mov al,[bx + si]<br>and al,11011111B<br>mov [bx + si],al<br>inc si<br>loop s2<br>mov cx,ds:[40H]<br>add bx,16<br>loop s<br><br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li><li><p>使用栈来临时保存CX中的值，代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data,ss:stack<br>data segment<br>db &#39;ibm.............&#39;<br>db &#39;dec.............&#39;<br>db &#39;dos.............&#39;<br>db &#39;vax.............&#39;<br>db 0<br>data ends<br><br>stack segment<br>db 0<br>stack ends<br><br>code segment<br>start:mov ax,data<br>mov ds,ax<br><br>mov bx,0<br>mov cx,4<br><br>s:push cx<br>mov si,0<br>mov cx,3<br>s2:mov al,[bx + si]<br>and al,11011111B<br>mov [bx + si],al<br>inc si<br>loop s2<br>pop cx<br>add bx,16<br>loop s<br><br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li></ol><h1 id="视频37（第七章-更灵活定位内存地址06）"><a href="#视频37（第七章-更灵活定位内存地址06）" class="headerlink" title="视频37（第七章 更灵活定位内存地址06）"></a>视频37（第七章 更灵活定位内存地址06）</h1><blockquote><ol><li>使用[bx + idata + si]实现将数据段中的数据从指定位开始到后面4位字母改为大写字母。</li><li>然后是第七章的总结。</li></ol></blockquote><ol><li><p>使用[bx + idata + si]实现将数据段中的数据从指定位开始到后面4位字母改为大写字母，代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs asm">assume cs:code,ds:data,ss:stack<br>data segment<br>db &#39;1. dispaly......&#39;<br>db &#39;2. brows........&#39;<br>db &#39;3. replace......&#39;<br>db &#39;4. modify.......&#39;<br>data ends<br><br>stack segment<br>db 0<br>stack ends<br><br>code segment<br>start:mov ax,data<br>mov ds,ax<br>mov ax,stack<br>mov ss,ax<br>mov sp,40H<br>mov bx,0<br><br>mov cx,4<br>s:push cx<br>mov si,0<br>mov cx,4<br>s2:mov al,[bx + 3 + si]<br>and al,11011111B<br>mov [bx + 3 +si],al<br>inc si<br>loop s2<br><br>add bx,16<br>pop cx<br>loop s<br><br>mov ax,4c00H<br>int 21H<br>code ends<br>end start<br></code></pre></td></tr></table></figure></li><li><p>总结</p><ul><li>这一章中，我们主要学习了更灵活的寻址方式的应用和一些编程方法，主要内容有：<ul><li>寻址方式：[bx (或si、di) + idata]、[bx + si (或di)]、[bx + si (或di) + idata]。</li><li>二重循环问题的处理。</li><li>栈的应用。</li><li>大小写转化技巧。</li></ul></li></ul></li></ol><center><h1>day09（2020年3月16日）</h1></center><h1 id="视频38（第八章-数据处理的两个基本问题01）"><a href="#视频38（第八章-数据处理的两个基本问题01）" class="headerlink" title="视频38（第八章 数据处理的两个基本问题01）"></a>视频38（第八章 数据处理的两个基本问题01）</h1><ol><li><p>通用寄存器包括：AX、BX、CX、DX、AH、AL、BH、BL、CH、CL、DH、DL、SP、BP、SI、DI。</p></li><li><p>段寄存器包括：DS、SS、CS、ES。</p></li><li><p>通用寄存器中，只有BX、BP、SI、DI这四个寄存器可以用在<code>[]</code>中来进行内存单元的寻址。</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200316112740991.png" class=""></li><li><p>在<code>[]</code>中，这四个寄存器(BX、BP、SI、DI)可以单个出现，也可以组合出现。</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200316112917937.png" class=""></li><li><p>只要在<code>[]</code>中使用寄存器BP，而指令中没有显性的给出段地址，段地址就默认在SS寄存器中。</p></li><li><p>指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200316113407734.png" class=""></li><li><p>寻址方式小结</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200316113638510.png" class=""></li></ol><h1 id="视频39（第八章-数据处理的两个基本问题02）"><a href="#视频39（第八章-数据处理的两个基本问题02）" class="headerlink" title="视频39（第八章 数据处理的两个基本问题02）"></a>视频39（第八章 数据处理的两个基本问题02）</h1><ol><li><p>各种寻址方式的动画展示。</p></li><li><p>告诉指令要处理的的数据有多长，即是字长度（16位）还字节长度（8位）。</p><p>指定数据长度的三种方式：</p><ol><li>通过寄存器名指明要处理的数据的尺寸，比如ax就是字，al就是字节。</li><li>在没有寄存器名的情况下，用操作符ptr指明内存单元的长度，比如<code>mov word ptr ds:[0],1</code>就是字，<code>mov byte ptr ds:[0],1</code>就是字节。</li><li>栈的pop和push命令默认就是以字为单位，需要注意。</li></ol></li></ol><h1 id="视频40（第八章-数据处理的两个基本问题03）"><a href="#视频40（第八章-数据处理的两个基本问题03）" class="headerlink" title="视频40（第八章 数据处理的两个基本问题03）"></a>视频40（第八章 数据处理的两个基本问题03）</h1><ol><li>通过一个实例来理解寻址方式的综合应用。</li></ol><h1 id="视频41-（第八章-数据处理的两个基本问题04）"><a href="#视频41-（第八章-数据处理的两个基本问题04）" class="headerlink" title="视频41 （第八章 数据处理的两个基本问题04）"></a>视频41 （第八章 数据处理的两个基本问题04）</h1><ol><li><p>div是除法指令，使用div做除法的时候需要注意：</p><ul><li>被除数默认放在AX或DX和AX中。</li><li>除数可以是8位的也可以是16位的，可以放在寄存器或者内存单元中。</li><li>当除数是8位时，被除数应该是16位，放在AX中。当除数是16位时，被除数应该是32位，高16位放在DX中，低16位放在AX中。</li></ul></li><li><p>div除法的结果分布如下：</p><ol><li>如果除数是8位的时候（被除数为16位），商是存放在AL中的，余数是存放在AH中的。</li><li>如果除数是16位的时候（被除数为32位），商是存放在AX中的，余数是存放在DX中的。</li></ol></li><li><p>div指令格式</p><ul><li>div 寄存器。</li><li>div 内存单元。</li></ul><p>示例，除数为8位时：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">div byte ptr ds:[0]<br></code></pre></td></tr></table></figure><p>该程序的商表示方式为：(al) = (ax) / ((ds) * 16 + 0) 的商。</p><p>该程序的余数表示方式为：(ah) =  (ax) / ((ds) * 16 + 0) 的余数。</p><p>示例，除数为16位时：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">div word ptr es:[0]<br></code></pre></td></tr></table></figure><p>该程序的商表示方式为：(ax) =  [(dx) * 10000H + (ax)] / ((es) * 16 + 0) 的商。</p><p>该程序的余数表示方式为：(dx) =  [(dx) * 10000H + (ax)] / ((es) * 16 + 0)    的余数。</p><p><b>重点理解一下，为什么要乘以10000H？</b></p><p>举个例子来理解，比如被除数是一个32位的数据，根据规定，把高16位放在DX寄存器中，把低16位放在AX寄存器中。假如一个数据是357896H，首先我们先将低16位寄存器填充完，即AX = 7896H，那么高16位寄存器DX = 0035H。现在如果要将数据还原为357896H，就应该是 DX * 16的4次方 + AX，16的4次方正好转化为16进制就是10000H。那么为什么是4次方，因为35相当于向左移动了4位，又因为数据是16进制的，所以是16的四次方。</p><p>这和10进制是相同的道理，想一想，假如一个数是2456，如果用两位表示低位，用两位表示高位。那么低位就是56，高位就是24,当要还原数据时，其实就是24 * 10的2次方 + 56 = 2456。因为数据时10进制的，所以是10的2次方。</p><p>通过上面的解释，就可以知道为什么有：段地址 * 16 + 偏移地址 = 物理地址。8086CPU一次能处理20位，但是一个寄存器能存储16位，为了让CPU不浪费资源，将两个16位寄存器组成一个20位。这样就有效利用了CPU的计算能力，但是这样其实是浪费了12个寄存器单元。因为CPU是处理数据的，而寄存器是存放数据的，所以选择了舍弃空间，来提升程序的速度效率更高。</p></li><li><p>伪指令 dd，dd伪指令和db、dw含义一样，只是dd表示的是一个双字型数据的意思。即占32位。</p></li><li><p>伪指令dup，dup是一个操作符，用来定义数据的重复。</p><p>格式为：</p><ul><li><p>db 重复的次数 dup（重复的字节型数据）。</p></li><li><p>dw 重复的次数 dup（重复的字型数据）。</p></li><li><p>dd 重复的次数 dup（重复的双字型数据）。</p></li></ul><p>例子如下：</p><p>db 3 dup(0)：定义了3个字节，它们的值都为0。</p><p>db 3 dup(0,1,2)：定义了9个字节，它们的值为：0、1、2、0、1、2、0、1、2。</p></li></ol><h1 id="视频42（第八章-数据处理的两个基本问题06）"><a href="#视频42（第八章-数据处理的两个基本问题06）" class="headerlink" title="视频42（第八章 数据处理的两个基本问题06）"></a>视频42（第八章 数据处理的两个基本问题06）</h1><ol><li>一个十分复杂的联系题。后面视频看完后，可以自己动手做一下。</li></ol><h1 id="视频43（第九章-转移指令的原理01）"><a href="#视频43（第九章-转移指令的原理01）" class="headerlink" title="视频43（第九章 转移指令的原理01）"></a>视频43（第九章 转移指令的原理01）</h1><ol><li><p>操作符offset，也是一个伪指令，在汇编语言中是由编译器处理的符号，它的功能是获取标号的<b>偏移地址</b>。</p></li><li><p>jmp指令，为无条件转移，可以只修改IP寄存器，也可以同时修改CS和IP寄存器。</p></li><li><p>jmp short 标号，<b>也称为段内短转移</b>，它对IP的修改范围为 -128 ~ 127，即向前最多能转移128个字节，向后最多能转移127个字节。作用是转到标号处执行指令。</p></li><li><p>jmp的实现原理详解</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200316165826205.png" class=""><p>​    jmp short s 指令的读取和执行过程如下：</p><ol><li>如上图所示，现在（CS）= 0BBDH，（IP）= 0006H，此时 jmp 000BH 对应的机器码为：EB03H。</li><li>CPU将机器码EB03H读取到指令缓冲器。</li><li>(IP) = (IP) + 2 = 0008H，这里加2是应为EB03H占用了两个字节，此时CS:IP指向汇编指令 add ax,0001H。</li><li>CPU执行指令缓冲器中的指令 EB 03H，这里的EB对应汇编指令就是jmp。03H即在当前IP的值下加3，<b>如果是负数该值就是补码形式</b>。</li><li>指令执行 EB 03H 后，(IP) = 000BH，CS:IP指向汇编指令 inc ax。</li><li>jmp near ptr 标号，<b>也称为段内近转移</b>，该指令和jmp short 标号作用相同，唯一不同就是，它对IP的修改范围是2个字节，即 -32768~32767。</li></ol></li></ol><h1 id="视频44（第九章-转移指令的原理02）"><a href="#视频44（第九章-转移指令的原理02）" class="headerlink" title="视频44（第九章 转移指令的原理02）"></a>视频44（第九章 转移指令的原理02）</h1><ol><li>jmp far ptr 标号，实现的是段间转移，又称为远转移。</li><li>转移地址在内存中的jmp指令有两种格式，分别如下：<ol><li>jmp word ptr 内存单元地址，这是一种段内转移，它的功能是从内存单元地址处开始存放一个字，该字是转移的目的偏移地址。</li><li>jmp dword ptr 内存单元地址，这是一种段间转移，它的功能是从内存单元地址处开始存放两个字，高地址处的字是转移的目的的段地址，低地址处的字是转移的目的的偏移地址。</li></ol></li></ol><h1 id="视频45（第九章-转移指令的原理03）"><a href="#视频45（第九章-转移指令的原理03）" class="headerlink" title="视频45（第九章 转移指令的原理03）"></a>视频45（第九章 转移指令的原理03）</h1><ol><li><p>jcxz为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为 -128~127。</p><p>指令格式：jcxz 标号。这个指令和CX寄存器有联系，如果CX的值为0，则转移到标号处执行。当CX不为0时，程序会向下执行。</p></li><li><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为 -128~127。</p><p>指令格式：loop 标号。这个指令和CX寄存器有联系，如果CX的值不为0，就会一直循环到CX为0才会结束，每循环一次(cx) = (cx) - 1。</p></li></ol><h1 id="视频46（第九章-转移指令的原理04）"><a href="#视频46（第九章-转移指令的原理04）" class="headerlink" title="视频46（第九章 转移指令的原理04）"></a>视频46（第九章 转移指令的原理04）</h1><ol><li><p>jmp short 标号、jmp near  ptr 标号、jcxz 标号、loop 标号，这几种汇编指令它们对IP的修改时根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p></li><li><p>在段内转移为什么是用位移距离来达到转移效果？</p><p>如果机器码中包含的是目的地址，则就对程序段在内存中的偏移地址有了严格的限制，某个程序的偏移地址被改变了，就意味着相应的转移会出现问题。</p></li><li><p>注意，根据位移进行转移的指令，它们的转移范围收到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将会报错。</p></li><li><p>jmp 2000:0100 这种转移指令只能在debug程序中使用，汇编编译器并不认识，所以在源程序中这样使用，编译时会报错。</p></li></ol><h1 id="视频47（第九章-实验8和实验九详细讲解）"><a href="#视频47（第九章-实验8和实验九详细讲解）" class="headerlink" title="视频47（第九章  实验8和实验九详细讲解）"></a>视频47（第九章  实验8和实验九详细讲解）</h1><ol><li>分析实验8，理解位移。</li><li>分析实验9，在显示屏上显示数据。</li></ol><center><h1>day10（2020年3月17日）</h1></center><h1 id="视频48（第十章-call和ret指令01）"><a href="#视频48（第十章-call和ret指令01）" class="headerlink" title="视频48（第十章 call和ret指令01）"></a>视频48（第十章 call和ret指令01）</h1><ol><li><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p></li><li><p>ret指令用栈中的数据，修改IP的内容，从而实现<b>近转移</b>。</p><p>CPU在执行ret指令的时候，进行下面两步操作：</p><ol><li>(IP) = ((ss) * 16 + (SP))：使IP的值为栈顶的值。</li><li>(SP) = (SP) + 2：出栈一个字，偏移地址指向下一个字。</li></ol></li><li><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现<b>远转移</b>。</p><p>CPU执行retf指令时，进行下面四步操作：</p><ol><li>(IP) = ((ss) * 16 + (SP))：使IP的值为栈顶的值。</li><li>(SP) = (SP) + 2：出栈一个字，偏移地址指向下一个字。</li><li>(CS) = ((ss) * 16 + (SP))：使CS的值为栈顶的值。</li><li>(SP) = (SP) + 2：出栈一个字，偏移地址指向下一个字。</li></ol><p>retf指令会出现两次出栈的操作，第一次出栈是修改IP的内容，第二次出栈是修改CS的内容。</p></li><li><p>可以看出，用汇编语言来解释ret和retf指令，就有：</p><ul><li><p>CPU执行ret指令时，相当于进行</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">pop IP<br></code></pre></td></tr></table></figure></li><li><p>CPU执行retf指令时，相当于执行</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">pop IP<br>pop CS<br></code></pre></td></tr></table></figure></li></ul></li><li><p>call指令跟ret指令配合使用，因此CPU执行call指令，进行两部操作：</p><ol><li>将当前IP或CS和IP压如栈中。</li><li>转移(jmp)。</li></ol></li><li><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令原理相同。</p></li><li><p>call指令格式为：call 标号。</p><p>作用是将当前的IP压栈后，转到标号处执行指令。CPU在执行此种格式的call指令时，进行如下的操作：</p><ol><li>(SP) = (SP) - 2：进行压栈操作。</li><li>(IP) = ((SS) * 16 + (IP))：将IP的偏移地址指向栈顶地址。</li><li>(IP) = (IP) + 16位位移。16位位移 = <code>标号</code>处的地址 - call指令后的第一个字节的地址。16位位移的范围为-32768~32767，用补码表示。</li></ol></li><li><p>CPU执行<code>call 标号</code>时，相当于进行了</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">push IP<br>jmp near ptr 标号<br></code></pre></td></tr></table></figure></li></ol><h1 id="视频49（第十章-call和ret指令02）"><a href="#视频49（第十章-call和ret指令02）" class="headerlink" title="视频49（第十章 call和ret指令02）"></a>视频49（第十章 call和ret指令02）</h1><ol><li><p>指令<code>call far ptr 标号</code>实现的是段间转移。CPU执行<code>call far ptr 标号</code>这种格式的call指令时的操作如下：</p><ol><li><p>(SP) = (SP) - 2：栈顶偏移地址减二。</p><p>((SS) * 16 + (SP)) = (CS)：将当前的段地址，保存在栈顶中。</p><p>(SP) = (SP) - 2：栈顶偏移地址减二。</p><p>((SS) * 16 + (SP)) = (IP)：把当前指令的下一个指令的偏移地址，保存在栈顶中。</p></li><li><p>把CX的值变成标号所在的段地址。</p><p>把IP的值变成标号所在的偏移地址。</p></li></ol><p>这样就形成了让标号处的代码先执行，然后再使用retf指令回到<code>call far ptr 标号</code>处，执行下一行代码。</p><p>从汇编语言来解释<code>call far ptr 标号</code>,相当于进行如下操作：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push CS<br>push IP<br>jmp far ptr 标号<br></code></pre></td></tr></table></figure></li><li><p>指令<code>call 16位寄存器</code>实现的是段内转移。CPU执行<code>call 16位寄存器</code>这种格式的call指令时的操作如下：</p><ol><li>(SP) = (SP) - 2：栈顶偏移地址减二。</li><li>((SS) * 16 + (SP)) = (IP)：把当前指令的下一个指令的偏移地址，保存在栈顶中。</li><li>(IP) = 16位寄存器：将IP的值指向16位寄存器的值。</li></ol></li><li><p>转移地址在内存中的call指令有两种格式：</p><ol><li><p>call word ptr 内存单元地址。</p><p>汇编语法解释为：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">push IP<br>jmp word ptr 内存单元地址<br></code></pre></td></tr></table></figure></li><li><p>call dword ptr 内存单元地址。</p><p>汇编语法解释为：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push CS<br>push IP<br>jmp dword ptr 内存单元地址<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="视频50（第十章-call和ret指令03）"><a href="#视频50（第十章-call和ret指令03）" class="headerlink" title="视频50（第十章 call和ret指令03）"></a>视频50（第十章 call和ret指令03）</h1><ol><li><p>call指令后面的指令的地址将存储在栈中，所以可以在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p></li><li><p>我们可以利用call和ret来实现子程序机制。</p></li><li><p>mul指令，mul指令时乘法指令，在使用mul做乘法的时候，需要注意：</p><ol><li>相乘的两个数，要么都是8位，要么都是16位。</li><li>如果是8位相乘，结果就放在AX寄存器中；如果是16位相乘，高位放在DX中，低位放在AX中。</li></ol></li><li><p>mul指令格式：</p><ol><li>mul 寄存器。</li><li>mul 内存单元</li></ol></li><li><p>内存单元可以用不同的寻址方式给出。比如：</p><ul><li><p>mul byte ptr ds:[0]：含义为，(AX) = (AL) * ((DS) * 16 + 0)。</p></li><li><p>mul word ptr [bx + si + 8]：含义为，(AX) = (AX) * ((DS) * 16 + (BX) + (SI) + 8)结果的低16位。</p><p>(DX) = (AX) * ((DS) * 16 + (BX) + (SI) + 8)结果的高16位。</p></li></ul></li><li><p>call与ret指令共同支持了汇编语言编程中模块化设计。在实际编程中，程序的模块化是必不可少的。因为现实的问题通常比较复杂，对现实问题进行分析时，把它转化成相互联系、不同层次的子问题，是必须的解决方法。</p></li></ol><h1 id="视频51（第十章-call和ret指令04）"><a href="#视频51（第十章-call和ret指令04）" class="headerlink" title="视频51（第十章 call和ret指令04）"></a>视频51（第十章 call和ret指令04）</h1><ol><li>使用内存实现批量数据传递。</li><li>编写3个复杂小程序，后面有时间可以看看。</li></ol><h1 id="视频52（第十章-call和ret指令05）"><a href="#视频52（第十章-call和ret指令05）" class="headerlink" title="视频52（第十章 call和ret指令05）"></a>视频52（第十章 call和ret指令05）</h1><ol><li>前两个程序的实现与详解。</li></ol><h1 id="视频53（第十章-call和ret指令06）"><a href="#视频53（第十章-call和ret指令06）" class="headerlink" title="视频53（第十章 call和ret指令06）"></a>视频53（第十章 call和ret指令06）</h1><h1 id="视频54（第十一章-标志寄存器01）"><a href="#视频54（第十一章-标志寄存器01）" class="headerlink" title="视频54（第十一章 标志寄存器01）"></a>视频54（第十一章 标志寄存器01）</h1><ol><li><p>标志寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p></li><li><p>标志寄存器中的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何意义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义。</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200317153516229.png" class=""></li><li><p>ZF位，称为<b>零标志位</b>。</p><p>记录相关指令执行后的结果是否为0，如果为0，ZF = 1，否则，ZF = 0。</p><p>add、sub、div、mul、inc、or、and这些指令的执行是会影响到该标志位的。</p><p>mov、push、pop这些指令的执行是不会影响该标志位的。</p></li><li><p>PF位，称为<b>奇偶标志位</b>。</p><p>记录相关指令执行后的二进制结果中1的个数为奇数还是偶数，如果为偶数，PF = 1，否则，PF = 0。</p></li><li><p>SF位，称为<b>符号标志位</b>。</p><p>记录相关指令执行后的结果是正数还是负数。如果为正数，SF = 0，否则，SF = 1。</p></li></ol><h1 id="视频55（第十一章-标志寄存器02）"><a href="#视频55（第十一章-标志寄存器02）" class="headerlink" title="视频55（第十一章 标志寄存器02）"></a>视频55（第十一章 标志寄存器02）</h1><ol><li><p>CF位，称为<b>进位标志位</b>。</p><p>一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><p>CPU在进行运算时，当出现了要向高位进位，但是位数又不足时，比如两个8位数相加，98H + 98H就存在进位问题，但是进位值无法再保存在8位数中，所以CPU就用标志寄存器中的CF位来记录这个进位值。</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200317162221907.png" class=""><p>另外一种情况，当连个数据做减法的时候，有可能向高位借位。比如，两个8位数据：97H - 98H，将产生借位的情况，借位后，相当于197H - 98H。</p></li><li><p>OF位，称为<b>溢出标志位</b>。</p><p>在进行有符号数运算时，如结果超过了机器所能表示的范围称为溢出。</p><p>什么是机器所能表示的范围？</p><p>答：比如 add al,3，如果我们当做有符号运算时，最高位为符号位，即不能表示数据，所以范围就是-128~127。</p><p>如果在进行有符号运算时，出现了溢出情况，那么运算的结果将不正确。</p></li><li><p>CF和OF的区别</p><ul><li>CF是对无符号数运算有意义的标志位。</li><li>OF是对有符号数运算有意义的标志位。</li></ul></li><li><p>对于有无符号，计算机是分不清楚状况的，因此它必须两种都记载着，关于是有符号运算还是无符号元素，要看编写代码的人怎么理解，程序员认为是无符号运算就看CF标志位，程序员认为是有符号运算就看OF标志位。</p><p>例如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,98<br>add al,99<br></code></pre></td></tr></table></figure><ul><li>对于无符号运算来说，98 + 99 = 197 &lt; 255，所以没有进位，所以CF = 0。</li><li>对于有符号运算来说，98 + 99 = -59，数据不对，是应为结果被溢出了，所以OF = 1。</li></ul></li><li><p>adc是带进位加法指令，它利用CF位上记录的进位值。</p><p>格式：adc 操作对象一，操作对于二。</p><p>功能：操作对象一 = 操作对象一 + 操作对象二 + CF。</p><p>比如：adc ax,bx实现的功能是：(AX)  = (AX) + (BX) + CF。</p></li></ol><h1 id="视频56（第十一章-标志寄存器03）"><a href="#视频56（第十一章-标志寄存器03）" class="headerlink" title="视频56（第十一章 标志寄存器03）"></a>视频56（第十一章 标志寄存器03）</h1><ol><li><p>sbb指令，sbb是带借位减法指令，它利用了CF位上记录的借位值。</p><p>格式：sbb 操作对象一，操作对象二。</p><p>功能：操作对象一 = 操作对象一 - 操作对象二 - CF。</p><p>比如：sbb ax,bx实现的功能是：(AX) = (AX) - (BX) - CF</p></li><li><p>利用sbb指令我们可以对任意大的数据进行减法运算。比如计算003E1000H - 00202000H，结果放在AX，BX中，程序如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov bx,1000H<br>mov ax,003EH<br>sub bx,2000H<br>sbb ax,0020H<br></code></pre></td></tr></table></figure></li><li><p>sbb和adc是基于同样的思路设计的两条指令，在应用思路上和adc类似。</p></li><li><p>cmp指令，是比较指令，功能相当于减法指令，只是不保存结果。cmp指令执行后，会对标志寄存器产生影响。这样，其他相关的指令通过识别标志寄存器中被影响的标志位就可以得到比较结果。</p><p>格式：cmp 操作对象一，操作对象二。</p><p>功能：操作对象一 - 操作对象二，但是并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><p>比如：cmp ax,ax。在做(AX) - (AX)的运算，结果为0，但并不在AX中保存，仅仅影响标志寄存器的相应位。</p><p>指令在执行后：ZF = 1，PF = 1，SF = 0，CF = 0，OF = 0。</p></li><li><p>通过cmp指令执行后，根据相关标志位的值就可以看出比较结果，例如：cmp ax,bx就可以得到下面的结论</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200317175439473.png" class=""></li><li><p>cmp指令同add、sub指令一样，CPU在执行cmp指令时，也包含两种含义：</p><ol><li>进行无符号数运算和进行有符号数运算。</li><li>利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较</li></ol></li></ol><center><h1>day11（2020年3月19日）</h1></center><h1 id="视频57（第十一章-标志寄存器04）"><a href="#视频57（第十一章-标志寄存器04）" class="headerlink" title="视频57（第十一章 标志寄存器04）"></a>视频57（第十一章 标志寄存器04）</h1><ol><li><p>用cmp来进行有符号数比较时，我们需要注意哪些标志位。</p><ul><li><p>我们以cmp ah,bh为例进行说明：</p><p>如果(ah) = (bh)，则(ah) - (bh) = 0，所以ZF = 1。</p><p>如果(ah) != (bh)，则(ah) - (bh) != 0，所以ZF = 0。</p><p>所以我们根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。</p></li><li><p>如果(ah) &lt; (bh)则可能发生什么情况？</p><p>对于有符号的运算，在(ah) &lt; (bh)的情况下，(ah) - (bh)显然可能引起SF = 1，即结果为负。</p><p>比如 (ah) = 1，(bh) = 2，则 (ah) - (bh) = 0FFH，0FFH为-1的补码，这是SF = 1，所以结果为负，所以结果为-1。</p></li><li><p>我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知结果是否溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。</p></li><li><p>因为cmp指令可以进行两种比较，即无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即：</p><ol><li>根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值。</li><li>根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF、ZF的值。</li></ol></li><li><p>检测比较结果的条件转移指令</p><img src="/2020/03/19/%E5%B0%8F%E7%94%B2%E9%B1%BC%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200319110046468.png" class=""><p>注意观察它们所检测的标志位，都是cmp指令进行无符号数比较时候，记录比较结果的标志位。</p><p>比如je，检测ZF位，当ZF为1的时候进行转移，如果在je前面使用了cmp指令，那么je对ZF的检测，实际上就是间接的检测cmp的比较结果是否为两数相等。</p></li></ul></li></ol><h1 id="视频58（第十一章-标志寄存器05）"><a href="#视频58（第十一章-标志寄存器05）" class="headerlink" title="视频58（第十一章 标志寄存器05）"></a>视频58（第十一章 标志寄存器05）</h1><ol><li><p>编程实现如下功能，如果(ah) = (bh)则(ah) = (ah) + (ah)，否则(ah) = (ah) + (bh)。</p><p>核心代码如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">cmp ah,bh<br>je s<br>add ah,bh<br>jmp short ok<br>s:add ah,ah<br>ok:ret<br></code></pre></td></tr></table></figure></li><li><p>je检测的是ZF位置，不管je前面是什么指令，只要CPU执行je指令时，ZF = 1，那么就会发生转移。</p><p>比如下面的代码：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,0<br>add ax,0<br>je s<br>inc ax<br>s:inc ax<br></code></pre></td></tr></table></figure><p>代码执行后，(ax) = 1。add ax,0 使得ZF = 1，所以je指令将进行转移。</p></li><li><p>DF标志和串传送指令。</p><p>标志寄存器的第10位是DF标志位，也称为<b>方向标志位</b>。在串处理指令中，控制每次操作后si，di的增减。</p><p>DF = 0：每次操作后si，di递增。</p><p>DF = 1：每次操作后si，di递减。</p><ul><li><p>格式：movsb。</p><p>功能：以字节为单位传送，将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减。</p><ol><li>((es) * 16 + (di)) = ((dx) * 16 + (si))</li><li>如果DF = 0，则(si) = (si) + 1，(di) = (di) + 1。如果DF = 1，则(si) = (si) - 1，(di) = (di) - 1。</li></ol></li><li><p>格式movsw</p><p>功能：以字为单位传送，将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2。</p></li></ul></li><li><p>movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式为：rep movsb。</p><p>rep的作用是根据cx的值，重复执行后面的串传送指令。</p><p>由于每一次执行movsb指令si和di都会递增或递减一个单元，则rep movsb就可以循环实现（cx）个字符的传送。</p></li><li><p>由于DF位决定着串传送指令执行后，si和di的改变方向，所以CPU应该提供相应的指令来对DF位进行设置，从而使程序员能过决定传送的方向。</p><p>8086CPU提供如下两条指令对DF位进行设置：</p><ol><li>cld指令：将DF的值设置为0。</li><li>std指令：将DF的值设置为1。</li></ol></li></ol><h1 id="视频59（第十一章-标志寄存器06）"><a href="#视频59（第十一章-标志寄存器06）" class="headerlink" title="视频59（第十一章 标志寄存器06）"></a>视频59（第十一章 标志寄存器06）</h1><ol><li>pushf和popf<ul><li>pushf：将标志寄存器的值压栈。</li><li>popf：从栈中弹出数据，送入标志寄存器中。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合使用WebSocket</title>
      <link href="/2020/01/15/Spring-Boot-%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8WebSocket/"/>
      <url>/2020/01/15/Spring-Boot-%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8WebSocket/</url>
      
        <content type="html"><![CDATA[<p>使用 websocket 有两种方式：</p><ol><li><p>是使用 sockjs。</p></li><li><p>是使用 h5 的标准。</p></li></ol><p>使用 Html5 标准自然更方便简单，所以记录的是配合 h5 的使用方法。</p><h1 id="1、pom"><a href="#1、pom" class="headerlink" title="1、pom"></a>1、pom</h1><p>核心是 <code>@ServerEndpoint</code> 这个注解。这个注解是 Javaee 标准里的注解，tomcat7 以上已经对其进行了实现，如果是用传统方法使用 tomcat 发布项目，只要在 pom 文件中引入 javaee 标准即可使用。</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaee-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但使用 springboot 的内置 tomcat 时，就不需要引入javaee-api了，spring-boot 已经包含了。使用 springboot的websocket 功能首先引入 springboot 组件。</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>顺便说一句，springboot 的高级组件会自动引用基础的组件，像 spring-boot-starter-websocket 就引入了 spring-boot-starter-web 和 spring-boot-starter，所以不要重复引入。</p><a id="more"></a><h1 id="2、使用-ServerEndpoint创立websocket-endpoint"><a href="#2、使用-ServerEndpoint创立websocket-endpoint" class="headerlink" title="2、使用@ServerEndpoint创立websocket endpoint"></a>2、使用@ServerEndpoint创立websocket endpoint</h1><p>首先要注入 ServerEndpointExporter ，这个 bean 会自动注册使用了 <code>@ServerEndpoint</code> 注解声明的 Websocket endpoint 。要注意，如果使用独立的servlet容器，而不是直接使用springboot的内置容器，就不要注入  ServerEndpointExporter ，因为它将由容器自己提供和管理。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServerEndpointExporter <span class="hljs-title">serverEndpointExporter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServerEndpointExporter();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是写 websocket 的具体实现类，很简单，直接上代码：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ServerEndpoint</span>(value = <span class="hljs-string">"/websocket"</span>)<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebSocket</span> </span>&#123;<br>    <span class="hljs-comment">//静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> onlineCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;MyWebSocket&gt;();<br><br>    <span class="hljs-comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span><br>    <span class="hljs-keyword">private</span> Session session;<br><br>    <span class="hljs-comment">/**<br>     * 连接建立成功调用的方法<br>     */</span><br>    <span class="hljs-meta">@OnOpen</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.session = session;<br>        webSocketSet.add(<span class="hljs-keyword">this</span>);     <span class="hljs-comment">//加入set中</span><br>        addOnlineCount();           <span class="hljs-comment">//在线数加1</span><br>        System.out.println(<span class="hljs-string">"有新连接加入！当前在线人数为"</span> + getOnlineCount());<br>        <span class="hljs-keyword">try</span> &#123;<br>            sendMessage(CommonConstant.CURRENT_WANGING_NUMBER.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            System.out.println(<span class="hljs-string">"IO异常"</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 连接关闭调用的方法<br>     */</span><br>    <span class="hljs-meta">@OnClose</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span> </span>&#123;<br>        webSocketSet.remove(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">//从set中删除</span><br>        subOnlineCount();           <span class="hljs-comment">//在线数减1</span><br>        System.out.println(<span class="hljs-string">"有一连接关闭！当前在线人数为"</span> + getOnlineCount());<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 收到客户端消息后调用的方法<br>     *<br>     * <span class="hljs-doctag">@param</span> message 客户端发送过来的消息<br>     */</span><br>    <span class="hljs-meta">@OnMessage</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message, Session session)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"来自客户端的消息:"</span> + message);<br><br>        <span class="hljs-comment">//群发消息</span><br>        <span class="hljs-keyword">for</span> (MyWebSocket item : webSocketSet) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                item.sendMessage(message);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 发生错误时调用<br>     *<br>     */</span><br>    <span class="hljs-meta">@OnError</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Session session, Throwable error)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"发生错误"</span>);<br>        error.printStackTrace();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">this</span>.session.getBasicRemote().sendText(message);<br>        <span class="hljs-comment">//this.session.getAsyncRemote().sendText(message);</span><br>    &#125;<br><br><br>    <span class="hljs-comment">/**<br>     * 群发自定义消息<br>     * <br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">for</span> (MyWebSocket item : webSocketSet) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                item.sendMessage(message);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOnlineCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> onlineCount;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOnlineCount</span><span class="hljs-params">()</span> </span>&#123;<br>        MyWebSocket.onlineCount++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subOnlineCount</span><span class="hljs-params">()</span> </span>&#123;<br>        MyWebSocket.onlineCount--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 springboot 的唯一区别是要 <code>@Component</code> 声明下，而使用独立容器是由容器自己管理 websocket 的，但在 springboot 中连容器都是spring管理的。</p><p>虽然 <code>@Component</code> 默认是单例模式的，但 springboot 还是会为每个 websocket 连接初始化一个 bean，所以可以用一个静态 set 保存起来。</p><h1 id="3、前端代码"><a href="#3、前端代码" class="headerlink" title="3、前端代码　"></a>3、前端代码　</h1><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My WebSocket<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>Welcome<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"send()"</span>&gt;</span>Send<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"closeWebSocket()"</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"message"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><br>    <span class="hljs-keyword">var</span> websocket = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//判断当前浏览器是否支持WebSocket</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">'WebSocket'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)&#123;<br>        websocket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">"ws://localhost:8084/websocket"</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        alert(<span class="hljs-string">'Not support websocket'</span>)<br>    &#125;<br><br>    <span class="hljs-comment">//连接发生错误的回调方法</span><br>    websocket.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        setMessageInnerHTML(<span class="hljs-string">"error"</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">//连接成功建立的回调方法</span><br>    websocket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>        setMessageInnerHTML(<span class="hljs-string">"open"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//接收到消息的回调方法</span><br>    websocket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>        setMessageInnerHTML(event.data);<br>    &#125;<br><br>    <span class="hljs-comment">//连接关闭的回调方法</span><br>    websocket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        setMessageInnerHTML(<span class="hljs-string">"close"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span><br>    <span class="hljs-built_in">window</span>.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        websocket.close();<br>    &#125;<br><br>    <span class="hljs-comment">//将消息显示在网页上</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMessageInnerHTML</span>(<span class="hljs-params">innerHTML</span>)</span>&#123;<br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'message'</span>).innerHTML += innerHTML + <span class="hljs-string">'&lt;br/&gt;'</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//关闭连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeWebSocket</span>(<span class="hljs-params"></span>)</span>&#123;<br>        websocket.close();<br>    &#125;<br><br>    <span class="hljs-comment">//发送消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> message = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'text'</span>).value;<br>        websocket.send(message);<br>    &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>springboot 已经做了深度的集成和优化，要注意是否添加了不需要的依赖、配置或声明。由于很多讲解组件使用的文章是和 spring 集成的，会有一些配置，在使用 springboot 时，由于 springboot 已经有了自己的配置，再这些配置有可能导致各种各样的异常。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁知识点总结</title>
      <link href="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是锁"><a href="#1-什么是锁" class="headerlink" title="1 什么是锁"></a>1 什么是锁</h1><h2 id="1-1-锁的概述"><a href="#1-1-锁的概述" class="headerlink" title="1.1 锁的概述"></a>1.1 锁的概述</h2><p>在生活中锁的例子多的不能再多了，从古老的简单的门锁，到密码锁，再到现在的指纹解锁，人脸识别锁，这都是锁的鲜明的例子，所以，我们理解锁应该是非常简单的。</p><p>再到MySQL中的锁，对于MySQL来说，锁是一个很重要的特性，数据库的锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性，这样才能保证在高并发的情况下，访问数据库的时候，数据不会出现问题。</p><a id="more"></a><h2 id="1-2-锁的两个概念"><a href="#1-2-锁的两个概念" class="headerlink" title="1.2 锁的两个概念"></a>1.2 锁的两个概念</h2><p>在数据库中，lock和latch都可以称为锁，但是意义却不同。</p><p><strong>Latch</strong>一般称为<code>闩锁</code>（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差，在InnoDB引擎中，Latch又可以分为<code>mutex</code>（互斥量）和<code>rwlock</code>（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p><p><strong>Lock</strong>的对象是<code>事务</code>，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</p><h1 id="2-InnoDB存储引擎中的锁"><a href="#2-InnoDB存储引擎中的锁" class="headerlink" title="2 InnoDB存储引擎中的锁"></a>2 InnoDB存储引擎中的锁</h1><h2 id="2-1-锁的粒度"><a href="#2-1-锁的粒度" class="headerlink" title="2.1 锁的粒度"></a>2.1 锁的粒度</h2><p>在数据库中，锁的粒度的不同可以分为表锁、页锁、行锁，这些锁的粒度之间也是会发生升级的，<strong>锁升级</strong>的意思就是讲当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁，下面分别介绍一下这三种锁的粒度</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。</p><p>当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。</p><p>使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</p><p><strong>特点：</strong> 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源 颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。<br>使用页级锁定的主要是BerkeleyDB存储引擎。</p><p><strong>特点：</strong> 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>行级锁定最大的特点就是锁定对象的粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p><p>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。</p><p><strong>特点：</strong> 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p>比较表锁我们可以发现，这两种锁的特点基本都是相反的，而从锁的角度来说，<strong>表级锁</strong>更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而<strong>行级锁</strong>则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><p><strong>MySQL 不同引擎支持的锁的粒度</strong></p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640.webp" class=""><h2 id="2-2-锁的类型"><a href="#2-2-锁的类型" class="headerlink" title="2.2 锁的类型"></a>2.2 锁的类型</h2><p>InnoDB存储引擎中存在着不同类型的锁，下面一一介绍一下。</p><p><strong>S or X (共享锁、排他锁)</strong></p><p>数据的操作其实只有两种，也就是读和写，而数据库在实现锁时，也会对这两种操作使用不同的锁；InnoDB 实现了标准的<strong>行级锁</strong>，也就是<strong>共享锁（Shared Lock）和互斥锁（Exclusive Lock）</strong>。</p><ul><li>共享锁（读锁）（S Lock），允许事务读一行数据。</li><li>排他锁（写锁）（X Lock），允许事务删除或更新一行数据。</li></ul><p><strong>IS or IX (共享、排他)意向锁</strong></p><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB存储引擎支持一种额外的锁方式，就称为<strong>意向锁</strong>，意向锁在 InnoDB 中是<strong>表级锁</strong>，意向锁分为：</p><ul><li>意向共享锁：表达一个事务想要获取一张表中某几行的共享锁。</li><li>意向排他锁：表达一个事务想要获取一张表中某几行的排他锁。</li></ul><p>另外，这些锁之间的并不是一定可以共存的，有些锁之间是不兼容的，所谓<strong>兼容性</strong>就是指事务 A 获得一个某行某种锁之后，事务 B 同样的在这个行上尝试获取某种锁，如果能立即获取，则称锁兼容，反之叫冲突。</p><p>下面我们再看一下这两种锁的兼容性。</p><ul><li><p>S or X (共享锁、排他锁)的兼容性</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579059618780.webp" class=""></li><li><p>IS or IX (共享、排他)意向锁的兼容性</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579059634686.webp" class=""></li></ul><h1 id="3-前面小结"><a href="#3-前面小结" class="headerlink" title="3 前面小结"></a>3 前面小结</h1><p>这里用一个思维导图把前面的概念做一个小结。</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579059659087.webp" class=""><h1 id="4-一致性非锁定读和一致性锁定读"><a href="#4-一致性非锁定读和一致性锁定读" class="headerlink" title="4 一致性非锁定读和一致性锁定读"></a>4 一致性非锁定读和一致性锁定读</h1><p><strong>一致性锁定读（Locking Reads）</strong></p><p>在一个事务中查询数据时，普通的SELECT语句不会对查询的数据进行加锁，其他事务仍可以对查询的数据执行更新和删除操作。因此，InnoDB提供了两种类型的锁定读来保证额外的安全性：</p><ul><li><p><code>SELECT … LOCK IN SHARE MODE</code></p></li><li><p><code>SELECT ... FOR UPDATE</code></p><p><code>SELECT ... LOCK IN SHARE MODE</code>: 对读取的行添加S锁，其他事物可以对这些行添加S锁，若添加X锁，则会被阻塞。</p><p><code>SELECT ... FOR UPDATE</code>: 会对查询的行及相关联的索引记录加X锁，其他事务请求的S锁或X锁都会被阻塞。当事务提交或回滚后，通过这两个语句添加的锁都会被释放。注意：只有在自动提交被禁用时，SELECT FOR UPDATE才可以锁定行，若开启自动提交，则匹配的行不会被锁定。</p></li></ul><p><strong>一致性非锁定读</strong></p><p><strong>一致性非锁定读(consistent nonlocking read)</strong> 是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。所以，非锁定读机制大大提高了数据库的并发性。</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579059720614.webp" class=""><p>一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。在事务隔离级别<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>下，InnoDB使用一致性非锁定读。</p><p>然而，对于快照数据的定义却不同。在<code>READ COMMITTED</code>事务隔离级别下，一致性非锁定读总是<strong>读取被锁定行的最新一份快照数据</strong>。而在<code>REPEATABLE READ</code>事务隔离级别下，则<strong>读取事务开始时的行数据版本</strong>。</p><p>下面我们通过一个简单的例子来说明一下这两种方式的区别。</p><p>首先创建一张表;</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579059737442.webp" class=""><p>插入一条数据</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> lock_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>查看隔离级别</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@tx_isolation;<br><span class="hljs-comment"># MySQL8版本后用以下命令</span><br><span class="hljs-keyword">select</span> @@transaction_isolation;<br></code></pre></td></tr></table></figure><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579059874704.webp" class=""><p>下面分为两种事务进行操作。</p><p><strong>在 REPEATABLE READ 事务隔离级别下</strong></p><table>    <thead>        <tr>            <th>时间</th>            <th>会话 A</th>            <th>会话 B</th>        </tr>    </thead>    <tbody>        <tr>            <td>1</td>            <td>set session autocommit=0;</td>            <td>set session autocommit=0;</td>        </tr>        <tr>            <td>2</td>            <td>BEGIN;</td>            <td></td>        </tr>         <tr>            <td>3</td>            <td>                <p>SELECT * FROM lock_test WHERE a = 1;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115122137656.png" class="">                </p>             </td>            <td></td>        </tr>         <tr>            <td>4</td>            <td></td>            <td>BEGIN;</td>        </tr>         <tr>            <td>5</td>            <td></td>            <td>UPDATE lock_test SET a = 4 WHERE a = 1;</td>        </tr>         <tr>            <td>6</td>            <td>                <p>SELECT * FROM lock_test WHERE a = 1;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115122137656.png" class="">                </p>            </td>            <td></td>        </tr>        <tr>            <td>7</td>            <td></td>            <td>COMMIT;</td>        </tr>        <tr>            <td>8</td>            <td>                <p>SELECT * FROM lock_test WHERE a = 1;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115122137656.png" class="">                </p>            </td>            <td></td>        </tr>        <tr>            <td>9</td>            <td>COMMIT;</td>            <td></td>        </tr>        <tr>            <td>10</td>            <td>                <p>SELECT * FROM lock_test WHERE a = 1;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115123018140.png" class="">                </p>            </td>            <td></td>        </tr>    </tbody></table><p>在该模式下，事务是独立的，会话 A 只能读取从事务开始处表中的数据。</p><p>在会话 B 修改数据没有提交事务的时候，会话 A 也无法获取会话 B 修改的数据。</p><p>在会话 B 修改数据并提交事务的时候，会话 A 还是无法获取会话 B 修改的数据。</p><p>要想获取会话 B 修改的数据，只有会话 B 提交了事务，会话 A 也提交了事务，然后会话 A 再获取数据才能获取会话 B 修改的数据。</p><p><strong>在 READ COMMITTED 事务隔离级别下</strong></p><table>    <thead>        <tr>            <th>时间</th>            <th>会话 A</th>            <th>会话 B</th>        </tr>    </thead>    <tbody>        <tr>            <td>1</td>            <td>BEGIN;</td>            <td></td>        </tr>        <tr>            <td>2</td>            <td>                <p>SELECT * FROM lock_test WHERE a = 1;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115122137656.png" class="">                </p>            </td>            <td></td>        </tr>        <tr>            <td>3</td>            <td></td>            <td>BEGIN;</td>        </tr>        <tr>            <td>4</td>            <td></td>            <td>UPDATE lock_test SET a = 4 WHERE a = 1;</td>        </tr>        <tr>            <td>5</td>            <td>                <p>SELECT * FROM lock_test WHERE a = 1;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115122137656.png" class="">                </p>            </td>            <td></td>        </tr>        <tr>            <td>6</td>            <td></td>            <td>COMMIT;</td>        </tr>        <tr>            <td>7</td>            <td>                <p>SELECT * FROM lock_test WHERE a = 1;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115123018140.png" class="">                </p>            </td>            <td></td>        </tr>        <tr>            <td>8</td>            <td>COMMIT;</td>            <td></td>        </tr>    </tbody></table><p>在该模式下，会话 B 修改了数据并提交事务后，在会话 A 还没有提交事务的情况下，就能知道该数据被修改了。</p><h1 id="5-行锁的算法"><a href="#5-行锁的算法" class="headerlink" title="5 行锁的算法"></a>5 行锁的算法</h1><p>InnoDB存储引擎有3种行锁的算法，其分别是：</p><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li><li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p><strong>Record Lock</strong>：总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</p><p><strong>Next-Key Lock</strong>：结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。举个例子10，20，30，那么该索引可能被Next-Key Locking的区间为：</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579067486192.webp" class=""><p>除了Next-Key Locking，还有<strong>Previous-Key Locking</strong>技术，这种技术跟Next-Key Lock正好相反，锁定的区间是区间范围和前一个值。同样上述的值，使用Previous-Key Locking技术，那么可锁定的区间为：</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579067497475.webp" class=""><p>不是所有索引都会加上Next-key Lock的，这里有一种<strong>特殊的情况</strong>，在查询的列是唯一索引（包含主键索引）的情况下，<code>Next-key Lock</code>会降级为<code>Record Lock</code>。</p><p>接下来，我们来通过一个例子解释一下。</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">test</span> (<br>    x <span class="hljs-built_in">INT</span>,<br>    y <span class="hljs-built_in">INT</span>,<br>    PRIMARY <span class="hljs-keyword">KEY</span>(x),    // x是主键索引<br>    <span class="hljs-keyword">KEY</span>(y)    // y是普通索引<br>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">select</span> <span class="hljs-number">3</span>, <span class="hljs-number">2</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">select</span> <span class="hljs-number">5</span>, <span class="hljs-number">3</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">select</span> <span class="hljs-number">7</span>, <span class="hljs-number">6</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">select</span> <span class="hljs-number">10</span>, <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>我们现在会话A中执行如下语句</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">WHERE</span> y = <span class="hljs-number">3</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span><br></code></pre></td></tr></table></figure><p>我们分析一下这时候的加锁情况。</p><ul><li>对于主键x</li></ul><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579067542408.webp" class=""><ul><li>辅助索引y</li></ul><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579067551650.webp" class=""><p>用户可以通过以下两种方式来显示的关闭Gap Lock：</p><ul><li>将事务的隔离级别设为 READ COMMITED。</li><li>将参数innodb_locks_unsafe_for_binlog设置为1。</li></ul><p><strong>Gap Lock的作用</strong>：是为了阻止多个事务将记录插入到同一个范围内，设计它的目的是用来解决<strong>Phontom Problem（幻读问题）</strong>。在MySQL默认的隔离级别（Repeatable Read）下，InnoDB就是使用它来解决幻读问题。</p><blockquote><p><b>幻读</b>：是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL可能会返回之前不存在的行，也就是第一次执行和第二次执行期间有其他事务往里插入了新的行。</p></blockquote><h1 id="6-锁带来的问题"><a href="#6-锁带来的问题" class="headerlink" title="6 锁带来的问题"></a>6 锁带来的问题</h1><h2 id="6-1-脏读"><a href="#6-1-脏读" class="headerlink" title="6.1 脏读"></a>6.1 脏读</h2><p><strong>脏读：</strong> 在不同的事务下，当前事务可以读到另外事务未提交的数据。另外我们需要注意的是默认的MySQL隔离级别是<code>REPEATABLE READ</code>是不会发生脏读的，脏读发生的条件是需要事务的隔离级别为<code>READ UNCOMMITTED</code>，所以如果出现脏读，可能就是这种隔离级别导致的。</p><p>下面我们通过一个例子看一下。</p><table>    <thead>        <th>时间</th>        <th>会话 A</th>        <th>会话 B</th>    </thead>    <tbody>        <tr>            <td>1</td>            <td>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>            <td>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</td>        </tr>        <tr>            <td>2</td>            <td></td>            <td>BEGIN;</td>        </tr>        <tr>            <td>3</td>            <td></td>            <td>                <p>SELECT * FROM lock_test;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115122137656.png" class="">                </p>            </td>        </tr>        <tr>            <td>4</td>            <td>                BEGIN;                <br/>                INSERT INTO lock_test VALUES(2);                <br/>                COMMIT;            </td>            <td></td>        </tr>        <tr>            <td>5</td>            <td></td>            <td>                <p>SELECT * FROM lock_test;</p>                <p>                    结果：                    <img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/image-20200115141224576.png" class="">                </p>            </td>        </tr>        <tr>            <td>6</td>            <td></td>            <td>COMMIT;</td>        </tr>    </tbody></table><p>在该模式下，会话 A 新增的数据在提交事务后，在会话 B 中的事务中就能获取到数据了。</p><h2 id="6-2-不可重复读"><a href="#6-2-不可重复读" class="headerlink" title="6.2 不可重复读"></a>6.2 不可重复读</h2><p><strong>不可重复读：</strong> 是指在一个事务内多次读取同一集合的数据，但是多次读到的数据是不一样的，这就违反了数据库事务的一致性的原则。但是，这跟脏读还是有区别的，脏读的数据是没有提交的，但是不可重复读的数据是已经提交的数据。</p><p>在前面 <a href="#4-一致性非锁定读和一致性锁定读">4 一致性非锁定读和一致性锁定读</a> 中的「<strong>在 READ COMMITTED 事务隔离级别下</strong>」 知识点下已经模拟了不可重复的例子，可以回去看一下。</p><h2 id="6-3-丢失更新"><a href="#6-3-丢失更新" class="headerlink" title="6.3 丢失更新"></a>6.3 丢失更新</h2><p><strong>丢失更新：</strong>指的是一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致。在当前数据库的任何隔离级别下都不会导致丢失更新问题，要出现这个问题，在多用户计算机系统环境下有可能出现这种问题。</p><p>如何避免丢失更新的问题呢，我们只需要让事务的操作变成串行化，不要并行执行就可以。</p><p>我们一般使用<code>SELECT ... FOR UPDATE</code>语句，给操作加上一个排他X锁。</p><h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h2><p>这里我们做一个小结，主要是在不同的事务的隔离级别下出现的问题的对照，这样就更加清晰了。</p><img src="/2020/01/15/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/640-1579069244813.webp" class=""><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>以上就是我自己对 MySQL 数据库锁的理解。本文是在参考别人的文章然后结合自己的理解整理的。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用教程</title>
      <link href="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h1><p>Git是目前世界上最先进的分布式版本控制系统。<br>工作原理 / 流程：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640.webp" class=""><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h1 id="SVN与Git的最主要的区别？"><a href="#SVN与Git的最主要的区别？" class="headerlink" title="SVN与Git的最主要的区别？"></a>SVN与Git的最主要的区别？</h1><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><a id="more"></a><h1 id="在windows上如何安装Git？"><a href="#在windows上如何安装Git？" class="headerlink" title="在windows上如何安装Git？"></a>在windows上如何安装Git？</h1><p>msysgit是 windows版的Git,如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056058554.webp" class=""><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056104690.webp" class=""><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056113384.webp" class=""><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056122670.webp" class=""><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p>注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><h1 id="如何操作？"><a href="#如何操作？" class="headerlink" title="如何操作？"></a>如何操作？</h1><h2 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1. 创建版本库"></a>1. 创建版本库</h2><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056176864.webp" class=""><p>pwd 命令是用于显示当前的目录。</p><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056189017.webp" class=""><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056200074.webp" class=""><p>下面先看下demo如下演示：</p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056209779.webp" class=""><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p>第二步：用命令 git commit告诉Git，把文件提交到仓库。</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056217206.webp" class=""><p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056227404.webp" class=""><p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056240935.webp" class=""><p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p><p>把文件添加到版本库中。</p><p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：</p><p>git diff readme.txt 如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056253086.webp" class=""><p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p><p>如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056263818.webp" class=""><h2 id="2-版本回退"><a href="#2-版本回退" class="headerlink" title="2. 版本回退"></a>2. 版本回退</h2><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行</p><p>内容为33333333333333.继续执行命令如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056284976.webp" class=""><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056294798.webp" class=""><p>git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056303544.webp" class=""><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056314053.webp" class=""><p>如果想回退到上一个版本的命令如下操作：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056333956.webp" class=""><p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056346553.webp" class=""><p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056354765.webp" class=""><p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p><p>git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056364017.webp" class=""><p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令</p><p>git reset –hard 6fcfc89来恢复了。演示如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056372491.webp" class=""><p>可以看到 目前已经是最新的版本了。</p><h2 id="3-理解工作区与暂存区的区别"><a href="#3-理解工作区与暂存区的区别" class="headerlink" title="3. 理解工作区与暂存区的区别"></a>3. 理解工作区与暂存区的区别</h2><p>工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。<br>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><p>我们前面说过使用Git提交文件到版本库有两步：</p><p><strong>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</strong></p><p><strong>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</strong></p><p>我们继续使用demo来演示下：</p><p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056402327.webp" class=""><p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056411505.webp" class=""><p>接着我们可以使用git commit一次性提交到分支上，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056420436.webp" class=""><h2 id="4-Git撤销修改和删除文件操作"><a href="#4-Git撤销修改和删除文件操作" class="headerlink" title="4. Git撤销修改和删除文件操作"></a>4. Git撤销修改和删除文件操作</h2><h3 id="1-撤销修改"><a href="#1-撤销修改" class="headerlink" title="1. 撤销修改"></a>1. 撤销修改</h3><p>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056476889.webp" class=""><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><p><strong>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</strong></p><p><strong>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</strong></p><p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056491377.webp" class=""><p>可以发现，Git会告诉你，git checkout – file 可以丢弃工作区的修改，如下命令：<br>git checkout – readme.txt,如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056499799.webp" class=""><p>命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p><p><strong>1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。<br>2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</strong><br>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056511626.webp" class=""><p>注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</p><h3 id="2-删除文件"><a href="#2-删除文件" class="headerlink" title="2. 删除文件"></a>2. 删除文件</h3><p>假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056532903.webp" class=""><p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056544223.webp" class=""><p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？</p><p>可以使用如下命令 git checkout – b.txt，如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056557764.webp" class=""><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056565962.webp" class=""><h2 id="5-远程仓库"><a href="#5-远程仓库" class="headerlink" title="5. 远程仓库"></a>5. 远程仓库</h2><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：<br>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p>ssh-keygen -t rsa –C “<a href="mailto:youremail@example.com">youremail@example.com</a>”, 由于我本地此前运行过一次，所以本地有，如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056605128.webp" class=""><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056615081.webp" class=""><p>点击 Add Key，你就应该可以看到已经添加的key。</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056624890.webp" class=""><h3 id="1-如何添加远程库"><a href="#1-如何添加远程库" class="headerlink" title="1. 如何添加远程库"></a>1. 如何添加远程库</h3><p>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056667419.webp" class=""><p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056676563.webp" class=""><p>目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库</p><p>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://github.com/tugenhua0707/testgit.git<br></code></pre></td></tr></table></figure><p>所有的如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056712744.webp" class=""><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056722668.webp" class=""><p>从现在起，只要本地作了提交，就可以通过如下命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master<br></code></pre></td></tr></table></figure><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p><h3 id="2-如何从远程库克隆"><a href="#2-如何从远程库克隆" class="headerlink" title="2. 如何从远程库克隆"></a>2. 如何从远程库克隆</h3><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p><p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p><p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056766967.webp" class=""><p>如下，我们看到：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056776660.webp" class=""><p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056789278.webp" class=""><p>接着在我本地目录下 生成testgit2目录了，如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056797267.webp" class=""><h2 id="6-创建与合并分支"><a href="#6-创建与合并分支" class="headerlink" title="6. 创建与合并分支"></a>6. 创建与合并分支</h2><p>在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056824664.webp" class=""><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch dev<br></code></pre></td></tr></table></figure><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout dev<br></code></pre></td></tr></table></figure><p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056856797.webp" class=""><p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056865858.webp" class=""><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056873093.webp" class=""><p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>合并完成后，我们可以接着删除dev分支了，操作如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056885459.webp" class=""><p>总结创建与合并分支命令如下：</p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><p><strong>如何解决冲突</strong></p><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056966328.webp" class=""><p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056976034.webp" class=""><p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579056989668.webp" class=""><p>Git用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057370066.webp" class=""><p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057379296.webp" class=""><p>分支管理策略。通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p><ul><li>创建一个dev分支。</li><li>修改readme.txt内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并dev分支，使用命令 git merge –no-ff -m “注释” dev</li><li>查看历史记录</li></ul><p>截图如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057430223.webp" class=""><p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="7-bug分支"><a href="#7-bug分支" class="headerlink" title="7. bug分支"></a>7. bug分支</h2><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057455164.webp" class=""><p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057464274.webp" class=""><p>所以现在我可以通过创建issue-404分支来修复bug了。</p><p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057472752.webp" class=""><p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057480910.webp" class=""><p>现在，我们回到dev分支上干活了。</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057488740.webp" class=""><p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057498618.webp" class=""><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><p><strong>1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。<br>2.另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</strong><br>演示如下</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057509648.webp" class=""><h2 id="8-多人协作"><a href="#8-多人协作" class="headerlink" title="8. 多人协作"></a>8. 多人协作</h2><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><ol><li>要查看远程库的信息 使用 git remote</li><li>要查看远程库的详细信息 使用 git remote –v</li></ol><p>如下演示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057539188.webp" class=""><h3 id="1-推送分支"><a href="#1-推送分支" class="headerlink" title="1. 推送分支"></a>1. 推送分支</h3><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：使用命令 git push origin master</p><p>比如我现在的github上的readme.txt代码如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057558515.webp" class=""><p>本地的readme.txt代码如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057566101.webp" class=""><p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057575410.webp" class=""><p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057582912.webp" class=""><p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p><p>那么一般情况下，那些分支要推送呢？</p><p>master分支是主分支，因此要时刻与远程同步。<br>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p><h3 id="2-抓取分支"><a href="#2-抓取分支" class="headerlink" title="2. 抓取分支"></a>2. 抓取分支</h3><p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</p><p>但是我首先要把dev分支也要推送到远程去，如下</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057610535.webp" class=""><p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057619748.webp" class=""><p>现在目录下生成有如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057627397.webp" class=""><p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout –b dev origin/dev<br></code></pre></td></tr></table></figure><p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p><p>如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057648760.webp" class=""><p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057659017.webp" class=""><p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057668619.webp" class=""><p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057677361.webp" class=""><p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：<br>我们可以先来看看readme.txt内容了。</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057685738.webp" class=""><p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p><img src="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/640-1579057694804.webp" class=""><p>因此：多人协作工作模式一般是这样的：</p><p>首先，可以试图用git push origin branch-name推送自己的修改.<br>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。<br>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。  </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 版本控制 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中使用 Zookeeper 客户端 Curator 详解</title>
      <link href="/2020/01/08/Java-%E4%B8%AD%E4%BD%BF%E7%94%A8-Zookeeper-%E5%AE%A2%E6%88%B7%E7%AB%AF-Curator-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/08/Java-%E4%B8%AD%E4%BD%BF%E7%94%A8-Zookeeper-%E5%AE%A2%E6%88%B7%E7%AB%AF-Curator-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>因为最近项目需要使用Zookeeper这个中间件，提前了解一下它的客户端Curator的使用。</p><p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。Patrixck Hunt（Zookeeper）以一句“Guava is to Java that Curator to Zookeeper”给Curator予高度评价。</p><p>Curator无疑是Zookeeper客户端中的瑞士军刀，它译作”馆长”或者’’管理者’’，不知道是不是开发小组有意而为之，笔者猜测有可能这样命名的原因是说明Curator就是Zookeeper的馆长(脑洞有点大：Curator就是动物园的园长)。<br>Curator包含了几个包：</p><ul><li>curator-framework：对zookeeper的底层api的一些封装。</li><li>curator-client：提供一些客户端的操作，例如重试策略等。</li><li>curator-recipes：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等。</li></ul><a id="more"></a><p>Maven依赖（注意zookeeper版本  这里对应的是3.4.6）</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Curator的基本Api"><a href="#Curator的基本Api" class="headerlink" title="Curator的基本Api"></a>Curator的基本Api</h1><h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p><strong>方式一</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/*<br>    创建重试策略对象，参数含义如下：<br>    - baseSleepTimeMs: 基本睡眠时间。<br>    - maxRetries：最大重试次数。<br>    */</span><br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">/*<br>    创建客户端对象，参数含义如下：<br>    - connectString：服务器列表，格式为 `host1:port,host2:port,...`。<br>    - sessionTimeoutMs：会话超时时间， 默认 60000 ms。<br>    - connectionTimeoutMs：连接超时时间，默认 60000 ms。<br>    - retryPolicy：重试策略<br>    */</span><br>    CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retryPolicy);<br>    <span class="hljs-comment">// 连接 zookeeper 服务器</span><br>    client.start();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式二</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .build();<br>    client.start();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建包含隔离命名空间的会话</strong></p><p>为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（NameSpace），即指定一个Zookeeper的根路径（官方术语：为Zookeeper添加“Chroot”特性）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一课子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>CuratorFramework client =<br>CuratorFrameworkFactory.builder()<br>.connectString(connectionInfo)<br>.sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>.connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>.retryPolicy(retryPolicy)<br>.namespace(<span class="hljs-string">"base"</span>)<br>.build();<br></code></pre></td></tr></table></figure><h2 id="数据节点基本操作（增删改查）"><a href="#数据节点基本操作（增删改查）" class="headerlink" title="数据节点基本操作（增删改查）"></a>数据节点基本操作（增删改查）</h2><p><strong>Zookeeper的节点创建模式：</strong></p><ul><li>PERSISTENT：持久化</li><li>PERSISTENT_SEQUENTIAL：持久化并且带序列号</li><li>EPHEMERAL：临时</li><li>EPHEMERAL_SEQUENTIAL：临时并且带序列号</li></ul><p>增删改查操作如下</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .build();<br>    client.start();<br>    <span class="hljs-comment">// 删除一个节点，并且递归删除其所有的子节点</span><br>    client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/study"</span>);<br>    LOGGER.info(<span class="hljs-string">"清除上一次测试的数据成功！"</span>);<br>&#125;<br><br><span class="hljs-comment">/**<br> * 基本操作<br> * <span class="hljs-doctag">@throws</span> Exception<br> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">"study"</span>)<br>        .build();<br>    client.start();<br>    <span class="hljs-comment">/**<br>     * 创建节点<br>     */</span><br>    <span class="hljs-comment">// 创建一个节点，初始内容为空</span><br>    client.create().forPath(<span class="hljs-string">"/name"</span>);<br>    <span class="hljs-comment">// 创建一个节点，附带初始化内容</span><br>    client.create().forPath(<span class="hljs-string">"/name2"</span>, <span class="hljs-string">"创建一个节点，附带初始化内容"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br>    <span class="hljs-comment">// 创建一个节点，指定创建模式（临时节点），内容为空</span><br>    client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/name3"</span>);<br>    <span class="hljs-comment">// 创建一个节点，指定创建模式（临时节点），附带初始化内容</span><br>    client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/name4"</span>, <span class="hljs-string">"创建一个节点，指定创建模式（临时节点），附带初始化内容"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br>    <span class="hljs-comment">// 创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</span><br>    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/parent/name5"</span>, <span class="hljs-string">"创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br><br>    <span class="hljs-comment">/**<br>     * 更新数据节点数据<br>     */</span><br>    <span class="hljs-comment">// 更新一个节点的数据内容</span><br>    client.setData().forPath(<span class="hljs-string">"/name2"</span>, <span class="hljs-string">"更新一个节点的数据内容"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br>    <span class="hljs-comment">// 更新一个节点的数据内容，强制指定版本进行更新</span><br>    client.setData().withVersion(<span class="hljs-number">0</span>).forPath(<span class="hljs-string">"/name"</span>, <span class="hljs-string">"更新一个节点的数据内容，强制指定版本进行更新"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br><br>    <span class="hljs-comment">/**<br>     * 读取节点<br>     */</span><br>    <span class="hljs-comment">// 读取一个节点的数据内容</span><br>    String s = <span class="hljs-keyword">new</span> String(client.getData().forPath(<span class="hljs-string">"/name2"</span>), Charset.forName(<span class="hljs-string">"utf-8"</span>));<br>    LOGGER.info(<span class="hljs-string">"读取一个节点的数据内容, s: [&#123;&#125;]"</span>, s);<br>    <span class="hljs-comment">// 读取一个节点的数据内容，同时获取到该节点的stat</span><br>    Stat stat = <span class="hljs-keyword">new</span> Stat();<br>    s = <span class="hljs-keyword">new</span> String(client.getData().storingStatIn(stat).forPath(<span class="hljs-string">"/name"</span>), Charset.forName(<span class="hljs-string">"utf-8"</span>));<br>    LOGGER.info(<span class="hljs-string">"读取一个节点的数据内容，同时获取到该节点的stat, s: [&#123;&#125;], stat: [&#123;&#125;]"</span>, s, stat);<br><br>    <span class="hljs-comment">/**<br>     * 删除节点<br>     */</span><br>    <span class="hljs-comment">// 删除一个节点</span><br>    client.delete().forPath(<span class="hljs-string">"/name"</span>);<br>    <span class="hljs-comment">// 删除一个节点，并且递归删除其所有的子节点</span><br>    client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/parent"</span>);<br><br>    <span class="hljs-comment">/**<br>     * 检查节点是否存在，不存在时对象为 null<br>     */</span><br>    stat = client.checkExists().forPath(<span class="hljs-string">"/name5"</span>);<br>    LOGGER.info(<span class="hljs-string">"检查节点是否存在, stat: [&#123;&#125;]"</span>, stat);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>CuratorFramework的实例包含inTransaction( )接口方法，调用此方法开启一个ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交。一个例子如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">"study"</span>)<br>        .build();<br>    client.start();<br><br>    <span class="hljs-comment">// 事务操作，保证原子性</span><br>    client.inTransaction()<br>        .create().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/name"</span>, <span class="hljs-string">"aaaaa"</span>.getBytes())<br>        .and().setData().forPath(<span class="hljs-string">"/name"</span>, <span class="hljs-string">"bbb"</span>.getBytes())<br>        .and().commit();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h2><p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator提供异步接口，引入了BackgroundCallback接口用于处理异步接口调用之后服务端返回的结果信息。BackgroundCallback接口中一个重要的回调值为CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p><p><strong>CuratorEventType</strong></p><table><thead><tr><th align="center">事件类型</th><th align="center">对应CuratorFramework实例的方法</th></tr></thead><tbody><tr><td align="center">CREATE</td><td align="center">#create()</td></tr><tr><td align="center">DELETE</td><td align="center">#delete()</td></tr><tr><td align="center">EXISTS</td><td align="center">#checkExists()</td></tr><tr><td align="center">GET_DATA</td><td align="center">#getData()</td></tr><tr><td align="center">SET_DATA</td><td align="center">#setData()</td></tr><tr><td align="center">CHILDREN</td><td align="center">#getChildren()</td></tr><tr><td align="center">SYNC</td><td align="center">#sync(String,Object)</td></tr><tr><td align="center">GET_ACL</td><td align="center">#getACL()</td></tr><tr><td align="center">SET_ACL</td><td align="center">#setACL()</td></tr><tr><td align="center">WATCHED</td><td align="center">#Watcher(Watcher)</td></tr><tr><td align="center">CLOSING</td><td align="center">#close()</td></tr></tbody></table><p><strong>响应码(#getResultCode())</strong></p><table><thead><tr><th align="center">响应码</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK，即调用成功</td></tr><tr><td align="center">-4</td><td align="center">ConnectionLoss，即客户端与服务端断开连接</td></tr><tr><td align="center">-110</td><td align="center">NodeExists，即节点已经存在</td></tr><tr><td align="center">-112</td><td align="center">SessionExpired，即会话过期</td></tr></tbody></table><p>一个异步创建节点的例子如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test04App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br><span class="hljs-meta">@Before</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .build();<br>    client.start();<br>    <span class="hljs-comment">// 删除一个节点，并且递归删除其所有的子节点</span><br>    Stat stat = client.checkExists().forPath(<span class="hljs-string">"/study"</span>);<br>    <span class="hljs-keyword">if</span> (stat != <span class="hljs-keyword">null</span>) &#123;<br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/study"</span>);<br>    &#125;<br>    LOGGER.info(<span class="hljs-string">"清除上一次测试的数据成功！"</span>);<br>&#125;<br><br><span class="hljs-comment">/**<br> * 异步操作<br> * <span class="hljs-doctag">@throws</span> Exception<br> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">"study"</span>)<br>        .build();<br>    client.start();<br><br>    Executor executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).inBackground(<span class="hljs-keyword">new</span> BackgroundCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(CuratorFramework client, CuratorEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            LOGGER.info(<span class="hljs-string">"开始调用回调方法，WatchedEvent: [&#123;&#125;], ResultCode: [&#123;&#125;]"</span>, event.getType(), event.getResultCode());<br>        &#125;<br>    &#125;, executor).forPath(<span class="hljs-string">"/name"</span>);<br><br>    <span class="hljs-comment">// 不让程序结束，否则看不到回调方法的调用</span><br>    <span class="hljs-keyword">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure><p><b>注意：</b>如果#inBackground()方法不指定executor，那么会默认使用Curator的EventThread去进行异步处理。</p><h1 id="Curator-高级特性"><a href="#Curator-高级特性" class="headerlink" title="Curator 高级特性"></a>Curator 高级特性</h1><p><b>提醒：</b>强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，curator-recipes下的所有Api将会失效或者过期，尽管后面所有的例子都没有使用到ConnectionStateListener。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Zookeeper原生支持通过注册Watcher来进行事件监听，但是开发者需要反复注册(Watcher只能单次注册单次使用)。Cache是Curator中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听。Curator提供了三种Watcher(Cache)来监听结点的变化。</p><h3 id="Path-Cache"><a href="#Path-Cache" class="headerlink" title="Path Cache"></a>Path Cache</h3><p>Path Cache用来监控一个ZNode的子节点. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过PathChildrenCacheListener通知。</p><p>实际使用时会涉及到四个类：</p><ul><li>PathChildrenCache</li><li>PathChildrenCacheEvent</li><li>PathChildrenCacheListener</li><li>ChildData</li></ul><p>通过下面的构造函数创建Path Cache:</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathChildrenCache</span><span class="hljs-params">(CuratorFramework client, String path, <span class="hljs-keyword">boolean</span> cacheData)</span></span><br></code></pre></td></tr></table></figure><p>想使用cache，必须调用它的start方法，使用完后调用close方法。 可以设置StartMode来实现启动的模式。</p><p>StartMode有下面几种：</p><ol><li>NORMAL：正常初始化。</li><li>BUILD_INITIAL_CACHE：在调用start()之前会调用rebuild()。</li><li>POST_INITIALIZED_EVENT： 当Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件。</li></ol><p><code>public void addListener(PathChildrenCacheListener listener)</code>可以增加listener监听缓存的变化。</p><p><code>getCurrentData()</code>方法返回一个List<code>&lt;ChildData&gt;</code>对象，可以遍历所有的子节点。</p><p>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作，案例如下代码所示：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.*;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 10:31<br> * <span class="hljs-doctag">@description</span> Test05App, Curator 高级特性案例<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test05App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test05App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建客户端 CuratorFramework 对象</span><br>        CuratorFramework client = CuratorFrameworkFactory.builder()<br>                .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>                .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .build();<br>        <span class="hljs-comment">// 连接 zookeeper服务器</span><br>        client.start();<br>        <span class="hljs-comment">// 创建一个 PathChildrenCache 对象来监听对应路径下的的子节点</span><br>        PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache (client, <span class="hljs-string">"/example/cache"</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 开始监听子节点变化</span><br>        pathChildrenCache.start();<br>        <span class="hljs-comment">// 当子节点数据变化时需要处理的逻辑</span><br>        pathChildrenCache.getListenable().addListener((clientFramework, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"事件类型为：&#123;&#125;"</span>, event.getType());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != event.getData()) &#123;<br>                LOGGER.info(<span class="hljs-string">"节点路径为：&#123;&#125;，节点数据为：&#123;&#125;"</span>, event.getData().getPath(), <span class="hljs-keyword">new</span> String(event.getData().getData()));<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache/test01"</span>, <span class="hljs-string">"01"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache/test02"</span>, <span class="hljs-string">"02"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache/test01"</span>, <span class="hljs-string">"01_V2"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 遍历缓存中的数据</span><br>        <span class="hljs-keyword">for</span> (ChildData childData : pathChildrenCache.getCurrentData()) &#123;<br>            LOGGER.info(<span class="hljs-string">"获取childData对象数据, Path: [&#123;&#125;], Data: [&#123;&#125;]"</span>, childData.getPath(), <span class="hljs-keyword">new</span> String(childData.getData()));<br>        &#125;<br><br>        <span class="hljs-comment">// 删除数据</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache/test01"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 删除数据</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache/test02"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 关闭监听</span><br>        pathChildrenCache.close();<br><br>        <span class="hljs-comment">// 删除测试用的数据，如果存在子节点，一并删除</span><br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/example"</span>);<br><br>        <span class="hljs-comment">// 断开与 zookeeper 的连接</span><br>        client.close();<br>        LOGGER.info(<span class="hljs-string">"程序执行完毕"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><b>注意：</b>如果new PathChildrenCache(client, PATH, true)中的参数cacheData值设置为false，则示例中的event.getData().getData()、data.getData()将返回null，cache将不会缓存节点数据。</p><p><b>注意：</b>示例中的TimeUnit.MILLISECONDS.sleep(10)可以注释掉，但是注释后事件监听的触发次数会不全，这可能与PathCache的实现原理有关，不能太过频繁的触发事件！</p><h3 id="Node-Cache"><a href="#Node-Cache" class="headerlink" title="Node Cache"></a>Node Cache</h3><p>Node Cache与Path Cache类似，Node Cache只是监听某一个特定的节点。它涉及到下面的三个类：</p><ul><li>NodeCache - Node Cache实现类</li><li>NodeCacheListener - 节点监听器</li><li>ChildData - 节点数据</li></ul><p><b>注意：</b>使用cache，依然要调用它的start()方法，使用完后调用close()方法。</p><p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.ChildData;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 11:19<br> * <span class="hljs-doctag">@description</span> Test06App, Curator 高级特性 Node Cache<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test06App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test06App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建客户端 CuratorFramework 对象</span><br>        CuratorFramework client = CuratorFrameworkFactory.builder()<br>                .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>                .build();<br><br>        <span class="hljs-comment">// 连接 zookeeper服务器</span><br>        client.start();<br><br>        <span class="hljs-comment">// 创建一个 NodeCache 对象来监听指定节点</span><br>        NodeCache nodeCache = <span class="hljs-keyword">new</span> NodeCache(client, <span class="hljs-string">"/example/cache"</span>);<br>        <span class="hljs-comment">// 当节点数据变化时需要处理的逻辑</span><br>        nodeCache.getListenable().addListener(() -&gt; &#123;<br>            ChildData currentData = nodeCache.getCurrentData();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != currentData) &#123;<br>                LOGGER.info(<span class="hljs-string">"节点数据：Path[&#123;&#125;], Data: [&#123;&#125;]"</span>,currentData.getPath() , <span class="hljs-keyword">new</span> String(currentData.getData()));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LOGGER.info(<span class="hljs-string">"节点被删除！"</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 开始监听子节点变化</span><br>        nodeCache.start();<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01_V1"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 获取节点数据</span><br>        String s = <span class="hljs-keyword">new</span> String(client.getData().forPath(<span class="hljs-string">"/example/cache"</span>));<br>        LOGGER.info(<span class="hljs-string">"数据s：[&#123;&#125;]"</span>, s);<br><br>        <span class="hljs-comment">// 删除节点</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 删除测试用的数据，如果存在子节点，一并删除</span><br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/example"</span>);<br><br>        <span class="hljs-comment">// 关闭监听</span><br>        nodeCache.close();<br><br>        <span class="hljs-comment">// 断开与 zookeeper 的连接</span><br>        client.close();<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！"</span>);<br><br>        <span class="hljs-comment">// 为了查看打印日志，不加这段代码看不到节点监听处理逻辑</span><br>        <span class="hljs-keyword">for</span> (;;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><b>注意：</b>示例中的TimeUnit.MILLISECONDS.sleep(100)可以注释，但是注释后事件监听的触发次数会不全，这可能与NodeCache的实现原理有关，不能太过频繁的触发事件！</p><p><b>注意：</b>NodeCache只能监听一个节点的状态变化。</p><h3 id="Tree-Cache"><a href="#Tree-Cache" class="headerlink" title="Tree Cache"></a>Tree Cache</h3><p>Tree Cache可以监控整个树上的所有节点，类似于PathCache和NodeCache的组合，主要涉及到下面四个类：</p><ul><li>TreeCache - Tree Cache实现类</li><li>TreeCacheListener - 监听器类</li><li>TreeCacheEvent - 触发的事件类</li><li>ChildData - 节点数据</li></ul><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCache;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 11:45<br> * <span class="hljs-doctag">@description</span> Test07App, Curator 高级特性 Tree Cache<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test07App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test07App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建客户端 CuratorFramework 对象</span><br>        CuratorFramework client = CuratorFrameworkFactory.builder()<br>                .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>                .build();<br><br>        <span class="hljs-comment">// 连接 zookeeper服务器</span><br>        client.start();<br><br>        <span class="hljs-comment">// 创建一个 NodeCache 对象来监听指定节点下的所有节点</span><br>        TreeCache treeCache = <span class="hljs-keyword">new</span> TreeCache(client, <span class="hljs-string">"/example/cache"</span>);<br>        <span class="hljs-comment">// 当指定节点下的某个节点数据变化时需要处理的逻辑</span><br>        treeCache.getListenable().addListener((curatorFramework, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"事件类型：&#123;&#125;， 路径：&#123;&#125;，数据：&#123;&#125;"</span>,<br>                    event.getType(),<br>                    event.getData() == <span class="hljs-keyword">null</span>? <span class="hljs-keyword">null</span>:event.getData().getPath(),<br>                    event.getData() == <span class="hljs-keyword">null</span>? <span class="hljs-keyword">null</span>:<span class="hljs-keyword">new</span> String(event.getData().getData()));<br>        &#125;);<br><br>        <span class="hljs-comment">// 开始监听指定节点下的所有节点变化</span><br>        treeCache.start();<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01_V2"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01_V3"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 删除节点</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 删除测试用的数据，如果存在子节点，一并删除</span><br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/example"</span>);<br><br>        <span class="hljs-comment">// 关闭监听</span><br>        treeCache.close();<br><br>        <span class="hljs-comment">// 断开与 zookeeper 的连接</span><br>        client.close();<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！"</span>);<br><br>        <span class="hljs-comment">// 为了查看打印日志，不加这段代码看不到节点监听处理逻辑</span><br>        <span class="hljs-keyword">for</span> (;;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><b>注意：</b>在此示例中没有使用TimeUnit.MILLISECONDS.sleep(100)，但是事件触发次数也是正常的。</p><p><b>注意：</b>TreeCache在初始化(调用start()方法)的时候会回调TreeCacheListener实例一个事TreeCacheEvent，而回调的TreeCacheEvent对象的Type为INITIALIZED，ChildData为null，此时event.getData().getPath()很有可能导致空指针异常，这里应该主动处理并避免这种情况。</p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>使用场景如下，当我们的某些功能要提供高可用时，比如，服务器突然崩溃了，导致功能不能访问，这时就可以把该功能部署到多台机器上，但是并不是让这些机器上的功能同时对外提供服务，而是选一台机器上的功能对外提供服务，其他机器上的功能用作备用，当正在对外提供服务的机器出现故障时，我们就执行 Leader 选举，再选择一台机器来对外提供服务，这样就保证了服务的高可用。</p><p>Curator 有两种 leader 选举的方式,分别是<strong>LeaderSelector</strong>和<strong>LeaderLatch</strong>。</p><h3 id="LeaderLatch"><a href="#LeaderLatch" class="headerlink" title="LeaderLatch"></a>LeaderLatch</h3><p>LeaderLatch有两个构造函数：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderLatch</span><span class="hljs-params">(CuratorFramework client, String latchPath)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderLatch</span><span class="hljs-params">(CuratorFramework client, String latchPath,  String id)</span></span><br></code></pre></td></tr></table></figure><p>LeaderLatch的启动：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">leaderLatch.start( );<br></code></pre></td></tr></table></figure><p>一旦启动，LeaderLatch 会和其它使用相同<code>latchPath</code>的其它 LeaderLatch 交涉，然后其中一个最终会被选举为leader，可以通过<code>leaderLatch.hasLeadership()</code>方法查看LeaderLatch实例是否leader,<code>true</code>说明当前实例是leader。</p><p><b>异常处理：</b> LeaderLatch实例可以增加ConnectionStateListener来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader不再认为自己还是leader。当LOST后连接重连后RECONNECTED,LeaderLatch会删除先前的ZNode然后重新创建一个。LeaderLatch用户必须考虑导致leadership丢失的连接问题。 强烈推荐你使用ConnectionStateListener。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderLatch;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderLatchListener;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 15:11<br> * <span class="hljs-doctag">@description</span> Test08App, Curator 高级特性 leader 选举<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test08App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test08App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-comment">/**<br>     * 使用 LeaderLatch<br>     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;CuratorFramework&gt; clientList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;LeaderLatch&gt; leaderLatchList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>            clientList.add(client);<br><br>            <span class="hljs-keyword">final</span> LeaderLatch latch = <span class="hljs-keyword">new</span> LeaderLatch(client, <span class="hljs-string">"/francis/leader"</span>, <span class="hljs-string">"#client"</span> + i);<br>            latch.addListener(<span class="hljs-keyword">new</span> LeaderLatchListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isLeader</span><span class="hljs-params">()</span> </span>&#123;<br>                    LOGGER.info(<span class="hljs-string">"I am Leader, id: [&#123;&#125;]"</span>, latch.getId());<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notLeader</span><span class="hljs-params">()</span> </span>&#123;<br>                    LOGGER.info(<span class="hljs-string">"I am not Leader, id: [&#123;&#125;]"</span>, latch.getId());<br>                &#125;<br>            &#125;);<br>            leaderLatchList.add(latch);<br><br>            client.start();<br>            latch.start();<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"程序停止10秒开始"</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>        LOGGER.info(<span class="hljs-string">"程序停止10秒结束"</span>);<br><br>        LeaderLatch currentLatch = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (LeaderLatch latch : leaderLatchList) &#123;<br>            <span class="hljs-keyword">if</span> (latch.hasLeadership()) &#123;<br>                currentLatch = latch;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        LOGGER.info(<span class="hljs-string">"current leader is &#123;&#125;"</span>, currentLatch.getId());<br>        currentLatch.close();<br>        LOGGER.info(<span class="hljs-string">"release the leader &#123;&#125;"</span>, currentLatch.getId());<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">for</span> (LeaderLatch latch : leaderLatchList) &#123;<br>            <span class="hljs-keyword">if</span> (latch.hasLeadership()) &#123;<br>                currentLatch = latch;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        LOGGER.info(<span class="hljs-string">"current leader is &#123;&#125;"</span>, currentLatch.getId());<br>        currentLatch.close();<br>        LOGGER.info(<span class="hljs-string">"release the leader &#123;&#125;"</span>, currentLatch.getId());<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">for</span> (LeaderLatch latch : leaderLatchList) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != latch.getState() &amp;&amp; !latch.getState().equals(LeaderLatch.State.CLOSED)) &#123;<br>                CloseableUtils.closeQuietly(latch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (CuratorFramework client : clientList) &#123;<br>            CloseableUtils.closeQuietly(client);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们创建了5个LeaderLatch，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。<br>通过hasLeadership查看自己是否是leader， 如果是的话返回true。<br>可以通过.getLeader().getId()可以得到当前的leader的ID。<br>只能通过close释放当前的领导权。</p><h3 id="LeaderSelector"><a href="#LeaderSelector" class="headerlink" title="LeaderSelector"></a>LeaderSelector</h3><p>LeaderSelector使用的时候主要涉及下面几个类：</p><ul><li>LeaderSelector</li><li>LeaderSelectorListener</li><li>LeaderSelectorListenerAdapter</li><li>CancelLeadershipException</li></ul><p>核心类是LeaderSelector，它的构造函数如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderSelector</span><span class="hljs-params">(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderSelector</span><span class="hljs-params">(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)</span></span><br></code></pre></td></tr></table></figure><p>类似LeaderLatch,LeaderSelector必须start: <code>leaderSelector.start();</code> 一旦启动，当实例取得领导权时你的listener的takeLeadership()方法被调用。当这个方法执行完后，该实例就会放弃 leader 的执行权。</p><p><b>注意：</b>当你不再使用LeaderSelector实例时，应该调用它的close方法。</p><p>示例代码如下，推荐继承 LeaderSelectorListenerAdapter 类并实现 Closeable 接口：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.io.Closeable;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 17:10<br> * <span class="hljs-doctag">@description</span> Test09App, Curator 高级特性 leader 选举<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test09App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test09App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;CuratorFramework&gt; clients = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;LeaderSelectorAdapter&gt; examples = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>,<br>                    <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">20000</span>, <span class="hljs-number">3</span>));<br>            clients.add(client);<br>            LeaderSelectorAdapter selectorAdapter = <span class="hljs-keyword">new</span> LeaderSelectorAdapter(client, <span class="hljs-string">"/francis/leader"</span>, <span class="hljs-string">"Client #"</span> + i);<br>            examples.add(selectorAdapter);<br>            <span class="hljs-comment">// 连接 zookeeper 服务器</span><br>            client.start();<br>            <span class="hljs-comment">// 开始执行 leader 选举</span><br>            selectorAdapter.start();<br>        &#125;<br><br>        <span class="hljs-comment">// 测试完毕后，关闭选举和会话</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">30</span>);<br>        LOGGER.info(<span class="hljs-string">"开始回收数据了哦！"</span>);<br>        <span class="hljs-keyword">for</span> (LeaderSelectorAdapter example : examples) &#123;<br>            CloseableUtils.closeQuietly(example);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (CuratorFramework client : clients) &#123;<br>            CloseableUtils.closeQuietly(client);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeaderSelectorAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LeaderSelectorListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LeaderSelector leaderSelector;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger leaderCount = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderSelectorAdapter</span><span class="hljs-params">(CuratorFramework client, String path, String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.leaderSelector = <span class="hljs-keyword">new</span> LeaderSelector(client, path, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-comment">// 希望一个 selector 放弃 leader 后还要重新参与leader选举</span><br>            <span class="hljs-keyword">this</span>.leaderSelector.autoRequeue();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            leaderSelector.start();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            leaderSelector.close();<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 当某个实例成为 leader 后就会执行这个方法，当这个方法执行完后，该实例就会放弃 leader 的执行权。<br>         * <span class="hljs-doctag">@param</span> client<br>         * <span class="hljs-doctag">@throws</span> Exception<br>         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeLeadership</span><span class="hljs-params">(CuratorFramework client)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> waitSeconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">5</span>);<br>            LOGGER.info(<span class="hljs-string">"&#123;&#125; 现在是 leader，接下来我会一直当 leader &#123;&#125; 秒钟，除开这一次，我已经当过 &#123;&#125; 次 leader 了！"</span>, name, waitSeconds, leaderCount.getAndIncrement());<br>            TimeUnit.SECONDS.sleep(waitSeconds);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么推荐继承 LeaderSelectorListenerAdapter 类来实现 leader 选举？</strong></p><p>查看 LeaderSelectorListenerAdapter 源代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Licensed to the Apache Software Foundation (ASF) under one<br> * or more contributor license agreements.  See the NOTICE file<br> * distributed with this work for additional information<br> * regarding copyright ownership.  The ASF licenses this file<br> * to you under the Apache License, Version 2.0 (the<br> * "License"); you may not use this file except in compliance<br> * with the License.  You may obtain a copy of the License at<br> *<br> *   http://www.apache.org/licenses/LICENSE-2.0<br> *<br> * Unless required by applicable law or agreed to in writing,<br> * software distributed under the License is distributed on an<br> * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br> * KIND, either express or implied.  See the License for the<br> * specific language governing permissions and limitations<br> * under the License.<br> */</span><br><span class="hljs-keyword">package</span> org.apache.curator.framework.recipes.leader;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><br><span class="hljs-comment">/**<br> * An implementation of &#123;<span class="hljs-doctag">@link</span> LeaderSelectorListener&#125; that adds the recommended handling<br> * for connection state problems<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeaderSelectorListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LeaderSelectorListener</span><br></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( (newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST) )<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CancelLeadershipException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的意思就是，如果当前实例发生SUSPENDED（暂停）或者LOST（丢失）连接问题，最好直接抛CancelLeadershipException，此时，leaderSelector实例会尝试中断并且取消正在执行takeLeadership（）方法的线程。</p><p>看 org.apache.curator.framework.recipes.leader.LeaderSelector 如下代码：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        listener.stateChanged(client, newState);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> ( CancelLeadershipException dummy )<br>    &#123;<br>        leaderSelector.interruptLeadership();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 debug 调试，当程序抛出 CancelLeadershipException 异常时会执行方法 <code>leaderSelector.interruptLeadership();</code>，该方法的作用就是让该实例放弃 leader 执行权。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p><h3 id="可重入共享锁-Shared-Reentrant-Lock"><a href="#可重入共享锁-Shared-Reentrant-Lock" class="headerlink" title="可重入共享锁 Shared Reentrant Lock"></a>可重入共享锁 Shared Reentrant Lock</h3><p><strong>Shared意味着锁是全局可见的</strong>， 客户端都可以请求锁。 Reentrant和JDK的ReentrantLock类似，即可重入， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。 它是由类InterProcessMutex来实现。 它的构造函数为：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path)</span></span><br></code></pre></td></tr></table></figure><p>通过<code>acquire()</code>获得锁，并提供超时机制：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time,TimeUnit unit)</span></span>;<br></code></pre></td></tr></table></figure><p>通过<code>release()</code>方法释放锁。 InterProcessMutex 实例可以重用。</p><p><b>特别提醒：</b>错误处理 还是强烈推荐你使用 ConnectionStateListener 处理连接状态的改变。 当连接LOST时你不再拥有锁。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/26 14:04<br> * <span class="hljs-doctag">@description</span> Test10App<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test10App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test10App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建需要共享的资源对象</span><br>        <span class="hljs-keyword">final</span> FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        <span class="hljs-comment">// 创建线程池对象</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">final</span> ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    client.start();<br>                    InterProcessMutexDemo mutexDemo = <span class="hljs-keyword">new</span> InterProcessMutexDemo(client, <span class="hljs-string">"/examples/locks"</span>, resource, <span class="hljs-string">"我是客户端: "</span> + index);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                        mutexDemo.doWork(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序出现异常！"</span>, e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 关闭会话</span><br>                    CloseableUtils.closeQuietly(client);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br><br>            <span class="hljs-comment">// 交给线程池执行</span><br>            executorService.submit(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 当线程池中的所有任务执行完后，关闭线程池</span><br>        executorService.shutdown();<br><br>        <span class="hljs-comment">// 等待除主线程外其他线程都执行完毕</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 锁<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterProcessMutexDemo</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> InterProcessMutex lock;<br>        <span class="hljs-keyword">private</span> FakeLimitedResource resource;<br>        <span class="hljs-keyword">private</span> String clientName;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMutexDemo</span><span class="hljs-params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> InterProcessMutex(client, lockPath);<br>            <span class="hljs-keyword">this</span>.resource = resource;<br>            <span class="hljs-keyword">this</span>.clientName = clientName;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-comment">/*try &#123;<br>                // 如果获取不到锁<br>                LOGGER.info("&#123;&#125;， 第一次加锁", this.clientName);<br>                if (!lock.acquire(time, unit)) &#123;<br>                    throw new RuntimeException(this.clientName + "，第一次获取锁失败！");<br>                &#125;<br><br>                // 第二次获取锁测试可重入性<br>                try &#123;<br>                    LOGGER.info("&#123;&#125;， 第二次加锁", this.clientName);<br>                    if (!lock.acquire(time, unit)) &#123;<br>                        throw new RuntimeException(this.clientName + "，第二次获取锁失败！");<br>                    &#125;<br>                    LOGGER.info("&#123;&#125; 获取到了锁！", this.clientName);<br>                    resource.use();<br>                &#125; finally &#123;<br>                    LOGGER.info("&#123;&#125; 资源使用完毕，释第二次加的锁！", this.clientName);<br>                    lock.release();<br>                &#125;<br><br>                LOGGER.info("&#123;&#125; 获取到了锁！", this.clientName);<br>                resource.use();<br>            &#125; finally &#123;<br>                LOGGER.info("&#123;&#125; 资源使用完毕，释第一次加的锁！", this.clientName);<br>                lock.release();<br>            &#125;*/</span><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果获取不到锁</span><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125;， 第一次加锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, unit)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-keyword">this</span>.clientName + <span class="hljs-string">"，第一次获取锁失败！"</span>);<br>                &#125;<br><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125;， 第二次加锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, unit)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-keyword">this</span>.clientName + <span class="hljs-string">"，第二次获取锁失败！"</span>);<br>                &#125;<br><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 获取到了锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                resource.use();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 资源使用完毕，释第一次加的锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                lock.release();<br>                lock.release();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><b>这里有个地方特别注意：</b>在上面的示例代码中，加多少次锁就要释放几次锁，不然在下次获取锁的时候就会高概率的抛异常。原因是 Curator 的分布式锁机制导致的，它创建的 zookeeper 节点的类型是<strong>临时顺序</strong>节点，而在获取节点的时候会先获取最先创建（序号最小）的节点。如果加 n 次锁过后没有释放 n 次锁，那么这个节点就依然还存活在 zookeeper 节点中，因此导致其他线程获取其他节点（序号不是最小的节点）时就获取不到锁，获取不了锁就会抛异常。之所以说是高概率而不是绝对，是因为在上面示例代码中是多线程环境，在代码中有这样一段代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关闭会话</span><br>CloseableUtils.closeQuietly(client);<br></code></pre></td></tr></table></figure><p>所以当某个线程的客户端被关闭后，也相当于 zookeeper 中对应的节点也没有了，自然另外的线程就能获取到锁了。</p><p>这个代码我研究了好久，各种猜测，最后 debug 才明白是怎么回事，所以特地记录在此！</p><h3 id="不可重入共享锁-Shared-Lock"><a href="#不可重入共享锁-Shared-Lock" class="headerlink" title="不可重入共享锁 Shared Lock"></a>不可重入共享锁 Shared Lock</h3><p>这个锁和上面的 InterProcessMutex 相比，就是少了 Reentrant 的功能，也就意味着它不能在同一个线程中重入。这个类是 <code>InterProcessSemaphoreMutex</code> ,使用方法和 <code>InterProcessMutex</code> 类似。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/27 14:43<br> * <span class="hljs-doctag">@description</span> Test11App, Curator 高级特性——不可重入共享锁 示例代码<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test11App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test11App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建共享资源对象</span><br>        <span class="hljs-keyword">final</span> FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        <span class="hljs-comment">// 创建线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 重试策略对象</span><br>        <span class="hljs-keyword">final</span> ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Runnable task = () -&gt; &#123;<br>                CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    client.start();<br>                    InterProcessSemaphoreMutexDemo mutexDemo = <span class="hljs-keyword">new</span> InterProcessSemaphoreMutexDemo(client, <span class="hljs-string">"/examples/locks"</span>, resource, <span class="hljs-string">"客户端"</span> + index);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>                        mutexDemo.doWork(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    CloseableUtils.closeQuietly(client);<br>                &#125;<br>            &#125;;<br><br>            <span class="hljs-comment">// 交给线程池执行</span><br>            executorService.submit(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 当线程池中的所有任务执行完后，关闭线程池</span><br>        executorService.shutdown();<br>        <span class="hljs-comment">// 等待除主线程外其他线程都执行完毕</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterProcessSemaphoreMutexDemo</span> </span>&#123;<br><br>        <span class="hljs-comment">/**<br>         * 不可重入贡献锁对象<br>         */</span><br>        <span class="hljs-keyword">private</span> InterProcessSemaphoreMutex lock;<br>        <span class="hljs-comment">/**<br>         * 共享资源对象<br>         */</span><br>        <span class="hljs-keyword">private</span> FakeLimitedResource resource;<br>        <span class="hljs-comment">/**<br>         * 客户端名称<br>         */</span><br>        <span class="hljs-keyword">private</span> String clientName;<br><br>        <span class="hljs-comment">/**<br>         * <span class="hljs-doctag">@param</span> client 连接 zookeeper 的客户端对象<br>         * <span class="hljs-doctag">@param</span> lockPath 锁路径<br>         * <span class="hljs-doctag">@param</span> resource 共享资源对象<br>         * <span class="hljs-doctag">@param</span> clientName 客户名称<br>         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessSemaphoreMutexDemo</span><span class="hljs-params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> InterProcessSemaphoreMutex(client, lockPath);<br>            <span class="hljs-keyword">this</span>.resource = resource;<br>            <span class="hljs-keyword">this</span>.clientName = clientName;<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 业务功能<br>         * <span class="hljs-doctag">@param</span> time<br>         * <span class="hljs-doctag">@param</span> unit<br>         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 第一次获取锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, unit)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 第一次没有获取到锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 这个示例代码是不可重入锁，所以这里会获取不了锁</span><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 第二次获取锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, TimeUnit.SECONDS)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 第二次没有获取到锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 获取到了锁，马上开始使用资源！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">this</span>.resource.use();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOGGER.error(<span class="hljs-string">"业务功能发生了异常！"</span>, e);<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 业务功能处理完了，马上开始释放锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                    <span class="hljs-keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;<br>                        lock.release();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;<br>                        lock.release();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.info(<span class="hljs-string">"释放锁发生了异常！"</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后发现，有且只有一个 client 成功获取第一个锁(第一个 acquire() 方法返回 true )，然后它自己阻塞在第二个 acquire() 方法，获取第二个锁失败，方法返回 false。这样也就验证了 <code>InterProcessSemaphoreMutex</code> 实现的锁是不可重入的。</p><h3 id="可重入读写锁-Shared-Reentrant-Read-Write-Lock"><a href="#可重入读写锁-Shared-Reentrant-Read-Write-Lock" class="headerlink" title="可重入读写锁 Shared Reentrant Read Write Lock"></a>可重入读写锁 Shared Reentrant Read Write Lock</h3><p>类似JDK的<strong>ReentrantReadWriteLock</strong>。一个读写锁管理一对相关的锁。一个负责读操作，另外一个负责写操作。读操作在写锁没被使用时可同时由多个进程使用，而写锁在使用时不允许读(阻塞)。</p><p>此锁是可重入的。<strong>一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁</strong>。这也意味着<strong>写锁可以降级成读锁， 比如请求写锁 —&gt;请求读锁—&gt;释放读锁 —-&gt;释放写锁</strong>。从读锁升级成写锁是不行的。</p><p>可重入读写锁主要由两个类实现：<code>InterProcessReadWriteLock</code>、<code>InterProcessMutex</code>。使用时首先创建一个<code>InterProcessReadWriteLock</code>实例，然后再根据你的需求得到读锁或者写锁，读写锁的类型是<code>InterProcessMutex</code>。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 13:59<br> * <span class="hljs-doctag">@description</span> Test12App, 可重入读写锁 Shared Reentrant Read Write Lock<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test12App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test12App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">final</span> FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Runnable task = () -&gt; &#123;<br>                <span class="hljs-keyword">final</span> CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    client.start();<br>                    ReentrantReadWriteLockDemo demo = <span class="hljs-keyword">new</span> ReentrantReadWriteLockDemo(client, <span class="hljs-string">"/examples/locks"</span>, resource, <span class="hljs-string">"客户端"</span> + index);<br>                    demo.doWork(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    CloseableUtils.closeQuietly(client);<br>                &#125;<br>            &#125;;<br>            executorService.execute(task);<br>        &#125;<br><br>        executorService.shutdown();<br><br>        executorService.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantReadWriteLockDemo</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessReadWriteLock lock;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessMutex readLock;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessMutex writeLock;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FakeLimitedResource resource;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String clientName;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLockDemo</span><span class="hljs-params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> InterProcessReadWriteLock(client, lockPath);<br>            <span class="hljs-keyword">this</span>.readLock = <span class="hljs-keyword">this</span>.lock.readLock();<br>            <span class="hljs-keyword">this</span>.writeLock = <span class="hljs-keyword">this</span>.lock.writeLock();<br>            <span class="hljs-keyword">this</span>.resource = resource;<br>            <span class="hljs-keyword">this</span>.clientName = clientName;<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 业务功能<br>         * <span class="hljs-doctag">@param</span> time<br>         * <span class="hljs-doctag">@param</span> unit<br>         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.writeLock.acquire(time, unit)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 不能获取到写锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                &#125;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 已得到写锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.readLock.acquire(time, unit)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 不能获取到读锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                &#125;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 已得到读锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br><br>                LOGGER.info(<span class="hljs-string">"开始使用共享资源"</span>);<br>                resource.use();<br>                LOGGER.info(<span class="hljs-string">"共享资源使用完毕"</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOGGER.error(<span class="hljs-string">"public void doWork(long time, TimeUnit unit) 方法发生异常！"</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    LOGGER.info(<span class="hljs-string">"业务处理完毕，开始释放锁"</span>);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readLock.isAcquiredInThisProcess()) &#123;<br>                        <span class="hljs-keyword">this</span>.readLock.release();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.writeLock.isAcquiredInThisProcess()) &#123;<br>                        <span class="hljs-keyword">this</span>.writeLock.release();<br>                    &#125;<br>                    LOGGER.info(<span class="hljs-string">"锁释放成功！"</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"public void doWork(long time, TimeUnit unit) 方法释放锁发生异常！"</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号量-Shared-Semaphore"><a href="#信号量-Shared-Semaphore" class="headerlink" title="信号量 Shared Semaphore"></a>信号量 Shared Semaphore</h3><p>一个计数的信号量类似JDK的Semaphore。 JDK中Semaphore维护的一组许可(<strong>permits</strong>)，而Curator中称之为租约(<strong>Lease</strong>)。 有两种方式可以决定semaphore的最大租约数。第一种方式是用户给定path并且指定最大LeaseSize。第二种方式用户给定path并且使用<code>SharedCountReader</code>类。<strong>如果不使用SharedCountReader, 必须保证所有实例在多进程中使用相同的(最大)租约数量,否则有可能出现A进程中的实例持有最大租约数量为10，但是在B进程中持有的最大租约数量为20，此时租约的意义就失效了。</strong></p><p>这次调用<code>acquire()</code>会返回一个租约对象。 客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。 租约还可以通过下面的方式返还：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnAll</span><span class="hljs-params">(Collection&lt;Lease&gt; leases)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnLease</span><span class="hljs-params">(Lease lease)</span></span><br></code></pre></td></tr></table></figure><p>注意你可以一次性请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Lease <span class="hljs-title">acquire</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> Collection&lt;Lease&gt; <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> qty)</span><br><span class="hljs-keyword">public</span> Lease <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span><br><span class="hljs-keyword">public</span> Collection&lt;Lease&gt; <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> qty, <span class="hljs-keyword">long</span> time, TimeUnit unit)</span></span><br></code></pre></td></tr></table></figure><p>Shared Semaphore使用的主要类包括下面几个：</p><ul><li>InterProcessSemaphoreV2</li><li>Lease</li><li>SharedCountReader</li></ul><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.Lease;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 14:55<br> * <span class="hljs-doctag">@description</span> Test13App, 信号量—Shared Semaphore<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test13App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test13App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, retry);<br>        client.start();<br><br>        <span class="hljs-comment">// 定义信号量变量，最大租约为 10</span><br>        InterProcessSemaphoreV2 semaphore = <span class="hljs-keyword">new</span> InterProcessSemaphoreV2(client, <span class="hljs-string">"/examples/locks"</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 获取 5 个租约</span><br>        Collection&lt;Lease&gt; leases = semaphore.acquire(<span class="hljs-number">5</span>);<br>        LOGGER.info(<span class="hljs-string">"leases 租约数量为：&#123;&#125;"</span>, leases.size());<br><br>        <span class="hljs-comment">// 获取 1 个租约</span><br>        Lease lease = semaphore.acquire();<br>        LOGGER.info(<span class="hljs-string">"lease: [&#123;&#125;]"</span>, lease);<br><br>        <span class="hljs-comment">// 使用共享资源</span><br>        resource.use();<br><br>        <span class="hljs-comment">// 在 6 秒内获取 5 个租约，如果获取不了就返回 null</span><br>        Collection&lt;Lease&gt; leases2 = semaphore.acquire(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (leases2 != <span class="hljs-keyword">null</span>) &#123;<br>            LOGGER.info(<span class="hljs-string">"leases2 租约数量为：&#123;&#125;"</span>, leases2.size());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOGGER.info(<span class="hljs-string">"在 6 秒内没有获取到 5 个租约，所以 leases2 为 null"</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 把使用的租约还给 semaphore</span><br>        semaphore.returnLease(lease);<br>        semaphore.returnAll(leases);<br>        <span class="hljs-keyword">if</span> (leases2 != <span class="hljs-keyword">null</span>) &#123;<br>            semaphore.returnAll(leases2);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们先获得了5个租约， 最后我们把它还给了semaphore。 接着请求了一个租约，因为semaphore还有5个租约，所以请求可以满足，返回一个租约，还剩4个租约。 然后再请求一个租约，因为租约不够，<strong>阻塞到超时，还是没能满足，返回结果为null(租约不足会阻塞到超时，然后返回null，不会主动抛出异常；如果不设置超时时间，会一致阻塞)。</strong></p><h3 id="多共享锁对象-Multi-Shared-Lock"><a href="#多共享锁对象-Multi-Shared-Lock" class="headerlink" title="多共享锁对象 Multi Shared Lock"></a>多共享锁对象 Multi Shared Lock</h3><p>Multi Shared Lock是一个锁的容器。 当调用<code>acquire()</code>， 所有的锁都会被<code>acquire()</code>，如果请求失败，所有的锁都会被release。 同样调用release时所有的锁都被release(<strong>失败被忽略</strong>)。 基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p><p>主要涉及两个类：</p><ul><li>InterProcessMultiLock</li><li>InterProcessLock</li></ul><p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMultiLock</span><span class="hljs-params">(List&lt;InterProcessLock&gt; locks)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMultiLock</span><span class="hljs-params">(CuratorFramework client, List&lt;String&gt; paths)</span></span><br></code></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessLock;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMultiLock;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 16:03<br> * <span class="hljs-doctag">@description</span> Test14App, 多共享锁对象 —Multi Shared Lock<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test14App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test14App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        <span class="hljs-comment">// 创建一个可重入锁对象</span><br>        InterProcessLock lock = <span class="hljs-keyword">new</span> InterProcessMutex(client, <span class="hljs-string">"/examples/locks"</span>);<br>        <span class="hljs-comment">// 创建一个不可重入锁对象</span><br>        InterProcessLock lock2 = <span class="hljs-keyword">new</span> InterProcessSemaphoreMutex(client, <span class="hljs-string">"/examples/locks2"</span>);<br>        <span class="hljs-comment">// 创建多共享锁对象</span><br>        InterProcessLock lock3 = <span class="hljs-keyword">new</span> InterProcessMultiLock(Arrays.asList(lock, lock2));<br><br>        <span class="hljs-keyword">if</span> (!lock3.acquire(<span class="hljs-number">2000</span>, TimeUnit.SECONDS)) &#123;<br>            LOGGER.info(<span class="hljs-string">"获取所有的锁失败！"</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"获取所有的锁成功！lock 是否获取到了锁：&#123;&#125;, lock2 是否获取到了锁：&#123;&#125;"</span>, lock.isAcquiredInThisProcess(), lock2.isAcquiredInThisProcess());<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用共享资源</span><br>            resource.use();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放所有锁</span><br>            lock3.release();<br>            LOGGER.info(<span class="hljs-string">"释放所有的锁成功！lock 是否获取到了锁：&#123;&#125;, lock2 是否获取到了锁：&#123;&#125;"</span>, lock.isAcquiredInThisProcess(), lock2.isAcquiredInThisProcess());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建一个<code>InterProcessMultiLock</code>， 包含一个重入锁和一个非重入锁。 调用<code>acquire()</code>后可以看到线程同时拥有了这两个锁。 调用<code>release()</code>看到这两个锁都被释放了。</p><p><strong>最后再重申一次， 强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，锁将会丢失。</strong></p><h2 id="分布式计数器"><a href="#分布式计数器" class="headerlink" title="分布式计数器"></a>分布式计数器</h2><p>顾名思义，计数器是用来计数的, 利用ZooKeeper可以实现一个集群共享的计数器。 只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数(<code>SharedCount</code>)，一个用long来计数(<code>DistributedAtomicLong</code>)。</p><h3 id="分布式int计数器-SharedCount"><a href="#分布式int计数器-SharedCount" class="headerlink" title="分布式int计数器(SharedCount)"></a>分布式int计数器(SharedCount)</h3><p>这个类使用int类型来计数。 主要涉及三个类。</p><ul><li>SharedCount</li><li>SharedCountReader</li><li>SharedCountListener</li></ul><p><code>SharedCount</code>代表计数器， 可以为它增加一个<code>SharedCountListener</code>，当计数器改变时此Listener可以监听到改变的事件，而<code>SharedCountReader</code>可以读取到最新的值， 包括字面值和带版本信息的值VersionedValue。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCount;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCountListener;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCountReader;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 16:56<br> * <span class="hljs-doctag">@description</span> Test15App, 分布式int计数器—SharedCount<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test15App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> Random random = <span class="hljs-keyword">new</span> Random();<br>        SharedCounterDemo demo = <span class="hljs-keyword">new</span> SharedCounterDemo();<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">2000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br>        <span class="hljs-comment">// 创建计数器对象</span><br>        SharedCount sharedCount = <span class="hljs-keyword">new</span> SharedCount(client, <span class="hljs-string">"/examples/counter"</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 给计数器对象添加监听器</span><br>        sharedCount.addListener(demo);<br>        <span class="hljs-comment">// 启动计数器</span><br>        sharedCount.start();<br><br>        List&lt;SharedCount&gt; sharedCounts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> SharedCount SharedCount = <span class="hljs-keyword">new</span> SharedCount(client, <span class="hljs-string">"/examples/counter"</span>, <span class="hljs-number">0</span>);<br>            sharedCounts.add(sharedCount);<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                SharedCount.start();<br>                TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">10</span>));<br>                <span class="hljs-keyword">boolean</span> b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br>                <span class="hljs-keyword">while</span> (!b) &#123;<br>                    b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br>                &#125;<br>                LOGGER.info(<span class="hljs-string">"修改数据，b: [&#123;&#125;]"</span>, b);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br>            executorService.submit(task);<br>        &#125;<br><br>        executorService.shutdown();<br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">// 关闭计数器</span><br>        <span class="hljs-keyword">for</span> (SharedCount count : sharedCounts) &#123;<br>            count.close();<br>        &#125;<br><br>        sharedCount.close();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedCounterDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SharedCountListener</span> </span>&#123;<br>        <span class="hljs-comment">/**<br>         * 数字更改时触发<br>         * <span class="hljs-doctag">@param</span> sharedCount<br>         * <span class="hljs-doctag">@param</span> newCount<br>         * <span class="hljs-doctag">@throws</span> Exception<br>         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countHasChanged</span><span class="hljs-params">(SharedCountReader sharedCount, <span class="hljs-keyword">int</span> newCount)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            LOGGER.info(<span class="hljs-string">"数据被修改为：&#123;&#125;"</span>, newCount);<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 状态更改时触发<br>         * <span class="hljs-doctag">@param</span> client<br>         * <span class="hljs-doctag">@param</span> newState<br>         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>            LOGGER.info(<span class="hljs-string">"状态被修改为了：&#123;&#125;"</span>, newState);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>baseCount</code>来监听计数值(<code>addListener</code>方法来添加SharedCountListener )。 任意的SharedCount， 只要使用相同的path，都可以得到这个计数值。 然后我们使用5个线程为计数值增加一个10以内的随机数。相同的path的SharedCount对计数值进行更改，将会回调给<code>baseCount</code>的SharedCountListener。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br><span class="hljs-keyword">while</span> (!b) &#123;<br>    b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用<code>trySetCount</code>去设置计数器。 <strong>第一个参数提供当前的VersionedValue,如果期间其它client更新了此计数值， 你的更新可能不成功， 更新不成功会返回 false。所以失败了你可以尝试再更新一次。 而<code>setCount</code>是强制更新计数器的值</strong>。</p><p>注意计数器必须<code>start</code>,使用完之后必须调用<code>close</code>关闭它。</p><p>强烈推荐使用<code>ConnectionStateListener</code>。 在本例中<code>SharedCountListener</code>扩展<code>ConnectionStateListener</code>。</p><h3 id="分布式long计数器-DistributedAtomicLong"><a href="#分布式long计数器-DistributedAtomicLong" class="headerlink" title="分布式long计数器(DistributedAtomicLong)"></a>分布式long计数器(DistributedAtomicLong)</h3><p>再看一个Long类型的计数器。 除了计数的范围比<code>SharedCount</code>大了之外， 它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用<code>InterProcessMutex</code>方式来更新计数值。</p><p>可以从它的内部实现<code>DistributedAtomicValue.trySet()</code>中看出：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicValue &lt; <span class="hljs-keyword">byte</span>[] &gt; trySet(MakeValue makeValue) <span class="hljs-keyword">throws</span> Exception &#123;<br>    MutableAtomicValue &lt; <span class="hljs-keyword">byte</span>[] &gt; result = <span class="hljs-keyword">new</span> MutableAtomicValue &lt; <span class="hljs-keyword">byte</span>[] &gt; (<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    tryOptimistic(result, makeValue);<br>    <span class="hljs-keyword">if</span>(!result.succeeded() &amp;&amp; (mutex != <span class="hljs-keyword">null</span>)) &#123;<br>        tryWithMutex(result, makeValue);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>此计数器有一系列的操作：</p><ul><li>get(): 获取当前值</li><li>increment()： 加一</li><li>decrement(): 减一</li><li>add()： 增加特定的值</li><li>subtract(): 减去特定的值</li><li>trySet(): 尝试设置计数值</li><li>forceSet(): 强制设置计数值</li></ul><p>你<strong>必须</strong>检查返回结果的<code>succeeded()</code>， 它代表此操作是否成功。 如果操作成功， <code>preValue()</code>代表操作前的值， <code>postValue()</code>代表操作后的值。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.atomic.AtomicValue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.atomic.DistributedAtomicLong;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.RetryNTimes;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 17:29<br> * <span class="hljs-doctag">@description</span> Test16App, 分布式long计数器—DistributedAtomicLong<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test16App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">2000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">/**<br>             * 重试策略对象，参数解释如下：<br>             * 第一个参数：重试次数<br>             * 第二个参数：重试之间的睡眠时间<br>             */</span><br>            RetryNTimes retryNTimes = <span class="hljs-keyword">new</span> RetryNTimes(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">final</span> DistributedAtomicLong atomicLong = <span class="hljs-keyword">new</span> DistributedAtomicLong(client, <span class="hljs-string">"/examples/counter"</span>, retryNTimes);<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 加 1</span><br>                    AtomicValue&lt;Long&gt; value = atomicLong.increment();<br>                    <span class="hljs-keyword">if</span> (value.succeeded()) &#123;<br>                        LOGGER.info(<span class="hljs-string">"修改前的值为：&#123;&#125;， 修改后的值为：&#123;&#125;"</span>, value.preValue(), value.postValue());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        LOGGER.info(<span class="hljs-string">"修改失败"</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序出现异常！"</span>, e);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br><br>            executorService.submit(task);<br>        &#125;<br><br>        executorService.shutdown();<br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>使用Curator也可以简化Ephemeral Node (<strong>临时节点</strong>)的操作。Curator也提供ZK Recipe的分布式队列实现。 利用ZK的 PERSISTENTS_EQUENTIAL节点， 可以保证放入到队列中的项目是按照顺序排队的。 如果单一的消费者从队列中取数据， 那么它是先入先出的，这也是队列的特点。 如果你严格要求顺序，你就的使用单一的消费者，可以使用Leader选举只让Leader作为唯一的消费者。</p><p>但是， 根据Netflix的Curator作者所说， ZooKeeper真心不适合做Queue，或者说ZK没有实现一个好的Queue，详细内容可以看 <a href="https://cwiki.apache.org/confluence/display/CURATOR/TN4" target="_blank" rel="noopener">Tech Note 4</a>， 原因有五：</p><ol><li>ZK有1MB 的传输限制。 实践中ZNode必须相对较小，而队列包含成千上万的消息，非常的大。</li><li>如果有很多节点，ZK启动时相当的慢。 而使用queue会导致好多ZNode. 你需要显著增大 initLimit 和 syncLimit.</li><li>ZNode很大的时候很难清理。Netflix不得不创建了一个专门的程序做这事。</li><li>当很大量的包含成千上万的子节点的ZNode时， ZK的性能变得不好</li><li>ZK的数据库完全放在内存中。 大量的Queue意味着会占用很多的内存空间。</li></ol><p>尽管如此， Curator还是创建了各种Queue的实现。 如果Queue的数据量不太多，数据量不太大的情况下，酌情考虑，还是可以使用的。</p><h3 id="分布式队列-DistributedQueue"><a href="#分布式队列-DistributedQueue" class="headerlink" title="分布式队列(DistributedQueue)"></a>分布式队列(DistributedQueue)</h3><p>DistributedQueue是最普通的一种队列。 它设计以下四个类：</p><ul><li>QueueBuilder - 创建队列使用QueueBuilder,它也是其它队列的创建类</li><li>QueueConsumer - 队列中的消息消费者接口</li><li>QueueSerializer - 队列消息序列化和反序列化接口，提供了对队列中的对象的序列化和反序列化</li><li>DistributedQueue - 队列实现类</li></ul><p>QueueConsumer是消费者，它可以接收队列的数据。处理队列中的数据的代码逻辑可以放在QueueConsumer.consumeMessage()中。</p><p><strong>正常情况下先将消息从队列中移除，再交给消费者消费。但这是两个步骤，不是原子的。</strong>可以调用Builder的lockPath()消费者加锁，当消费者消费数据时持有锁，这样其它消费者不能消费此消息。如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。最好还是单消费者模式使用队列。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.DistributedQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueBuilder;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueConsumer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueSerializer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/3 14:43<br> * <span class="hljs-doctag">@description</span> Test17App, 分布式队列—DistributedQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test17App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test17App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));<br>        CuratorFramework client2 = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">// 客户端启动</span><br>        client.start();<br>        <span class="hljs-comment">// 客户端2启动</span><br>        client2.start();<br><br>        <span class="hljs-comment">/**<br>         * 是线程不安全的<br>         */</span><br>        <span class="hljs-comment">// DistributedQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer("消费者A"), creQueueSerializer(), "/example/queue").buildQueue();</span><br>        <span class="hljs-comment">// DistributedQueue&lt;String&gt; queue2 = QueueBuilder.builder(client, createQueueConsumer("消费者B"), creQueueSerializer(), "/example/queue").buildQueue();</span><br><br>        <span class="hljs-comment">/**<br>         * 正常情况下先将消息从队列中移除，再交给消费者消费。但这是两个步骤，不是原子的。<br>         * 可以调用Builder的lockPath()消费者加锁，当消费者消费数据时持有锁，这样其它消费者不能消费此消息。<br>         * 如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。最好还是单消费者模式使用队列。<br>         */</span><br>        DistributedQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(<span class="hljs-string">"消费者A"</span>), creQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).lockPath(<span class="hljs-string">"/example/lock"</span>).buildQueue();<br>        DistributedQueue&lt;String&gt; queue2 = QueueBuilder.builder(client, createQueueConsumer(<span class="hljs-string">"消费者B"</span>), creQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).lockPath(<span class="hljs-string">"/example/lock"</span>).buildQueue();<br><br>        <span class="hljs-comment">// 消息队列启动</span><br>        queue.start();<br>        <span class="hljs-comment">// 消息队列2启动</span><br>        queue2.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">// 往消息队列中放数据</span><br>            queue.put(<span class="hljs-string">"Test-A-"</span> + i);<br>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>            <span class="hljs-comment">// 往消息队列2中放数据</span><br>             queue2.put(<span class="hljs-string">"Test-B-"</span> + i);<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 关闭消息队列</span><br>        queue.close();<br>        <span class="hljs-comment">// 关闭消息队列2</span><br>        queue2.close();<br><br>        <span class="hljs-comment">// 客户端关闭</span><br>        client.close();<br>        <span class="hljs-comment">// 客户端2关闭</span><br>        client2.close();<br>        LOGGER.info(<span class="hljs-string">"程序执行结束！"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 定义队列消费者<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-comment">/**<br>             * 消费消息时调用的方法<br>             * <span class="hljs-doctag">@param</span> message<br>             * <span class="hljs-doctag">@throws</span> Exception<br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 消费消息：&#123;&#125;"</span>, name, message);<br>            &#125;<br><br>            <span class="hljs-comment">/**<br>             * 状态改变时调用的方法<br>             * <span class="hljs-doctag">@param</span> client<br>             * <span class="hljs-doctag">@param</span> newState<br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"连接状态为：&#123;&#125;"</span>, newState.name());<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 队列消息序列化实现类<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">creQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-comment">/**<br>             * 序列化<br>             * <span class="hljs-doctag">@param</span> item<br>             * <span class="hljs-doctag">@return</span><br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-comment">/**<br>             * 反序列化<br>             * <span class="hljs-doctag">@param</span> bytes<br>             * <span class="hljs-doctag">@return</span><br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子中定义了两个分布式队列和两个消费者，因为PATH是相同的，通常会存在消费者抢占消费消息的情况，但是我使用了 <code>lockPath(/example/lock)</code> 方法，所以不会，如果将该代码注释掉，然后方案前面注释的代码，就会出现消费者抢占消费消息的情况（但是我测试了 N 次，也没有出现这个这种情况）。</p><h3 id="带Id的分布式队列-DistributedIdQueue"><a href="#带Id的分布式队列-DistributedIdQueue" class="headerlink" title="带Id的分布式队列(DistributedIdQueue)"></a>带Id的分布式队列(DistributedIdQueue)</h3><p>DistributedIdQueue和上面的队列类似，<strong>但是可以为队列中的每一个元素设置一个ID</strong>。 可以通过ID把队列中任意的元素移除。 它涉及几个类：</p><ul><li>QueueBuilder</li><li>QueueConsumer</li><li>QueueSerializer</li><li>DistributedQueue</li></ul><p>通过下面方法创建：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">builder.buildIdQueue()<br></code></pre></td></tr></table></figure><p>放入元素时：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.put(aMessage, messageId);<br></code></pre></td></tr></table></figure><p>移除元素时：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> numberRemoved = queue.remove(messageId);<br></code></pre></td></tr></table></figure><p>示例代码如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.*;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 13:55<br> * <span class="hljs-doctag">@description</span> Test18App，带Id的分布式队列—DistributedIdQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test18App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test18App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-comment">/**<br>     * 测试方法<br>     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建队列对象</span><br>        DistributedIdQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(), createQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).buildIdQueue();<br>        <span class="hljs-comment">// 启动队列</span><br>        queue.start();<br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            queue.put(<span class="hljs-string">"Test-"</span> + i, <span class="hljs-string">"Id-"</span> + i);<br>            <span class="hljs-comment">/**<br>             * 往队列中放入一个数据后睡眠任意秒，该线程放弃 CPU 执行权。队列开始消费，如果该线程在睡眠任意秒后重新获得 CPU 执行权，但是队列的数据没有被消费，<br>             * 此时调用 queue.remove("Id-" + i) 方法把队列中的指定数据删除了，该消费就不会被消费了。<br>             */</span><br>            TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">2</span>));<br>            queue.remove(<span class="hljs-string">"Id-"</span> + i);<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！准备回收资源"</span>);<br><br>        CloseableUtils.closeQuietly(queue);<br>        CloseableUtils.closeQuietly(client);<br><br>        LOGGER.info(<span class="hljs-string">"资源回收完毕！"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建序列化和反序列化对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">createQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建消费者对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"消费的消息内容为：&#123;&#125;"</span>, message);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"当前连接的状态改变了，新状态为：&#123;&#125;"</span>, newState);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中， 有些元素还没有被消费者消费前就移除了，这样消费者不会收到删除的消息。</p><h3 id="优先级分布式队列-DistributedPriorityQueue"><a href="#优先级分布式队列-DistributedPriorityQueue" class="headerlink" title="优先级分布式队列(DistributedPriorityQueue)"></a>优先级分布式队列(DistributedPriorityQueue)</h3><p>优先级队列对队列中的元素按照优先级进行排序。 <strong>Priority越小， 元素越靠前， 越先被消费掉</strong>。 它涉及下面几个类：</p><ul><li>QueueBuilder</li><li>QueueConsumer</li><li>QueueSerializer</li><li>DistributedPriorityQueue</li></ul><p>通过builder.buildPriorityQueue(minItemsBeforeRefresh)方法创建。 当优先级队列得到元素增删消息时，它会暂停处理当前的元素队列，然后刷新队列。minItemsBeforeRefresh指定刷新前当前活动的队列的最小数量。 主要设置你的程序可以容忍的不排序的最小值。</p><p>放入队列时需要指定优先级：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.put(aMessage, priority);<br></code></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueBuilder;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueConsumer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueSerializer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 15:32<br> * <span class="hljs-doctag">@description</span> Test19App, 优先级分布式队列—DistributedPriorityQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test19App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test19App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-comment">/**<br>     * 测试方法<br>     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建优先级队列对象</span><br>        DistributedPriorityQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(), createQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).buildPriorityQueue(<span class="hljs-number">0</span>);<br>        queue.start();<br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> priority = random.nextInt(<span class="hljs-number">100</span>);<br>            LOGGER.info(<span class="hljs-string">"Test-"</span> + i + <span class="hljs-string">" priority: "</span> + priority);<br>            queue.put(<span class="hljs-string">"Test"</span> + i, priority);<br>            TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">2</span>));<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！开始回收资源"</span>);<br><br>        CloseableUtils.closeQuietly(queue);<br>        CloseableUtils.closeQuietly(client);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建序列化和反序列化对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">createQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建消费者对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"消费的消息内容为：&#123;&#125;"</span>, message);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"当前连接的状态改变了，新状态为：&#123;&#125;"</span>, newState);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有时候你可能会有错觉，优先级设置并没有起效。那是因为优先级是对于队列积压的元素而言，如果消费速度过快有可能出现在后一个元素入队操作之前前一个元素已经被消费，这种情况下DistributedPriorityQueue会退化为DistributedQueue。</p><h3 id="分布式延迟队列-DistributedDelayQueue"><a href="#分布式延迟队列-DistributedDelayQueue" class="headerlink" title="分布式延迟队列(DistributedDelayQueue)"></a>分布式延迟队列(DistributedDelayQueue)</h3><p>JDK中也有DelayQueue，不知道你是否熟悉。 DistributedDelayQueue也提供了类似的功能， 元素有个delay值， 消费者隔一段时间才能收到元素。 涉及到下面四个类。</p><ul><li>QueueBuilder</li><li>QueueConsumer</li><li>QueueSerializer</li><li>DistributedDelayQueue</li></ul><p>通过下面的语句创建：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">QueueBuilder&lt;MessageType&gt;    builder = QueueBuilder.builder(client, consumer, serializer, path);<br>... more builder method calls as needed ...<br>DistributedDelayQueue&lt;MessageType&gt; queue = builder.buildDelayQueue();<br></code></pre></td></tr></table></figure><p>放入元素时可以指定<code>delayUntilEpoch</code>：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.put(aMessage, delayUntilEpoch);<br></code></pre></td></tr></table></figure><p>注意<code>delayUntilEpoch</code>不是离现在的一个时间间隔， 比如20毫秒，而是未来的一个时间戳，如 System.currentTimeMillis() + 10秒。 如果delayUntilEpoch的时间已经过去，消息会立刻被消费者接收。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.DistributedDelayQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueBuilder;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueConsumer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueSerializer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 15:53<br> * <span class="hljs-doctag">@description</span> Test20App, 分布式延迟队列—DistributedDelayQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test20App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test20App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建延时队列对象</span><br>        DistributedDelayQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(), createQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).buildDelayQueue();<br>        queue.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            queue.put(<span class="hljs-string">"Test-"</span> + i, System.currentTimeMillis() + <span class="hljs-number">1000</span>);<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"所有的数据都已经放入了延时队列中！"</span>);<br><br>        <span class="hljs-comment">// 等待消费者消费完队列数据再释放资源</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 释放资源</span><br>        CloseableUtils.closeQuietly(queue);<br>        CloseableUtils.closeQuietly(client);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建序列化和反序列化对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">createQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建消费者对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"消费的消息内容为：&#123;&#125;"</span>, message);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"当前连接的状态改变了，新状态为：&#123;&#125;"</span>, newState);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于JDK的分布式队列-SimpleDistributedQueue"><a href="#基于JDK的分布式队列-SimpleDistributedQueue" class="headerlink" title="基于JDK的分布式队列(SimpleDistributedQueue)"></a>基于JDK的分布式队列(SimpleDistributedQueue)</h3><p>前面虽然实现了各种队列，但是你注意到没有，这些队列并没有实现类似JDK一样的接口。 <code>SimpleDistributedQueue</code>提供了和JDK基本一致的接口(但是没有实现Queue接口)。 创建很简单：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleDistributedQueue</span><span class="hljs-params">(CuratorFramework client,String path)</span></span><br></code></pre></td></tr></table></figure><p>增加元素：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception</span><br></code></pre></td></tr></table></figure><p>删除元素：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] take() <span class="hljs-keyword">throws</span> Exception<br></code></pre></td></tr></table></figure><p>另外还提供了其它方法：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] peek() <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] poll(<span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] poll() <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] remove() <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] element() <span class="hljs-keyword">throws</span> Exception<br></code></pre></td></tr></table></figure><p>没有<code>add</code>方法， 多了<code>take</code>方法。<code>take</code>方法在成功返回之前会被阻塞。 而<code>poll</code>方法在队列为空时直接返回null。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.SimpleDistributedQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 16:22<br> * <span class="hljs-doctag">@description</span> Test21App，SimpleDistributedQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test21App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test21App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建队列对象</span><br>        SimpleDistributedQueue queue = <span class="hljs-keyword">new</span> SimpleDistributedQueue(client, <span class="hljs-string">"/example/queue"</span>);<br><br>        <span class="hljs-comment">// 创建生产者和消费者对象</span><br>        Producer producer = <span class="hljs-keyword">new</span> Producer(queue);<br>        Consumer consumer = <span class="hljs-keyword">new</span> Consumer(queue);<br><br>        <span class="hljs-comment">// 启动生产者和消费者线程</span><br>        <span class="hljs-keyword">new</span> Thread(producer).start();<br>        <span class="hljs-keyword">new</span> Thread(consumer).start();<br><br>        <span class="hljs-comment">// 等待队列中的数据处理完毕</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 释放资源</span><br>        CloseableUtils.closeQuietly(client);<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 消费者<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> SimpleDistributedQueue queue;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(SimpleDistributedQueue queue)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">this</span>.queue.take();<br>                    <span class="hljs-keyword">if</span> (bytes == <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    LOGGER.info(<span class="hljs-string">"消费一条消息成功：&#123;&#125;"</span>, <span class="hljs-keyword">new</span> String(bytes));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOGGER.error(<span class="hljs-string">"程序出现异常!"</span>, e);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 生产者<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> SimpleDistributedQueue queue;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(SimpleDistributedQueue queue)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">this</span>.queue.offer((<span class="hljs-string">"test-"</span> + i).getBytes());<br>                    <span class="hljs-keyword">if</span> (flag) &#123;<br>                        LOGGER.info(<span class="hljs-string">"发送消息成功：&#123;&#125;"</span>, <span class="hljs-string">"test-"</span> + i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        LOGGER.info(<span class="hljs-string">"发送消息失败：&#123;&#125;"</span>, <span class="hljs-string">"test-"</span> + i);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序发生异常！"</span>, e);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分布式栅栏-屏障-——Barrier"><a href="#分布式栅栏-屏障-——Barrier" class="headerlink" title="分布式栅栏(屏障)——Barrier"></a>分布式栅栏(屏障)——Barrier</h2><p>分布式Barrier是这样一个类： 它会阻塞所有节点上的等待进程，直到某一个被满足， 然后所有的节点继续进行。</p><p>比如赛马比赛中， 等赛马陆续来到起跑线前。 一声令下，所有的赛马都飞奔而出。</p><h3 id="DistributedBarrier"><a href="#DistributedBarrier" class="headerlink" title="DistributedBarrier"></a>DistributedBarrier</h3><p><code>DistributedBarrier</code>类实现了栅栏的功能。 它的构造函数如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DistributedBarrier</span><span class="hljs-params">(CuratorFramework client, String barrierPath)</span></span><br></code></pre></td></tr></table></figure><p>首先你需要设置栅栏，它将阻塞在它上面等待的线程:</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">setBarrier();<br></code></pre></td></tr></table></figure><p>然后需要阻塞的线程调用方法告诉栅栏等待放行:</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitOnBarrier</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>移除栅栏，所有等待的线程将继续执行：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">removeBarrier();<br></code></pre></td></tr></table></figure><p><strong>异常处理</strong> DistributedBarrier 会监控连接状态，当连接断掉时<code>waitOnBarrier()</code>方法会抛出异常。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.barriers.DistributedBarrier;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 17:30<br> * <span class="hljs-doctag">@description</span> Test22App, DistributedBarrier<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test22App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test22App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        <span class="hljs-comment">// 创建线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 创建栅栏对象</span><br>        <span class="hljs-keyword">final</span> DistributedBarrier barrier = <span class="hljs-keyword">new</span> DistributedBarrier(client, <span class="hljs-string">"/examples/barrier"</span>);<br>        <span class="hljs-comment">// 设置栅栏，在该栅栏上的所有线程都将阻塞</span><br>        barrier.setBarrier();<br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="hljs-number">3</span>));<br>                LOGGER.info(<span class="hljs-string">"客户端 #"</span> + index + <span class="hljs-string">"准备数据"</span>);<br><br>                <span class="hljs-comment">// 告诉栅栏对象，数据准备完毕</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    barrier.waitOnBarrier();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序出现异常！"</span>, e);<br>                &#125;<br>                <span class="hljs-comment">// 栅栏对象放行后，执行</span><br>                LOGGER.info(<span class="hljs-string">"开始处理数据！"</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br>            executorService.submit(task);<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br><br>        LOGGER.info(<span class="hljs-string">"当所有线程数据准备完毕后，开始放行！"</span>);<br><br>        <span class="hljs-comment">// 放行栅栏</span><br>        barrier.removeBarrier();<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        executorService.shutdown();<br><br>        <span class="hljs-comment">// 和 executorService.shutdown() 组合使用，监控线程池是否已经关闭，如果线程池内之前提交的任务还没有完成，会一直监控到任务处理完成后。</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子创建了<code>controlBarrier</code>来设置栅栏和移除栅栏。 我们创建了5个线程，在此Barrier上等待。 最后移除栅栏后所有的线程才继续执行。</p><h3 id="双栅栏-DistributedDoubleBarrier"><a href="#双栅栏-DistributedDoubleBarrier" class="headerlink" title="双栅栏(DistributedDoubleBarrier)"></a>双栅栏(DistributedDoubleBarrier)</h3><p>双栅栏允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算， 当计算完成时，离开栅栏。 双栅栏类是<code>DistributedDoubleBarrier</code>。 构造函数为:</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DistributedDoubleBarrier</span><span class="hljs-params">(CuratorFramework client,<br>                                String barrierPath,<br>                                <span class="hljs-keyword">int</span> memberQty)</span></span><br></code></pre></td></tr></table></figure><p><code>memberQty</code>是成员数量，当<code>enter()</code>方法被调用时，成员被阻塞，直到所有的成员都调用了<code>enter()</code>。 当<code>leave()</code>方法被调用时，它也阻塞调用线程，直到所有的成员都调用了<code>leave()</code>。 就像百米赛跑比赛， 发令枪响， 所有的运动员开始跑，等所有的运动员跑过终点线，比赛才结束。</p><p>DistributedDoubleBarrier会监控连接状态，当连接断掉时<code>enter()</code>和<code>leave()</code>方法会抛出异常。</p><p>示例代码如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.barriers.DistributedDoubleBarrier;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 18:07<br> * <span class="hljs-doctag">@description</span> Test23App, 双栅栏—DistributedDoubleBarrier<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test23App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test23App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        <span class="hljs-comment">// 创建线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 创建栅栏对象</span><br>            <span class="hljs-keyword">final</span> DistributedDoubleBarrier doubleBarrier = <span class="hljs-keyword">new</span> DistributedDoubleBarrier(client, <span class="hljs-string">"/examples/barrier"</span>, <span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="hljs-number">3</span>));<br>                LOGGER.info(<span class="hljs-string">"客户端 #"</span> + index + <span class="hljs-string">"进入栅栏"</span>);<br>                doubleBarrier.enter();<br><br>                <span class="hljs-comment">// 当所有线程都进入栅栏后，执行下面的代码</span><br>                LOGGER.info(<span class="hljs-string">"执行代码"</span>);<br>                TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">3</span>));<br><br>                doubleBarrier.leave();<br>                LOGGER.info(<span class="hljs-string">"客户端 #"</span> + index + <span class="hljs-string">"离开栅栏"</span>);<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br>            executorService.submit(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        executorService.shutdown();<br><br>        <span class="hljs-comment">// 和 executorService.shutdown() 组合使用，监控线程池是否已经关闭，如果线程池内之前提交的任务还没有完成，会一直监控到任务处理完成后。</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>源代码：<a href="https://github.com/ZGYSYY/spring-boot-seckill/blob/master/src/test/java/com/zgy/test" target="_blank" rel="noopener">https://github.com/ZGYSYY/spring-boot-seckill/blob/master/src/test/java/com/zgy/test</a></p><blockquote><p>本文参考自：<a href="http://throwable.coding.me/2018/12/16/zookeeper-curator-usage/" target="_blank" rel="noopener">http://throwable.coding.me/2018/12/16/zookeeper-curator-usage/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper详解（一）</title>
      <link href="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>作为分布式系统解决方案的 ZooKeeper，被广泛应用于多个分布式场景。例如：数据发布/订阅，负载均衡，命名服务，集群管理等等。<br>因此，ZooKeeper 在分布式系统中扮演着重要的角色，今天通过一个简单的例子来看看它的实现原理。</p><a id="more"></a><h1 id="从一个简单的例子开始"><a href="#从一个简单的例子开始" class="headerlink" title="从一个简单的例子开始"></a>从一个简单的例子开始</h1><p>在分布式系统中经常会遇到这种情况，多个应用读取同一个配置。例如：A，B 两个应用都会读取配置 C 中的内容，一旦 C 中的内容出现变化，会通知 A 和 B。<br>一般的做法是在 A，B 中按照时钟频率询问 C 的变化，或者使用观察者模式来监听 C 的变化，发现变化以后再更新 A 和 B。那么 ZooKeeper 如何协调这种场景？<br>ZooKeeper 会建立一个 ZooKeeper 服务器，暂且称为 ZServer，用它来存放 C 的值。为 A，B 两个应用分别生成两个客户端，称作 ClientA 和 ClientB。<br>这两个客户端连接到 ZooKeeper 的服务器，并获取其中存放的 C。保存 C 值的地方在 ZooKeeper 服务端（Server）中称为 ZNode。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640.webp" class="" title="ClientA 和 ClientB 通过 ZooKeeper Server 获取 C 的值"><h1 id="ZNode"><a href="#ZNode" class="headerlink" title="ZNode"></a>ZNode</h1><p>通过上面的例子，客户端 ClientA 和 ClientB 需要读取 C 的内容。这个 C 就作为树的叶子节点存放在 ZooKeeper 的 ZNode 中。<br>通常来说，为了提高效率 ZNode 是被存放在内存中的。ZNode 的数据模型是一棵树（ZNode Tree）。<br>好像我们从上图中看到的一样，树中的每个节点都可以存放数据，并且每个节点下面都可以存放叶子节点。<br>ZooKeeper 客户端通过 “/” 作为访问路径，访问数据。例如可以通过路径 “/RootNode/C” 来访问 C 变量。</p><p><strong>为了方便客户端调用，ZooKeeper 会暴露一些命令：</strong></p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091644284.webp" class=""><p><strong>作为存储媒介来说，ZNode分为持久节点和临时节点：</strong></p><p>持久节点（PERSISTENT），该数据节点被创建后，就一直存在于 ZooKeeper 服务器上，除非删除操作（delete）清除该节点。<br>临时节点（EPHEMERAL），该数据节点的生命周期会和客户端（Client）会话（Session）绑定在一起。如果客户端（Client）会话丢失了，那么节点就自动清除掉。<br>如果把临时节点看成资源的话，当客户端和服务端产生会话并生成临时节点，一旦客户端与服务器中断联系，节点资源会被从 ZNode 中删除。<br>顺序节点（SEQUENTIAL），ZNode 节点被分配唯一个单调递增的整数。例如多个客户端在服务器 /tasks 上申请节点时，根据客户端申请的先后顺序，将数字追加到 /tasks/task 后面。<br>如果有三个客户端申请节点资源，那么在 /tasks 下面建立三个顺序节点，分别是 /tasks/task1，/tasks/task2，/tasks/task3。<br>顺序节点，在处理分布式事务的时候非常有帮助，当多个客户端（Client）协作工作的时候，会按照一定的顺序执行。<br>如果将上面的两类节点和顺序节点进行组合的话，就有四种节点类型，分别是持久节点，持久顺序节点，临时节点，临时顺序节点。</p><h1 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h1><p>上面说了 ZooKeeper 用来存放数据的 ZNode，并且把 C 的值存储在里面。如果 C 被更新了，两个客户端（ClientA、ClientB）如何获得通知呢？<br>ZooKeeper 客户端（Client）会在指定的节点（/RootNote/C）上注册一个 Watcher，ZNode 上的 C 被更新的时候，服务端就会通知 ClientA 和 ClientB。</p><p><strong>通过三步来实现：</strong></p><ol><li>客户端注册 Watcher</li><li>服务端处理 Watcher</li><li>客户端回调 Watcher</li></ol><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091748758.webp" class=""><p><strong>①客户端注册 Watcher</strong></p><p>ZooKeeper 客户端创建 Watcher 的实例对象：</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091773626.webp" class=""><p>同时这个 Watcher 会保存在客户端本地，一直作为和服务端会话的 Watcher。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091784988.webp" class=""><p>客户端可以通过 getData，getChildren 和 exist 方法来向服务端注册 Watcher。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091795841.webp" class=""><p>同时需要注意的是在客户端发送 Watcher 到服务端注册的时候，会将这个要发送的 Watcher 在本地的 ZKWatchManager 中保存。<br>这样做的好处，就是当获得服务端的注册成功的信息以后，就不用将 Watcher 的具体内容回传给客户端了。<br>客户端只用在接到服务端响应以后，从本地的 ZKWatchManager 中获取 Watch 的信息进行处理即可。</p><p><strong>②服务端处理 Watcher</strong></p><p>服务端收到客户端的请求以后，交给 FinalRequestProcessor 处理，这个进程会去 ZNode 中获取对应的数据，同时会把 Watch 加入到 WatchManager 中。<br>这样下次这节点上的数据被更改了以后，就会通知注册 Watch 的客户端了。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091832270.webp" class=""><p><strong>③客户端回调 Watcher</strong></p><p>客户端在响应客户端 Watcher 注册以后，会发送 WathcerEvent 事件。作为客户端有对应的回调函数接受这个消息。<br>这里会通过 readResponse 方法统一处理：</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091859389.webp" class=""><p>在 SendTread 接受到服务端的通知以后，会将事件通过 EventThread.queueEvent 发送给 EventThread。<br>正如前面提到的，在客户端注册时，已经将 Watcher 的具体内容保存在 ZKWatchManager 一样了。<br>所以，EventTread 通过 EventType 就可以知道哪个 Watcher 被响应了（数据变化了）。<br>然后从 ZKWatchManager 取出具体 Watch 放到 waitingEvent 队列等待处理。<br>最后，由 EventThread 中的 processEvent 方法依次处理数据更新的响应。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091873098.webp" class=""><h1 id="版本（Version）"><a href="#版本（Version）" class="headerlink" title="版本（Version）"></a>版本（Version）</h1><p>介绍完了 Watcher 机制，回头再来谈谈 ZNode 的版本（Version）。如果有一个客户端（ClientD），它尝试修改 C 的值，此时其他两个客户端会收到通知，并且进行后续的业务处理了。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091892704.webp" class=""><p>那么在分布式系统中，会出现这么一种情况：在 ClientD 对 C 进行写入操作的时候，又有一个 ClientE 也对 C 进行写入操作。这两个 Client 会去竞争 C 资源，通常这种情况需要对 C 进行加锁操作。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091904111.webp" class="" title="两个 Client 竞争一个资源"><p>因此引入 ZNode 版本（Version）概念。版本是用来保证分布式数据原子性操作的。<br>ZNode 的版本（Version）信息保存在 ZNode 的 Stat 对象中。有如下三种：</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091934877.webp" class=""><p>本例只关注“数据节点内容的版本号”，也就是 Version。<br>如果说 ClientD 和 ClientE 对 C 进行写入操作视作是一个事务的话。在执行写入操作之前，两个事务分别会获取节点上的值，即节点保存的数据和节点的版本号（Version）。<br>以乐观锁为例，对数据的写入会分成以下三个阶段：数据读取，写入校验和数据写入。例如 C 上的数据是 1， Version 是 0。<br>此时 ClientD 和 ClientE 都获取了这些信息。假设 ClientD 先做写入操作，在做写入校验的时候，发现之前获得的 Version 和节点上的 Version 是相同的，都是 1，因此直接执行数据写入。<br>写入以后，Version 由原来的 1 变成了 2。当 ClientE 做写入校验时，发现自己持有的 Version=1 和节点当前的 Version=2，不一样。于是，写入失败，重新获取 Version 和节点数据，再次尝试写入。<br>除了上述方案以外，还可以利用 ZNode 的有序性。在 C 下面建立多个有序的子节点。每当一个 Client 准备写入数据的时候，创建一个临时有序的节点。<br>节点的顺序根据 FIFO 算法，保证先申请写入的 Client 排在其前面。每个节点都有一个序号，后面申请的节点按照序号依次递增。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577091959155.webp" class="" title="ClientD，ClientE 分别建立子 ZNode"><p>每个 Client 在执行修改 C 操作的时候，都要检查有没有比自己序号小的节点，如果存在那么就进入等待。<br>直到比自己序号小的节点进行完毕以后，才轮到自己执行修改操作。从而保证了事物处理的顺序性。</p><h1 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h1><p>说完版本（Version）的概念，例子从原来的 ClientAB 已经扩充到了 ClientDE。这些客户端都会和 ZooKeeper 的服务端进行通信，或读取数据或修改数据。<br>我们将客户端与服务端完成的这种连接称为会话。ZooKeeper 的会话有 Connecting，Connected，Reconnecting，Reconnected 和 Close 这几种状态。<br>并且在服务端由专门的进程来管理他们，客户端初始化的时候就会根据配置自动连接服务器，从而建立会话，客户端连接服务器时会话处于 Connecting 状态。<br>一旦连接完成，就会进入 Connected 状态。如果出现延迟或者短暂失联，客户端会自动重连，Reconnecting 和 Reconnected 状态也就应运而生。<br>如果长时间超时，或者客户端断开服务器，ZooKeeper 会清理掉会话，以及该会话创建的临时数据节点，并且关闭和客户端的连接。</p><p><strong>Session 作为会话实体，用来代表客户端会话，其包括 4 个属性：</strong></p><ul><li>SessionID，用来全局唯一识别会话。</li><li>TimeOut，会话超时事件。客户端在创造 Session 实例的时候，会设置一个会话超时的时间。</li><li>TickTime，下次会话超时时间点。后面“分桶策略”会用到。</li><li>isClosing，当服务端如果检测到会话超时失效了，会通过设置这个属性将会话关闭。</li></ul><p>既然，会话是客户端与服务器之间的连接。在服务器端由 SessionTracker 管理会话。<br>SessionTracker 有一个工作就是，将超时的会话清除掉。于是“分桶策略”就登场了。<br>由于每个会话在生成的时候都会定义超时时间，通过当前时间+超时时间可以算出会话的过期时间。<br>由于 SessionTracker 不是实时监听会话超时，它是按照一定时间周期来监听的。<br>也就是说，如果没有到达 SessionTracker 的检查时间周期，即使有会话过期，SessionTracker 也不会去清除。由此，就引入会话超时计算公式，也就是 TickTime 的计算公式。</p><p><b>TickTime=（（当前时间+会话过期时间）/检查时间间隔+1）* 检查时间间隔。</b></p><p>将这个值计算出来以后，SessionTracker 会把对应的会话按照这个时间放在对应的时间轴上面。SessionTracker 在对应的 TickTime 检查会话是否过期。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577092047238.webp" class=""><p>每当客户端连接上服务器都会做激活操作，同时每隔一段时间客户端会向服务器发送心跳检测。<br>服务器收到激活或者心跳检测以后，会重新计算会话过期时间，根据“分桶策略”进行重新调整。把会话从“老的区块“放到”新的区块“中去。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577092069240.webp" class="" title="重新计算过期时间并且调整“分桶策略”"><p><strong>对于超时的会话，SessionTracker 也会做如下清理工作：</strong></p><ul><li>标记会话状态为“已关闭”，也就是设置 isClosing 为 True。</li><li>发起“会话关闭”的请求，让关闭操作在整个集群生效。</li><li>收集需要清理的临时节点。</li><li>添加“节点删除”的事务变更。</li><li>删除临时节点</li><li>移除会话</li><li>关闭客户端与服务端的连接<br>会话关闭以后客户端就无法从服务端获取/写入数据了。</li></ul><h1 id="服务群组（Leader，Follower，Observer）"><a href="#服务群组（Leader，Follower，Observer）" class="headerlink" title="服务群组（Leader，Follower，Observer）"></a>服务群组（Leader，Follower，Observer）</h1><p>前面提到了客户端如何通过会话与服务端保持联系，以及服务端是如何管理客户端会话（Session）的。<br>我们继续思考一下，这么多的服务端都依赖一个 ZooKeeper 服务器。一旦服务挂了，客户端就无法工作了。<br>为了提高 ZooKeeper 服务的可靠性，引入服务器集群的概念。从原来的单个服务器，扩充成多个服务器，即使某一台服务器挂了，其他的服务器也可以顶上来。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577092132249.webp" class="" title="ZooKeeper 的服务器集群"><p>这样看起来不错了，新的问题是，存在多个 ZooKeeper 服务器，那么客户端的请求发给哪台呢？服务器之间如何同步数据呢？如果一个服务挂掉了其他的服务器如何替代？这里介绍两个概念 Leader 和 Follower。<br>Leader 服务器，是事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性。也是集群内部服务器的调度者。<br>它是整个集群的老大，其他的服务器接到事务请求都会转交给它，让它协调处理。<br>Follower 服务器，处理非事务请求（读操作），转发事务请求给 Leader 服务器。参与选举 Leader 的投票和事务请求 Proposal 的投票。<br>既然 Leader 是集群的老大，那么这个老大是如何产生的。ZooKeeper 有仲裁机制，通过服务器的选举产生这个 Leader，按照少数服从多数的原则。<br>因此，集群中服务器的个数一般都是奇数，例如：1，3，5。当然这里是建议。关于选举和仲裁都有一定的算法，一起来看看吧。<br>当众多服务器启动的时候，互相都不知道谁是 Leader，因此都会进入 Looking 状态，也就是在网络中寻找 Leader。<br>寻找的过程也是投票的过程，每个服务器会将服务器 ID 和事务 ID 作为投票信息发送给网络中其他的服务器。假设称它为投票信息 VOTE，它包括：（ServerID，ZXID）。</p><p>其中，ServerID 是服务器注册的 ID，随着服务器启动的顺序自动增加，后启动的服务器 ServerID 就大；ZXID 是服务器处理事物的 ID，随着事物的增加自动增加，同样后提交的事务 ZXID 也大一些。<br>其他的服务器收到 VOTE 信息以后会和自己的 VOTE 信息（ServerID，ZXID）进行比较。<br>如果收到的 VOTE（ServerID，ZXID）中的 ZXID 比自己的 ZXID 要大，那么把自己的 VOTE 修改成收到的 VOTE。<br>如果 ZXID 一样大，那么就比较 ServerID，将大的那个 ServerID 作为自己 VOTE 的 ServerID，转发给其他服务器。</p><p>再简单点说，如果事务 ID（ZXID）比自己的事务 ID（ZXID）要大，就把票投给这个服务器。如果事务 ID 一样，就把票投给 ServerID 大的服务器。</p><p><strong>来个具体的例子，有三个服务器，他们的投票值分别是：</strong></p><ul><li><p>S1 (1，6)</p></li><li><p>S2 (2，5)</p></li><li><p>S3 (3，5)</p></li></ul><p>三个服务器分别把自己的 VOTE 发给其他两台服务器，S2 和 S3 收到 VOTE 以后发现 ZXID 为 6 的来自 S1 的 VOTE 比自己持有的 ZXID 要大，因此把自己的 VOTE 修改为（1，6）投出去，因此 S1 称为 Leader。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577092179972.webp" class="" title="Leader 选举实例"><p>同样，如果 S1 作为 Leader，因为某种原因挂掉或者长时间没有响应请求，其他的服务器也会进入 Looking 状态，开启投票仲裁模式寻找下一个 Leader。<br>成为新 Leader 以后会通过广播的方式将 ZNode 上的数据同步到其他的 Follower。<br>Leader 有了，整个服务器集群有了领袖，它可以处理客户端的事物请求。客户端的请求可以发给集群中任意一台服务器，无论是哪个服务器都会将事物请求转交给 Leader。<br>Leader 在将数据写入 ZNode 之前会向 ZooKeeper 的其他 Follower 进行广播。<br>这里广播用到了 ZAB 协议（Atomic Broadcast Protocol）是 Paxos 协议的实践。说白了就是一个两段提交。</p><p>PS：对分布式事务比较了解的同学应该知道两段提交和三段提交。</p><p><strong>这里 ZooKeeper 通过以下方式实现两段提交：</strong></p><ul><li>Leader 向所有 Follower 发送一个 PROPOSAL。</li><li>当 Follower 接收到 PROPOSAL 后，返回给 Leader 一个 ACK 消息，表示我收到 PROPOSAL，并且准备好了。</li><li>Leader 仲裁数量（过半数）的 Follower 发送的 ACK 后（包括 Leader 自己），会发送消息通知 Follower 进行 COMMIT。</li><li>收到 COMMIT 以后，Follower 就开始干活，将数据写入到 ZNode 中。</li></ul><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577092225305.webp" class="" title="ZAB 广播 PROPOSAL"><p>选举了 Leader 领导集群，Leader 接受到 Client 的请求以后，也可以协调 Follower 工作了。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577092240964.webp" class=""><p>那么如果 Client 很多的情况下，特别是这些客户端都是做读操作的时候，ZooKeeper 服务器如何处理如此多的请求呢？这里引入 Observer 的概念。<br>Observer 和 Follower 基本一致，对于非事务请求（读操作），可以直接返回节点中的信息（数据从 Leader 中同步过来的）。<br>对于事务请求（写操作），会转交给 Leader 做统一处理。Observer 的存在就是为了解决大量客户端读请求。<br>Observer 和 Follower 的区别是，Observer 不参与仲裁投票，选举 Leader。</p><img src="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/640-1577092253737.webp" class="" title="Observer 加入 Leader 和 Follower 大家庭"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>全文用了一个简单的例子讲 ZooKeeper 的主要特性和实现原理，最后做个总结。<br>ZooKeeper 被用来协调和管理分布式系统，发挥着重要的作用。分布式系统由于其特性，应用分布在不同的物理主机或者网络中。<br>为了让它们协同工作，ZooKeeper 中的 ZNode 成为统一协调的重要部分，客户端通过 Client 间接到服务端的 ZNode 上，监听 ZNode 数据的变化。<br>同时 ZNode 支持的持久，临时和顺序性，以及版本（Version）控制，这些特性支持了分布式事务和锁的功能。<br>如果说，每一个 ZooKeeperClient 对 Server 的写入操作都是一次事务的话，ZooKeeper 服务端维护了大量的事务，并且通过“分桶策略”来管理它们，保证了 Client 与 Server 端协调工作。</p><p>为了提高 Server 的可靠性，ZooKeeper 引入了 Server 集群的概念。通过仲裁机制选举 Leader 来领导其他 Follower。<br>事物都由 Leader 来处理，通过两段提交的方式对其他 Server 发起广播。为了增强对非事务请求的处理效率，ZooKeeper 加入了 Observer 来帮忙。</p><p>ZooKeeper 包含的内容远不止上面说的这些，由于篇幅的原因无法一一道来。<br>为了方便大家理解，文中将一些原理做了简化处理，希望有机会和大家做深入的探讨，咱们下次见。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql 笔记</title>
      <link href="/2020/01/03/MySql-%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/03/MySql-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>创建用户</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">'username'</span>@<span class="hljs-string">'localhost'</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">'password'</span>;<br></code></pre></td></tr></table></figure><p><strong>创建数据库</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> 数据库名称; 或者 <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">SCHEMA</span> 数据库名称;<br></code></pre></td></tr></table></figure><p><strong>授权</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> 数据库名称.* <span class="hljs-keyword">TO</span> <span class="hljs-string">'username'</span>@<span class="hljs-string">'localhost'</span>;<br></code></pre></td></tr></table></figure><p><strong>删除用户</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">user</span> <span class="hljs-string">'usernaem'</span>@<span class="hljs-string">'localhost'</span>;<br></code></pre></td></tr></table></figure><a id="more"></a><p><strong>MySql中@ 和 @@的区别</strong></p><p>@x 是 用户自定义的变量 (User variables are written as @var_name)。<br>@@x 是 global或session变量 (@@global @@session )，默认使用的是@@session.x，session 被省略了。</p><p>@@查看全局变量:</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@log_error;<br><span class="hljs-keyword">select</span> @@FOREIGN_KEY_CKECK;<br></code></pre></td></tr></table></figure><p>@设置用户自定义变量值:</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> @t1=<span class="hljs-number">0</span>, @t2=<span class="hljs-number">0</span>, @t3=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">SELECT</span> @t1:=(@t2:=<span class="hljs-number">1</span>)+@t3:=<span class="hljs-number">4</span>,@t1,@t2,@t3;   //5 5 1 4<br></code></pre></td></tr></table></figure><p><strong>查看隔离级别</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@tx_isolation;<br><span class="hljs-comment"># MySQL8版本后用以下命令</span><br><span class="hljs-keyword">select</span> @@transaction_isolation;<br></code></pre></td></tr></table></figure><p><strong>修改事务隔离级别</strong></p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">//设置read uncommitted级别：<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> uncommitted;<br><br>//设置read committed级别：<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> committed;<br><br>//设置repeatable read级别：<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> repeatable <span class="hljs-keyword">read</span>;<br><br>//设置serializable级别：<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">serializable</span>;<br></code></pre></td></tr></table></figure><p><strong>查看事务自动提交是否开启</strong></p><p>查看当前会话</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">session</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'autocommit'</span>;<br></code></pre></td></tr></table></figure><p>查看全局</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'autocommit'</span>;<br></code></pre></td></tr></table></figure><p><strong>修改事务自动提交</strong></p><p>修改当前会话</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 0 表示关闭，1 表示开启</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">session</span> autocommit=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>修改全局</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 0 表示关闭，1 表示开启</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> autocommit=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常用命令</title>
      <link href="/2020/01/03/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/01/03/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="拷贝文件并排除某些文件"><a href="#拷贝文件并排除某些文件" class="headerlink" title="拷贝文件并排除某些文件"></a>拷贝文件并排除某些文件</h1><p>语法：xcopy 源目录 目标目录 参数</p><figure class="hljs highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">xcopy</span> .\my-shop D:\Temp\my-shop /Y /E /H /EXCLUDE:EXCLUDE.txt<br></code></pre></td></tr></table></figure><a id="more"></a><p>参数解释</p><p>/Y： 禁止提示以确认改写一个现存目标文件。 </p><p>/E： 复制目录和子目录，包括空的。 </p><p> /H： 复制隐藏和系统文件。 </p><p>/EXCLUDE：排除文件配置文件</p><p>举例，EXCLUDE.txt 配置内容如下：</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.git</span><br><span class="hljs-selector-class">.idea</span><br><span class="hljs-selector-tag">target</span><br><span class="hljs-selector-class">.iml</span><br><span class="hljs-selector-tag">EXCLUDE</span><span class="hljs-selector-class">.txt</span><br></code></pre></td></tr></table></figure><p>表示文件名或者目录名包含以上字符的文件或者目录都不拷贝。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 系统 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建JavaWeb环境</title>
      <link href="/2020/01/03/Docker%E6%90%AD%E5%BB%BAJavaWeb%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/01/03/Docker%E6%90%AD%E5%BB%BAJavaWeb%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p><a href="/download/Docker搭建JavaWeb环境/source.rar">本教程用到的资源，点击下载</a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>CentOS7.5</li><li>必须有root权限</li></ul><a id="more"></a><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">docker CentOS安装文档</a></p><ol><li><p>安装一些工具和驱动 <code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p></li><li><p>添加yum源 <code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></p></li><li><p>安装docker <code>yum install docker-ce</code></p></li><li><p>验证docker是否安装成功 <code>docker -v</code></p></li><li><p>如果步骤4成功，启动docker <code>sytemctl start docker</code></p></li><li><p>配置镜像加速器</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">'EOF'</span><br>&#123;<br>  <span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://jtpbxytq.mirror.aliyuncs.com"</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure></li><li><p>运行一个docker测试 <code>docker run hello-world</code></p></li><li><p>可以自行百度，安装一个docker命令自动补全的工具（非必须）</p></li></ol><h1 id="安装数据库-mariadb"><a href="#安装数据库-mariadb" class="headerlink" title="安装数据库-mariadb"></a>安装数据库-mariadb</h1><ol><li><p>搜索镜像，<code>docker search mariadb</code></p></li><li><p>拉取镜像，<code>docker pull mariadb</code></p></li><li><p>创建容器，<code>docker run -tid --name mariadb -p 7788:3306 -e MYSQL_ROOT_PASSWORD=root -v /usr/mariadb/:/var/lib/mysql mariadb</code></p><p><strong>注意：</strong>/var/lib/mysql 这个是不变的，这是容器中的数据库文件位置。</p></li><li><p>连接数据库</p></li></ol><h1 id="制作java运行环境进行"><a href="#制作java运行环境进行" class="headerlink" title="制作java运行环境进行"></a>制作java运行环境进行</h1><ol><li><p>到jdk官网下载server-jre，并上传到Linux服务器中</p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html" target="_blank" rel="noopener">server-jre下载</a></p></li><li><p>编写Dockerfile文件</p><figure class="hljs highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 基于frolvlad/alpine-glibc镜像</span><br><span class="hljs-keyword">FROM</span> frolvlad/alpine-glibc<br><br><span class="hljs-comment"># 作者</span><br>MAINTAINER ZGY &lt;3030392760@qq.com&gt;<br><br><span class="hljs-comment"># 在容器中更新软件包并安装tzdata（一款管理时间的软件），然后设置运行环境时间与宿主机相同</span><br><span class="hljs-builtin-name">RUN</span> apk update &amp;&amp; apk <span class="hljs-builtin-name">add</span> tzdata &amp;&amp; cp -rf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><br><span class="hljs-comment"># 在容器中创建jar运行目录</span><br><span class="hljs-builtin-name">RUN</span> mkdir -p /apps<br><br><span class="hljs-comment"># 将宿主机中的server-jar包复制到容器中，并解压</span><br><span class="hljs-builtin-name">ADD</span> ./server-jre-8u191-linux-x64.tar.gz /usr/local/<br><br><span class="hljs-comment"># 设置环境变量</span><br>EVN JAVA_HOME /usr/local/jdk1.8.0_191<br>EVN JAVA_OPTS <span class="hljs-string">"-server -Xms512M -Xmx1024M"</span><br>EVN CLASSPATH <span class="hljs-variable">$JAVA_HOME</span>/bin<br>EVN PATH <span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin<br></code></pre></td></tr></table></figure></li><li><p>创建镜像</p><p><strong>注意：</strong>需要进入Dockerfile文件和jar包对应的目录中，运行下面的命令</p><p><code>docker build -t zgy/demo .</code></p></li><li><p>运行容器</p><p><code>docker run -tid --name zgy.demo zgy/demo</code></p></li></ol><p>参考链接：</p><ol><li><a href="https://blog.csdn.net/liupeifeng3514/article/details/80418887" target="_blank" rel="noopener">Alpine Linux 中的 apk 命令讲解</a></li><li><a href="https://blog.csdn.net/xie19900123/article/details/81410006" target="_blank" rel="noopener">构建自定义镜像</a></li></ol><h1 id="安装DNS服务器-dnsmasq"><a href="#安装DNS服务器-dnsmasq" class="headerlink" title="安装DNS服务器-dnsmasq"></a>安装DNS服务器-dnsmasq</h1><blockquote><p>什么是dnsmasq？</p><p>DNSmasq是一个小巧且方便地用于配置<a href="https://baike.baidu.com/item/DNS/427444" target="_blank" rel="noopener">DNS</a>和<a href="https://baike.baidu.com/item/DHCP" target="_blank" rel="noopener">DHCP</a>的工具，适用于小型<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C/143243" target="_blank" rel="noopener">网络</a>，它提供了DNS功能和可选择的DHCP功能。它服务那些只在本地适用的域名，这些域名是不会在全球的DNS服务器中出现的。DHCP服务器和DNS服务器结合，并且允许DHCP分配的地址能在DNS中正常解析，而这些DHCP分配的地址和相关命令可以配置到每台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151" target="_blank" rel="noopener">主机</a>中，也可以配置到一台核心设备中（比如路由器），DNSmasq支持静态和动态两种DHCP配置方式。 </p></blockquote><ol><li><p>搜索镜像</p><p><code>docker search dnsmasq</code></p></li><li><p>拉取镜像</p><p><code>docker pull dnsmasq</code></p></li><li><p>运行容器</p><p><code>docker run -d -p 53:53/udp -p 53:53/tcp --cap-add=NET_ADMIN -v /usr/dnsmasq:/etc/dnsmasq.d --name dns-server andyshinn/dnsmasq</code></p></li><li><p>修改配置文件，在宿主机的配置文件中添加要解析的域名</p><ol><li><code>vim /user/dnsmasq/dns-zgy.conf</code>，添加如下配置</li></ol><figure class="hljs highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">address=/noobgg.test/<span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.100</span><br></code></pre></td></tr></table></figure></li><li><p>重启容器</p><p><code>docker restart dns-server</code></p></li><li><p>测试</p><p>在另一台机器上将首选dns改为安装有dnsmasq服务器的ip地址，然后ping noobgg.test，看是否能够ping通，如果能，则安装成功。</p></li></ol><p>参考链接：</p><ol><li><a href="https://www.cnblogs.com/javacspring/p/6172327.html" target="_blank" rel="noopener">解决Docker容器时区及时间不同步问题</a> </li></ol><h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><ol><li><p>搜索镜像</p><p><code>docker search nginx</code></p></li><li><p>拉取镜像</p><p><code>docker pull nginx</code></p></li><li><p>运行容器</p><p><code>docker run -d --name zgy.nginx -p 80:80 -v /usr/nginx/conf/conf.d:/etc/nginx/conf.d -----link zgy.demo nginx</code></p></li><li><p>修改配置文件default.conf，配置如下</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br>    listen       80;<br>    server_name  noobgg.test;<br><br>    location &#x2F; &#123;<br>        proxy_pass  http:&#x2F;&#x2F;zgy.demo:9090;<br>        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    #error_page  404              &#x2F;404.html;<br><br>    # redirect server error pages to the static page &#x2F;50x.html<br>    #<br>    error_page   500 502 503 504  &#x2F;50x.html;<br>    location &#x3D; &#x2F;50x.html &#123;<br>        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重启容器</p><p><code>docker restart zgy.nginx</code></p></li><li><p>测试</p><p>打开浏览器访问：<a href="http://noobgg.test" target="_blank" rel="noopener">http://noobgg.test</a></p></li></ol><p>参考链接：</p><ol><li><a href="https://blog.csdn.net/subfate/article/details/81396532" target="_blank" rel="noopener">docker容器相互访问</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令笔记</title>
      <link href="/2020/01/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Dockerfile创建镜像"><a href="#使用Dockerfile创建镜像" class="headerlink" title="使用Dockerfile创建镜像"></a>使用Dockerfile创建镜像</h1><a id="more"></a><h1 id="Docker管理Volume"><a href="#Docker管理Volume" class="headerlink" title="Docker管理Volume"></a>Docker管理Volume</h1><h2 id="查看所有的volume"><a href="#查看所有的volume" class="headerlink" title="查看所有的volume"></a>查看所有的volume</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume ls<br><span class="hljs-comment"># 显示所有的volume名称列表</span><br>docker volume ls -qf dangling=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="删除volume"><a href="#删除volume" class="headerlink" title="删除volume"></a>删除volume</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除指定name的volume</span><br>docker volume rm name名称<br><span class="hljs-comment"># 删除所有的volume</span><br>docker volume rm $(docker volume ls -qf dangling=<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><h1 id="容器与主机之间的数据拷贝"><a href="#容器与主机之间的数据拷贝" class="headerlink" title="容器与主机之间的数据拷贝"></a>容器与主机之间的数据拷贝</h1><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker cp /www/runoob 96f7f14e99ab:/www/<br></code></pre></td></tr></table></figure><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker cp /www/runoob 96f7f14e99ab:/www<br></code></pre></td></tr></table></figure><p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker cp  96f7f14e99ab:/www /tmp/<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h1><ul><li>yum install 【软件包名】[-y]：安装指定的软件包，如果加上<code>-y</code>表示不询问安装。</li><li>yum remove 【软件包名】[-y]：删除指定软件包，如果加上<code>-y</code>表示不询问删除。</li><li>yum list installed：列出所用安装过的软件，可以配合<code>|</code>和<code>grep</code>命令做过滤。</li><li>yum list：列出所用软件，可以配合<code>|</code>和<code>grep</code>命令做过滤。</li><li>yum search 【软件包名】：查找指定的软件包。</li><li>yum clean all：删除缓存。</li><li>yum update ：更新所用的软件包，如果后面添加【软件包名】就是更新指定的软件包。</li></ul><a id="more"></a><h1 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h1><ul><li>rpm -e 【软件包名】：删除软件包。</li><li>rpm -ivh 【软件包名】：安装指定软件包。</li><li>rpm -Uvh 【软件包名】：更新指定软件包。</li><li>rpm -Uvh –oldpackage 【软件包名】：软甲包降级。</li><li>rpm -qa 【软件包名】：查找指定软件，可以配合<code>|</code>和<code>grep</code>命令做过滤。</li><li>rpm -ql 【软件包名】：查看软件安装的路径。</li></ul><h1 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h1><p>systemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。</p><table>    <tr>        <th>任务</th>        <th>旧指令</th>        <th>新指令</th>    </tr>    <tr>        <td>使某服务自动启动</td>        <td>chkconfig --level 3 httpd on</td>        <td>systemctl enable httpd.service</td>    </tr>    <tr>        <td>使某服务不自动启动</td>        <td>chkconfig --level 3 httpd off</td>        <td>systemctl disable httpd.service</td>    </tr>    <tr>        <td>检查服务状态</td>        <td>service httpd status</td>        <td>systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active)</td>    </tr>    <tr>        <td>显示所有已启动的服务</td>        <td>chkconfig --list</td>        <td>systemctl list-units --type=service</td>    </tr>    <tr>        <td>启动某服务</td>        <td>service httpd start</td>        <td>systemctl start httpd.service</td>    </tr>     <tr>        <td>停止某服务</td>        <td>service httpd stop</td>        <td>systemctl stop httpd.service</td>    </tr>     <tr>        <td>重启某服务</td>        <td>service httpd restart</td>        <td>systemctl restart httpd.service</td>    </tr>    <tr>        <td>查看自启服务</td>        <td>--</td>        <td>systemctl list-unit-files</td>    </tr></table><h1 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h1><ul><li>curl -o 【文件名】url：将指定的url资源下载到指定的文件中。</li><li>curl -L url：如果指定的url返回重定向，将跳转重定向地址，如果不加<code>L</code>将不回重定向。</li></ul><h1 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h1><ul><li>ln -s 【源文件】 【目标文件】：给源文件创建一个软连接到目标文件。</li></ul><p>更多详情，参考以下链接：</p><p><a href="https://www.cnblogs.com/kex1n/p/5193826.html" target="_blank" rel="noopener">linux 创建连接命令 ln -s 软链接</a></p><h1 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h1><ul><li>wget -O 【文件名】 url：将指定的url资源下载到指定的文件中。</li></ul><p>更多详情，参考以下链接：</p><p><a href="https://www.cnblogs.com/peida/archive/2013/03/18/2965369.html" target="_blank" rel="noopener">wget命令详解</a></p><h1 id="CentOS关闭SELinux"><a href="#CentOS关闭SELinux" class="headerlink" title="CentOS关闭SELinux"></a>CentOS关闭SELinux</h1><p>查看SELinux状态</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sestatus  -v<br></code></pre></td></tr></table></figure><p>临时关闭</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">setenforce 0<br></code></pre></td></tr></table></figure><p>永久关闭</p><p>修改/etc/selinux/config文件中的SELINUX=”enforcing” 为 disabled ，然后重启。</p><h1 id="CentOS7如何设置防火墙"><a href="#CentOS7如何设置防火墙" class="headerlink" title="CentOS7如何设置防火墙"></a>CentOS7如何设置防火墙</h1><p>在旧版本的CentOS中，是使用 iptables 命令来设置防火墙的。但是，从CentOS7开始，默认就没有安装iptables，而是改用firewall来配置防火墙。</p><p>firewall的配置文件是以xml的格式，存储在 /usr/lib/firewalld/ 和 /etc/firewalld/ 目录中。</p><p><strong>系统配置目录</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/lib/firewalld/<br>/usr/lib/firewalld/services<br>/usr/lib/firewalld/zones<br></code></pre></td></tr></table></figure><p><strong>用户配置目录</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/firewalld/<br>/etc/firewalld/services<br>/etc/firewalld/zones<br></code></pre></td></tr></table></figure><p><strong>设置防火墙</strong></p><p>设置防火墙的方式有两种：firewall命令和直接修改配置文件。</p><p>推荐使用firewall命令来设置防火墙。</p><p>注意： 对防火墙所做的更改，必须重启防火墙服务，才会立即生效。命令如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service firewalld restart 或 systemctl restart firewalld<br></code></pre></td></tr></table></figure><h2 id="设置防火墙的方式有两种"><a href="#设置防火墙的方式有两种" class="headerlink" title="设置防火墙的方式有两种"></a>设置防火墙的方式有两种</h2><h3 id="1-firewall命令"><a href="#1-firewall命令" class="headerlink" title="1. firewall命令"></a>1. firewall命令</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 对外开放3306端口，供外部的计算机访问</span><br><span class="hljs-comment"># 该命令方式添加的端口，可在/etc/firewalld/zones中的对应配置文件中得到体现</span><br>firewall-cmd --zone=public --add-port=3306/tcp --permanent<br><br><span class="hljs-comment"># 查看端口状态</span><br>firewall-cmd --zone=public --query-port=3306/tcp --permanent<br><br><span class="hljs-comment"># 对外关闭3306端口</span><br>firewall-cmd --zone=public --remove-port=3306/tcp --permanent<br><br><span class="hljs-comment"># 重启防火墙</span><br>systemctl restart firewalld<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>firewall-cmd：Linux中提供的操作firewall的工具。</li><li>–zone：指定作用域。</li><li>–add-port=80/tcp：添加的端口，格式为：端口/通讯协议。</li><li>–permanent：表示永久生效，没有此参数重启后会失效。</li></ul><p><strong>直接修改配置文件</strong></p><h3 id="2-直接修改配置文件"><a href="#2-直接修改配置文件" class="headerlink" title="2. 直接修改配置文件"></a>2. 直接修改配置文件</h3><p>/etc/firewalld/zones/public.xml 文件的默认内容为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;<br>&lt;zone&gt;<br>  &lt;short&gt;Public&lt;/short&gt;<br>  &lt;description&gt;For use <span class="hljs-keyword">in</span> public areas. You <span class="hljs-keyword">do</span> not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;<br>  &lt;service name=<span class="hljs-string">"dhcpv6-client"</span>/&gt;<br>  &lt;service name=<span class="hljs-string">"ssh"</span>/&gt;<br>&lt;/zone&gt;<br></code></pre></td></tr></table></figure><p>修改该配置文件，来添加3306端口。修改后的内容为：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;<br>&lt;zone&gt;<br>  &lt;short&gt;Public&lt;/short&gt;<br>  &lt;description&gt;For use <span class="hljs-keyword">in</span> public areas. You <span class="hljs-keyword">do</span> not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;<br>  &lt;service name=<span class="hljs-string">"dhcpv6-client"</span>/&gt;<br>  &lt;service name=<span class="hljs-string">"ssh"</span>/&gt;<br>  &lt;port protocol=<span class="hljs-string">"tcp"</span> port=<span class="hljs-string">"3306"</span>/&gt;<br>&lt;/zone&gt;<br></code></pre></td></tr></table></figure><h2 id="firewall常用命令"><a href="#firewall常用命令" class="headerlink" title="firewall常用命令"></a>firewall常用命令</h2><h3 id="1-查看firewall的状态"><a href="#1-查看firewall的状态" class="headerlink" title="1. 查看firewall的状态"></a>1. 查看firewall的状态</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">service firewalld status<br>或<br>systemctl status firewalld<br>或<br>firewall-cmd --state<br></code></pre></td></tr></table></figure><h3 id="2-启动、停止、重启"><a href="#2-启动、停止、重启" class="headerlink" title="2. 启动、停止、重启"></a>2. 启动、停止、重启</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br>service firewalld start<br>或<br>systemctl start firewalld<br><br><span class="hljs-comment"># 停止</span><br>service firewalld stop<br>或<br>systemctl stop firewalld<br><br><span class="hljs-comment"># 重启</span><br>service firewalld restart<br>或<br>systemctl restart firewalld<br></code></pre></td></tr></table></figure><h3 id="3-开机自启动的关闭与开启"><a href="#3-开机自启动的关闭与开启" class="headerlink" title="3. 开机自启动的关闭与开启"></a>3. 开机自启动的关闭与开启</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭开机自启动</span><br>systemctl <span class="hljs-built_in">disable</span> firewalld<br><br><span class="hljs-comment"># 开启开机自启动</span><br>systemctl <span class="hljs-built_in">enable</span> firewalld<br></code></pre></td></tr></table></figure><h3 id="4-查看防火墙的规则"><a href="#4-查看防火墙的规则" class="headerlink" title="4. 查看防火墙的规则"></a>4. 查看防火墙的规则</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --list-all<br></code></pre></td></tr></table></figure><h2 id="将CentOS7更改为iptables防火墙"><a href="#将CentOS7更改为iptables防火墙" class="headerlink" title="将CentOS7更改为iptables防火墙"></a>将CentOS7更改为iptables防火墙</h2><p>CentOS7切换到iptables防火墙，首先应该关闭默认的firewall防火墙并禁止自启动，然后再来安装和启动iptables防火墙。</p><p>操作步骤如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 停止firewall</span><br>systemctl stop firewalld<br><br><span class="hljs-comment"># 禁止firewall的开机自启动</span><br>systemctl <span class="hljs-built_in">disable</span> firewalld<br><br><span class="hljs-comment"># 安装iptables</span><br>yum install iptables-services<br><br><span class="hljs-comment"># 开启iptables</span><br>systemctl start iptables<br><br><span class="hljs-comment"># 启用iptables的自启动</span><br>systemctl <span class="hljs-built_in">enable</span> iptables<br></code></pre></td></tr></table></figure><p>之后，就可以在CentOS7中使用iptables配置防火墙。</p><p>允许外部的计算机访问mysql，操作如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加3306端口</span><br>iptables -A INPUT -p tcp -dport 3306 -j ACCEPT<br><br><span class="hljs-comment"># 保存当前的防火墙策略</span><br>service iptables save<br><br><span class="hljs-comment"># 重启iptables</span><br>service iptables restart<br></code></pre></td></tr></table></figure><h3 id="iptables常用命令："><a href="#iptables常用命令：" class="headerlink" title="iptables常用命令："></a>iptables常用命令：</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动iptables</span><br>service iptables start<br><br><span class="hljs-comment"># 停止iptables</span><br>service iptables stop<br><br><span class="hljs-comment"># 重启iptables</span><br>service iptables restart<br><br><span class="hljs-comment"># 查看iptables的状态</span><br>service iptables status<br></code></pre></td></tr></table></figure><p>iptables防火墙，非常重要的两个文件：</p><ul><li>配置文件 /etc/sysconfig/iptables-config</li><li>策略文件 /etc/sysconfig/iptables（默认是不存在的，使用service ipatables save 可以保存当前策略）</li></ul><h3 id="iptables常用参数说明"><a href="#iptables常用参数说明" class="headerlink" title="iptables常用参数说明"></a>iptables常用参数说明</h3><img src="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/1568967240839.png" class=""><p>更多详情，参考以下链接：</p><ul><li><a href="https://www.cnblogs.com/stulzq/p/9808504.html" target="_blank" rel="noopener">Centos7 防火墙 firewalld 实用操作</a></li><li><a href="https://blog.51cto.com/andyxu/2137046" target="_blank" rel="noopener">firewalld防火墙详解</a></li><li><a href="https://www.91yun.co/archives/1690" target="_blank" rel="noopener">iptables详解</a></li><li><a href="cnblogs.com/grimm/p/10345693.html">细说firewalld和iptables</a></li><li><a href="https://www.linuxprobe.com/chapter-08.html" target="_blank" rel="noopener">firewalld和iptables详解</a></li></ul><h1 id="端口占用查询"><a href="#端口占用查询" class="headerlink" title="端口占用查询"></a>端口占用查询</h1><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>netstat 命令应用是比较频繁的，比如查看端口占用啦，查看端口进程啦，这些时候都是有必要的。</p><p>netstat命令各个参数说明如下：</p><p>　　-t : 指明显示TCP端口</p><p>　　-u : 指明显示UDP端口</p><p>　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</p><p>　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。</p><p>　　-n : 不进行DNS轮询，显示IP(可以加速操作)</p><p>常用命令如下：</p><p>查看所有TCP端口</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ntlp<br></code></pre></td></tr></table></figure><p>查看所有端口</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ntulp<br></code></pre></td></tr></table></figure><p>查看指定端口的连接数量，比如：80</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -pnt |grep :80 |wc<br></code></pre></td></tr></table></figure><p>更多详情，参考以下链接：</p><p><a href="https://www.cnblogs.com/cxbhakim/p/9353383.html" target="_blank" rel="noopener">linux查看端口状态相关命令</a></p><h1 id="firewalld与docker冲突问题"><a href="#firewalld与docker冲突问题" class="headerlink" title="firewalld与docker冲突问题"></a>firewalld与docker冲突问题</h1><p>在CentOS7中，如果安装有docker，会出现firewalld与docker冲突问题，具体现象为，firewalld中并没有开发端口，但是其它机器依然能够访问docker提供的服务。出现这个问题的原因是因为firewalld和docker的启动顺序造成的，在机器启动后，firewalld服务比docker服务要先启动，在docker服务启动后修改了iptables规则，因为firewalld的底层实现也是基于iptables规则的，导致firewalld服务没有开发的端口，依然能够访问docker提供的服务。</p><p>解决办法有两种，如下</p><ol><li>不用firewalld，改用iptables</li><li>将firewalld服务和docker服务都停止，然后先启动docker服务，过5秒（服务启动存在时间，保证docker完全启动）再启动firewalld服务。</li></ol><h1 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h1><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>内容说明如下：</p><ul><li>PID：进程的ID</li><li>USER：进程所有者</li><li>PR：进程的优先级别，越小越优先被执行</li><li>NI：进程Nice值，代表这个进程的优先值</li><li>VIRT：进程占用的虚拟内存</li><li>RES：进程占用的物理内存</li><li>SHR：进程使用的共享内存</li><li>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态</li><li>%CPU：进程占用CPU的使用</li><li>%MEM：进程使用的物理内存和总内存的百分</li><li>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</li><li>COMMAND：启动该进程的命令名称</li></ul><h2 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用KB为单位展示数据</span><br>free<br><span class="hljs-comment"># 用MB为单位展示数据</span><br>free -m<br><span class="hljs-comment"># 用GB为单位展示数据</span><br>free -h<br></code></pre></td></tr></table></figure><p>内容说明如下：</p><ul><li>total : 总计屋里内存的大小</li><li>used : 已使用内存的大小</li><li>free : 可用内存的大小</li><li>shared : 多个进程共享的内存总额</li><li>buff/cache : 磁盘缓存大小</li><li>available : 可用内存大小 ， 从应用程序的角度来说：available = free + buff/cache .</li></ul><h2 id="linux可用内存足够为什么还用swap"><a href="#linux可用内存足够为什么还用swap" class="headerlink" title="linux可用内存足够为什么还用swap"></a>linux可用内存足够为什么还用swap</h2><blockquote><p>该部分内容摘抄自：<a href="[http://www.ps-aux.com/linux%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E8%B6%B3%E5%A4%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E4%BD%BF%E7%94%A8%E4%BA%86swap.html](http://www.ps-aux.com/linux可用内存足够为什么还使用了swap.html)">linux可用内存足够为什么还用swap</a></p></blockquote><h3 id="为什么-buffer-cache-会占用这么多的内存"><a href="#为什么-buffer-cache-会占用这么多的内存" class="headerlink" title="为什么 buffer/cache 会占用这么多的内存?"></a>为什么 <code>buffer/cache</code> 会占用这么多的内存?</h3><p>buffer/cache使用过高通常是程序频繁存取文件后,物理内存会很快被用光,<br>当程序结束后,内存不会被正常释放,而是成为cache状态.<br>通常我们不需要手工释放swap,Linux会自动管理.<br>如果非要释放,请继续看.</p><h3 id="如何释放占用的swap呢"><a href="#如何释放占用的swap呢" class="headerlink" title="如何释放占用的swap呢?"></a>如何释放占用的<code>swap</code>呢?</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 将内存缓冲区数据立刻同步到磁盘</span><br>[root@localhost ~]<span class="hljs-comment"># sync</span><br><span class="hljs-comment">## 关闭所有的swap</span><br>[root@localhost ~]<span class="hljs-comment"># swapoff -a</span><br><span class="hljs-comment">## 启用所有swap</span><br>[root@localhost ~]<span class="hljs-comment"># swapon -a</span><br>[root@localhost ~]<span class="hljs-comment"># free -m</span><br>              total        used        free      shared  buff/cache   available<br>Mem:          31768       10853         217       16740       20698        3658<br>Swap:          8191           0        8191<br></code></pre></td></tr></table></figure><h3 id="linux可用内存足够为什么还用swap-1"><a href="#linux可用内存足够为什么还用swap-1" class="headerlink" title="linux可用内存足够为什么还用swap?"></a>linux可用内存足够为什么还用swap?</h3><p>上面可以看到服务器共有32G内存,其中buff/cache占用了21G+.<br>明明还有可以将近12G的内存可以使用.但系统却偏偏占用完了swap的8G内存.<br>可知系统并没有自动释放buff/cache最大化利用内存.</p><p>原因:</p><p>内核参数 swappiness 的值的大小,决定着linux何时开始使用swap。</p><ul><li><code>swappiness=0</code> 时表示尽最大可能的使用物理内存以避免换入到swap.</li><li><code>swappiness＝100</code> 时候表示最大限度使用swap分区，并且把内存上的数据及时的换出到swap空间里面.</li><li>此值linux的基本默认设置为60，不同发行版可能略微不同.</li></ul><p>查看命令具体如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat /proc/sys/vm/swappiness</span><br>60<br></code></pre></td></tr></table></figure><p>什么意思呢?<br>就是说，你的内存在使用率到40%(100%-60%)的时候，系统就会开始出现有交换分区的使用。<br>大家知道，内存的速度会比磁盘快很多，这样子会加大系统io，同时造的成大量页的换进换出，严重影响系统的性能，所以我们在操作系统层面，要尽可能使用内存，对该参数进行调整。</p><h3 id="调整Swap在什么时候使用"><a href="#调整Swap在什么时候使用" class="headerlink" title="调整Swap在什么时候使用"></a>调整Swap在什么时候使用</h3><p><strong>临时生效</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># sysctl vm.swappiness=10</span><br>vm.swappiness = 10<br>[root@localhost ~]<span class="hljs-comment"># cat /proc/sys/vm/swappiness</span><br>10<br></code></pre></td></tr></table></figure><p><strong>重启依旧生效</strong></p><p>需要在/etc/sysctl.conf修改:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat /etc/sysctl.conf</span><br>vm.swappiness = 10<br>[root@localhost ~]<span class="hljs-comment"># sysctl -p</span><br></code></pre></td></tr></table></figure><h3 id="shared内存"><a href="#shared内存" class="headerlink" title="shared内存"></a>shared内存</h3><p>通常我们还经常看到shared占用大量内存,shared表示共享内存的占用,<br>起决定参数的两个分别是:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 定义单个共享内存段的最大值</span><br>kernel.shmmax = 68719476736   <br><span class="hljs-comment"># 定义共享内存页数</span><br>kernel.shmall = 4194304  <span class="hljs-comment">##(16G)</span><br></code></pre></td></tr></table></figure><p>当前系统内存页大小查看:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># getconf  PAGESIZE</span><br>4096<br></code></pre></td></tr></table></figure><p>当前系统共享内存段大小(bytes):</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># cat /proc/sys/kernel/shmmax</span><br>16777216000<br></code></pre></td></tr></table></figure><p>共享内存段个数查看:</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># ipcs -m</span><br></code></pre></td></tr></table></figure><h1 id="curl命令详解"><a href="#curl命令详解" class="headerlink" title="curl命令详解"></a>curl命令详解</h1><p>curl -fsSL url链接：获取url链接的内容。</p><p>参数详解：</p><ul><li>f：连接失败时不显示http错误。</li><li>s：静默模式。不输出任何东西。</li><li>S：当有错误信息时，显示错误。</li><li>L：当请求放回301（重定向）状态码时，会访问新的网址。</li></ul><h1 id="查看Linux内核与版本"><a href="#查看Linux内核与版本" class="headerlink" title="查看Linux内核与版本"></a>查看Linux内核与版本</h1><ul><li><p>uname -a</p><img src="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/1570762324882.png" class=""></li><li><p>cat /proc/version</p></li><li><p>lsb_release -a</p></li><li><p>cat /etc/redhat-release，这种方法只适合Redhat系的Linux。</p></li><li><p>cat /etc/issue，这种方法通用。</p></li></ul><h1 id="Ubuntu-环境变量设置方法"><a href="#Ubuntu-环境变量设置方法" class="headerlink" title="Ubuntu 环境变量设置方法"></a>Ubuntu 环境变量设置方法</h1><h2 id="对所有用户生效，永久的"><a href="#对所有用户生效，永久的" class="headerlink" title="对所有用户生效，永久的"></a>对所有用户生效，永久的</h2><ul><li><p>在/etc/profile文件中添加变量</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开文件 (以设置java环境为例)</span><br>vi /etc/profile<br><span class="hljs-comment"># 在文末加入 </span><br>  <span class="hljs-comment"># 注意：1）linux用冒号“:”来分隔路径, windows用分号;来分割</span><br>   <span class="hljs-comment"># 2）CLASSPATH中当前目录“.”不能丢,把当前目录丢掉也是常见的错误。</span><br>   <span class="hljs-comment"># 3) export是把这变量导出为全局变量。</span><br>   <span class="hljs-comment"># 4) 严格区分大小写。</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/share/jdk1.8.0_05<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> CLASSPATH=./JAVA_HOME/lib:<span class="hljs-variable">$JAVA_HOME</span>/jre/lib<br><span class="hljs-comment"># 生效</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>在/etc/environment 中添加变量</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># enviroment文件比较不同, 原文件应为PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games" 的形式</span><br><span class="hljs-comment"># 直接在后面加上冒号和路径即可</span><br>PATH=<span class="hljs-string">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/etc/apache/bin"</span><br>PRESTO=<span class="hljs-string">"/home/zhen/software/PRESTO/presto"</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="对单一用户生效，永久的"><a href="#对单一用户生效，永久的" class="headerlink" title="对单一用户生效，永久的"></a>对单一用户生效，永久的</h2><ul><li><p>修改/etc/bash.bashrc</p></li><li><p>修改~/.bashrc</p></li><li><p>修改~/.profile （有时候是 ~/.bash_profile，或者 ~/.bash_login）</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 与 /etc/profile 文件的添加方法相同</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="只对当前shell有效，临时的"><a href="#只对当前shell有效，临时的" class="headerlink" title="只对当前shell有效，临时的"></a>只对当前shell有效，临时的</h2><ul><li><p>直接运行export命令定义变量</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意：＝ 即等号两边不能有任何空格</span><br><span class="hljs-built_in">export</span> SCHED=/home/zhen/software/sched_11.4<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/etc/apache/bin<br><span class="hljs-built_in">export</span> PATH=/etc/apache/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>使得设置立即生效</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># for sys</span><br><span class="hljs-built_in">source</span> /etc/environment<br><span class="hljs-comment"># for all users</span><br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-comment"># for single user</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br><span class="hljs-comment"># or logout the system.</span><br></code></pre></td></tr></table></figure><p><strong>参考链接如下</strong>：</p><blockquote><p><a href="http://zhaozhen.me/2017/09/15/ubuntu-evm.html" target="_blank" rel="noopener">Ubuntu 环境变量设置方法</a></p></blockquote><h1 id="关于ubuntu的sources-list总结"><a href="#关于ubuntu的sources-list总结" class="headerlink" title="关于ubuntu的sources.list总结"></a>关于ubuntu的sources.list总结</h1><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>   文件/etc/apt/sources.list是一个普通可编辑的文本文件，保存了ubuntu软件更新的源服务器的地址。和sources.list功能一样的是/etc/apt/sources.list.d/<em>.list(*代表一个文件名，只能由字母、数字、下划线、英文句号组成)。sources.list.d目录下的</em>.list文件为在单独文件中写入源的地址提供了一种方式，通常用来安装第三方的软件。</p><figure class="hljs highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-security main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-updates main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-proposed main restricted universe multiverse<br>deb http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-backports main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-security main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-updates main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-proposed main restricted universe multiverse<br>deb-src http:<span class="hljs-regexp">//</span>archive.ubuntu.com<span class="hljs-regexp">/ubuntu/</span> trusty-backports main restricted universe multiverse<br></code></pre></td></tr></table></figure><p>   如上是ubuntu官方sources.list文件内容，具体地含义如下：</p><p>   每一行的开头是deb或者deb-src，分别表示直接通过.deb文件进行安装和通过源文件的方式进行安装。</p><p>   deb或者deb-src字段之后，是一段URL，之后是五个用空格隔开的字符串，分别对应相应的目录结构。在浏览器中输入<a href="http://archive.ubuntu.com/ubuntu/，并进入dists目录，可以发现有5个目录和前述sources.list文件中的第三列字段相对应。任选其中一个目录进入，可以看到和sources.list后四列相对应的目录结构。" target="_blank" rel="noopener">http://archive.ubuntu.com/ubuntu/，并进入dists目录，可以发现有5个目录和前述sources.list文件中的第三列字段相对应。任选其中一个目录进入，可以看到和sources.list后四列相对应的目录结构。</a></p><p>更多内容可以使用man source.list获得。</p><img src="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/051605496117149.png" class=""><img src="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/051606162679773.png" class=""><h2 id="二、源的选择"><a href="#二、源的选择" class="headerlink" title="二、源的选择"></a>二、源的选择</h2><p>   ubuntu官方有自身的软件源，直接从官方的软件源获取数据的速度比较慢。而通过国内的一些的源的镜像进行更新一般能够获得比官方源更快的速度，不过不同国内的源的下载速度也会不一样。<a href="http://wiki.ubuntu.org.cn/源列表" target="_blank" rel="noopener">这里</a>给出了较为详细的ubuntu软件源列表，个人现在觉得选取ubuntu软件源的方法是首先选择位于相同地区的源，然后进行ping操作，时延不是太高即可。对比aliyun、sohu、ubuntu官方ping的数据，可以发现aliyun的源在时延上表现最好。</p><img src="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/051619280959698.png" class=""><img src="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/051620001422176.png" class=""><img src="/2020/01/03/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/051620372528304.png" class=""><h1 id="vim编辑器缩进设置"><a href="#vim编辑器缩进设置" class="headerlink" title="vim编辑器缩进设置"></a>vim编辑器缩进设置</h1><p>在 /etc/vimrc文件中追加如下内容</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">" vim 缩进设置<br>set ts=4<br>set expandtab<br>set autoindent</span><br></code></pre></td></tr></table></figure><p>ts：表示缩进空格数。</p><p>expandtab：表示按退格键时，按一次删除一个空格。</p><p>autoindent：表示开启自动缩进。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iptables自定义链</title>
      <link href="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/"/>
      <url>/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>你可能会问，iptables的默认链就已经能够满足我们了，为什么还需要自定义链呢？</p><p>原因如下：</p><p>当默认链中的规则非常多时，不方便我们管理。</p><p>想象一下，如果INPUT链中存放了200条规则，这200条规则有针对httpd服务的，有针对sshd服务的，有针对私网IP的，有针对公网IP的，假如，我们突然想要修改针对httpd服务的相关规则，难道我们还要从头看一遍这200条规则，找出哪些规则是针对httpd的吗？这显然不合理。 </p><a id="more"></a><p>所以，iptables中，可以自定义链，通过自定义链即可解决上述问题。</p><p>假设，我们自定义一条链，链名叫IN_WEB，我们可以将所有针对80端口的入站规则都写入到这条自定义链中，当以后想要修改针对web服务的入站规则时，就直接修改IN_WEB链中的规则就好了，即使默认链中有再多的规则，我们也不会害怕了，因为我们知道，所有针对80端口的入站规则都存放在IN_WEB链中，同理，我们可以将针对sshd的出站规则放入到OUT_SSH自定义链中，将针对Nginx的入站规则放入到IN_NGINX自定义链中，这样，我们就能想改哪里改哪里，再也不同担心找不到规则在哪里了。 </p><p>但是需要注意的是，自定义链并不能直接使用，而是需要被默认链引用才能够使用，空口白话说不明白，等到示例时我们自然会明白。 </p><p>说了这么多，我们来动手创建一条自定义链，使用-N选项可以创建自定义链，示例如下</p> <img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_1.png" class=""><p>如上图所示，”-t filter”表示操作的表为filter表，与之前的示例相同，省略-t选项时，缺省操作的就是filter表。</p><p>“-N IN_WEB”表示创建一个自定义链，自定义链的名称为”IN_WEB”</p><p>自定义链创建完成后，查看filter表中的链，如上图所示，自定义链已经被创建，而且可以看到，这条自定义链的引用计数为0 (0 references)，也就是说，这条自定义链还没有被任何默认链所引用，所以，即使IN_WEB中配置了规则，也不会生效，我们现在不用在意它，继续聊我们的自定义链。</p><p>好了，自定义链已经创建完毕，现在我们就可以直接在自定义链中配置规则了，如下图所示，我们配置一些规则用于举例。</p> <img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_2.png" class=""><p>如上图所示，对自定义链的操作与对默认链的操作并没有什么不同，一切按照操作默认链的方法操作自定义链即可。</p><p>现在，自定义链中已经有了一些规则，但是目前，这些规则无法匹配到任何报文，因为我们并没有在任何默认链中引用它。</p><p>既然IN_WEB链是为了针对web服务的入站规则而创建的，那么这些规则应该去匹配入站的报文，所以，我们应该用INPUT链去引用它。</p><p>当然，自定义链在哪里创建，应该被哪条默认链引用，取决于实际的工作场景，因为此处示例的规则是匹配入站报文，所以在INPUT链中引用自定义链。</p><p>示例如下。</p><img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_3.png" class=""><p>上图中，我们在INPUT链中添加了一条规则，访问本机80端口的tcp报文将会被这条规则匹配到</p><p>而上述规则中的”-j IN_WEB”表示：访问80端口的tcp报文将由自定义链”IN_WEB”中的规则进行处理，没错，在之前的示例中，我们使用”-j”选项指定动作，而此处，我们将”动作”替换为了”自定义链”，当”-j”对应的值为一个自定义链时，就表示被当前规则匹配到的报文将交由对应的自定义链处理，具体怎样处理，取决于自定义链中的规则，当IN_WEB自定义链被INPUT链引用以后，可以发现，IN_WEB链的引用计数已经变为1，表示这条自定义链已经被引用了1次，自定义链还可以引用其他的自定义链，感兴趣的话，动手试试吧。</p><p>在之前的文章中，我们说过，”动作”在iptables中被称为”target”，这样描述并不准确，因为target为目标之意，报文被规则匹配到以后，target能是一个”动作”，target也能是一个”自定义链”，当target为一个动作时，表示报文按照指定的动作处理，当target为自定义链时，表示报文由自定义链中的规则处理，现在回过头再理解之前的术语，似乎更加明了了。</p><p>那么此刻，我们在192.168.1.139上尝试访问本机的80端口，已经被拒绝访问，证明刚才自定义链中的规则已经生效了。 </p><img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_4.png" class=""><p>过了一段时间，我们发现IN_WEB这个名字不太合适，我们想要将这条自定义链重命名，把名字改成WEB，可以吗？必须能啊，示例如下</p><img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_5.png" class=""><p>如上图所示，使用”-E”选项可以修改自定义链名，如上图所示，引用自定义链处的名称会自动发生改变。</p><p>好了，我们已经能够创建自定义了，那么怎样删除自定义链呢？</p><p>使用”-X”选项可以删除自定义链，但是删除自定义链时，需要满足两个条件：</p><p>1、自定义链没有被任何默认链引用，即自定义链的引用计数为0。</p><p>2、自定义链中没有任何规则，即自定义链为空。</p><p>那么，我们来删除自定义链WEB试试。</p><img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_6.png" class=""><p>如上图所示，使用”-X”选项删除对应的自定义链，但是上例中，并没有成功删除自定义链WEB，提示：Too many links，是因为WEB链已经被默认链所引用，不满足上述条件1，所以，我们需要删除对应的引用规则，示例如下。</p><img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_7.png" class=""><p>如上图所示，删除引用自定义链的规则后，再次尝试删除自定义链，提示：Directory not empty，是因为WEB链中存在规则，不满足上述条件2，所以，我们需要清空对应的自定义链，示例如下</p><img src="/2020/01/03/iptables%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE/050717_1352_8.png" class=""><p>如上图所示，使用”-X”选项可以删除一个引用计数为0的、空的自定义链。</p><p><strong>小结</strong></p><p> 为了方便以后回顾，我们将上述命令进行总结。 </p><p><strong>创建自定义链</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#示例：在filter表中创建IN_WEB自定义链</span><br>iptables -t filter -N IN_WEB<br></code></pre></td></tr></table></figure><p><strong>引用自定义链</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#示例：在INPUT链中引用刚才创建的自定义链</span><br>iptables -t filter -I INPUT -p tcp --dport 80 -j IN_WEB<br></code></pre></td></tr></table></figure><p><strong>重命名自定义链</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#示例：将IN_WEB自定义链重命名为WEB</span><br>iptables -E IN_WEB WEB<br></code></pre></td></tr></table></figure><p><strong>删除自定义链</strong></p><p>删除自定义链需要满足两个条件</p><p>1、自定义链没有被引用</p><p>2、自定义链中没有任何规则</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#示例：删除引用计数为0并且不包含任何规则的WEB链</span><br>iptables -X WEB<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack详解</title>
      <link href="/2020/01/03/Webpack%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/03/Webpack%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="nrm工具使用"><a href="#nrm工具使用" class="headerlink" title="nrm工具使用"></a>nrm工具使用</h1><p>简述：一个管理镜像源地址的工具。</p><p>安装：<code>npm i nrm -g</code>。</p><p>查看当前使用的镜像源地址：<code>nrm ls</code>。</p><p>切换镜像源地址：<code>nrm use npm</code>或<code>nrm use taobao</code>。</p><h1 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h1><p>简述：Webpack是一个前端的项目构建工具，是基于node.js开发的一个前段工具。</p><a id="more"></a><h1 id="Webpack安装的两种方式"><a href="#Webpack安装的两种方式" class="headerlink" title="Webpack安装的两种方式"></a>Webpack安装的两种方式</h1><ol><li>运行<code>npm i webpack -g</code>全局安装，这样就能在全局使用webpack命令了。</li><li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手和四次挥手详解</title>
      <link href="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TCP 三次握手和四次挥手的问题在面试中是最为常见的考点之一。很多读者都知道三次和四次，但是如果问深入一点，他们往往都无法作出准确回答。 </p></blockquote><h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1><p> TCP 三次握手就好比两个人在街上隔着 50 米看见了对方，但是因为雾霾等原因不能 100% 确认，所以要通过招手的方式相互确定对方是否认识自己。 </p> <img src="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/640.gif" class=""><p>张三首先向李四招手(syn)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(ack)。</p><p>张三看到李四微笑后确认了李四成功辨认出了自己(进入 estalished 状态)。</p><p>但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。</p><p>所以李四也向张三招了招手(syn)，张三看到李四向自己招手后知道对方是在寻求自己的确认。</p><p>于是也点了点头挤出了微笑(ack)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入 established 状态)。</p><p>于是两人加快步伐，走到了一起，相互拥抱。 </p><a id="more"></a> <img src="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/640-1571975130958.gif" class=""><p> 我们看到这个过程中一共是如下四个动作： </p><ul><li><p><strong>张三招手</strong></p></li><li><p><strong>李四点头微笑</strong></p></li><li><p><strong>李四招手</strong></p></li><li><p><strong>张三点头微笑</strong></p><p>其中李四连续进行了 2 个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(syn+ack)。</p></li></ul><p>于是四个动作就简化成了三个动作，张三招手→李四点头微笑并招手→张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。</p><p>我们看到有两个中间状态，syn_sent 和 syn_rcvd，<strong>这两个状态叫做 「半打开」 状态</strong> ，就是向对方招手了，但是还没来得及看到对方的点头微笑。</p><p>syn_sent 是主动打开方的 <strong>「半打开」</strong> 状态，syn_rcvd 是被动打开方的 <strong>「半打开」</strong> 状态。客户端是主动打开方，服务器是被动打开方。</p><ul><li><strong>syn_sent：</strong> syn package has been sent</li><li><strong>syn_rcvd：</strong> syn package has been received</li></ul><h1 id="TCP-数据传输"><a href="#TCP-数据传输" class="headerlink" title="TCP 数据传输"></a>TCP 数据传输</h1><p> TCP 数据传输就是两个人隔空对话，差了一点距离，所以需要对方反复确认听见了自己的话。 </p> <img src="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/640-1571975188640.gif" class=""><p>张三喊了一句话(data)，李四听见了之后要向张三回复自己听见了(ack)。</p><p>如果张三喊了一句，半天没听到李四回复，张三就认为自己的话被大风吹走了，李四没听见，所以需要重新喊话，这就是 TCP 重传。</p><p>也有可能是李四听到了张三的话，但是李四向张三的回复被大风吹走了，以至于张三没听见李四的回复。</p><p>张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了，张三也不用管，重传一下就是。</p><p>既然会重传，李四就有可能同一句话听见了两次，这就是 <strong>「去重」</strong> 。 <strong>「重传」</strong> 和 <strong>「去重」</strong> 工作在操作系统的网络内核模块都已经帮我们处理好了，用户层是不用关心的。 </p> <img src="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/640-1571975208914.gif" class=""><p>张三可以向李四喊话，同样李四也可以向张三喊话，因为 TCP 链接是 <strong>「双工的」</strong> ，双方都可以主动发起数据传输。</p><p>不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。</p><p>张三可能是个高射炮，一连说了八句话，这时候李四可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量 ACK。</p><p>但是张三也不能一次性说太多话，李四的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是 <strong>「TCP 窗口大小」</strong> 。</p><p>网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。</p><p>同一个来源发出来的不同数据包在 <strong>「网际路由」</strong> 上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。</p><p>操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。 </p><h1 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h1><p>TCP 断开链接的过程和建立链接的过程比较类似，只不过中间的两步并不总是会合成一步走。</p><p>所以它分成了如下 4 个动作：</p><ul><li><p><strong>张三挥手(fin)</strong></p></li><li><p><strong>李四伤感地微笑(ack)</strong></p></li><li><p><strong>李四挥手(fin)</strong></p></li><li><p><strong>张三伤感地微笑(ack)</strong></p><img src="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/640-1571975246059.gif" class=""></li></ul><p>之所以中间的两个动作没有合并，是因为 TCP 存在 <strong>「半关闭」</strong> 状态，也就是单向关闭。</p><p>张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。</p><p>等待李四累了，也不再说话了，朝张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。 </p> <img src="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/640-1571975259924.gif" class=""><p>上面有一个非常特殊的状态 time_wait，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态。</p><p>这个状态标准的持续时间是 4 分钟，4 分钟后才会进入到 Closed 状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。</p><p>它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续 4 分钟的 time_wait 状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。</p><p>它的作用是重传最后一个 ack 报文，确保对方可以收到。因为如果对方没有收到 ack 的话，会重传 fin 报文，处于 time_wait 状态的套接字会立即向对方重发 ack 报文。</p><p>同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。</p><p>4 分钟的时间足以使得这些残留报文彻底消逝。不然，当新的端口被重复利用时，这些残留报文可能会干扰新的链接。</p><p>4 分钟就是 2 个 MSL，每个 MSL 是 2 分钟。MSL 就是 Maximum Segment Lifetime——最长报文寿命。</p><p>这个时间是由官方 RFC 协议规定的。至于为什么是 2 个 MSL 而不是 1 个 MSL，我还没有看到一个非常满意的解释。</p><p>四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的。</p><p>这个时候就成了三次挥手，主动关闭方就会从 fin_wait_1 状态直接进入到 time_wait 状态，跳过了 fin_wait_2 状态。 </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 三次握手四次挥手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Disruptor——详解</title>
      <link href="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="资料一（基础概念-简单demo）"><a href="#资料一（基础概念-简单demo）" class="headerlink" title="资料一（基础概念+简单demo）"></a>资料一（基础概念+简单demo）</h1><p><strong>背景</strong></p><p>高并发是指通过设计保证系统能够同时并行处理很多请求。虽然我在工作中经常听到高并发，QPS之类的术语。其实，我对高并发也是一知半解，知道Java里面可以用Lock，Synchronized，ArrayBlockingQueue之类的来进行高并发的处理。我个人觉得，高并发领域更多的依靠的是经验的累积。今天想跟大家分享的是一个高性能的并发框架Disruptor。</p><a id="more"></a><p><strong>Disruptor概述</strong></p><p>Disruptor是一个异步并发处理框架。是由LMAX公司开发的一款高效的无锁内存队列。它使用无锁的方式实现了一个环形队列，非常适合于实现生产者和消费者模式，比如事件和消息的发布。</p><p>Disruptor最大特点是高性能，其LMAX架构可以获得每秒6百万订单，用1微秒的延迟获得吞吐量为100K+。</p><p><strong>一个官网的简单的demo</strong></p><p>1.maven依赖<br>maven引入Disruptor的jar包，Disruptor版本为3.2.1</p><figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.创建数据实体类LongEvent</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代表数据的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEvent</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.创建工厂类LongEventFactory</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//产生LongEvent的工厂类，它会在Disruptor系统初始化时，构造所有的缓冲区中的对象实例（预先分配空间）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventFactory</span>&lt;<span class="hljs-title">LongEvent</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LongEvent <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LongEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.创建消费者类LongEventHandler</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//消费者实现为WorkHandler接口，是Disruptor框架中的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">LongEvent</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//onEvent()方法是框架的回调用法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(LongEvent event, <span class="hljs-keyword">long</span> sequence, <span class="hljs-keyword">boolean</span> endOfBatch)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Event: "</span> + event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.创建生产者类LongEventProducer</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//消费者实现为WorkHandler接口，是Disruptor框架中的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventProducer</span> </span>&#123;<br>    <span class="hljs-comment">//环形缓冲区,装载生产好的数据；</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LongEventProducer</span><span class="hljs-params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ringBuffer = ringBuffer;<br>    &#125;<br><br>    <span class="hljs-comment">//将数据推入到缓冲区的方法：将数据装载到ringBuffer</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onData</span><span class="hljs-params">(ByteBuffer bb)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> sequence = ringBuffer.next();<br><br>        <span class="hljs-comment">// Grab the next sequence //获取下一个可用的序列号</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            LongEvent event = ringBuffer.get(sequence);<br><br>            <span class="hljs-comment">// Get the entry in the Disruptor //通过序列号获取空闲可用的LongEvent</span><br><br>            <span class="hljs-comment">// for the sequence</span><br>            event.set(bb.getLong(<span class="hljs-number">0</span>));<br><br>            <span class="hljs-comment">// Fill with data //设置数值</span><br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            ringBuffer.publish(sequence);<br><br>            <span class="hljs-comment">//数据发布，只有发布后的数据才会真正被消费者看见</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.创建测试类 LongEventMain</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventMain</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建线程池</span><br>        Executor executor = Executors.newCachedThreadPool();<br>        <span class="hljs-comment">// 事件工厂</span><br>        LongEventFactory factory = <span class="hljs-keyword">new</span> LongEventFactory();<br>        <span class="hljs-comment">// ringBuffer 的缓冲区的大小是1024</span><br>        <span class="hljs-keyword">int</span> bufferSize = <span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">// 创建一个disruptor, ProducerType.MULTI:创建一个环形缓冲区支持多事件发布到一个环形缓冲区</span><br>        Disruptor&lt;LongEvent&gt; disruptor = <span class="hljs-keyword">new</span> Disruptor&lt;&gt;(factory, bufferSize, executor, ProducerType.MULTI, <span class="hljs-keyword">new</span> BlockingWaitStrategy());<br>        <span class="hljs-comment">// 创建一个消费者</span><br>        disruptor.handleEventsWith(<span class="hljs-keyword">new</span> LongEventHandler());<br>        <span class="hljs-comment">// 启动并初始化disruptor</span><br>        disruptor.start();<br>        <span class="hljs-comment">// 获取已经初始化好的ringBuffer</span><br>        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();<br><br>        <span class="hljs-comment">// 生产数据</span><br>        LongEventProducer producer = <span class="hljs-keyword">new</span> LongEventProducer(ringBuffer);<br>        ByteBuffer bb = ByteBuffer.allocate(<span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> l = <span class="hljs-number">0</span>; <span class="hljs-keyword">true</span>; l++) &#123;<br>            bb.putLong(<span class="hljs-number">0</span>, l);<br>            producer.onData(bb);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>7.demo结果输出</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/image-20191218180407076.png" class=""><p><strong>Disruptor的一些核心介绍</strong></p><p><strong>1.RingBuffer</strong></p><p>RingBuffer是其核心，生产者向RingBuffer中写入元素，消费者从RingBuffer中消费元素。</p><p>随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。</p><p>槽的个数是2的N次方更有利于基于二进制的计算机进行计算。（注：2的N次方换成二进制就是1000，100，10，1这样的数字， sequence &amp; （array length－1） = array index，比如一共有8槽，3&amp;（8－1）=3，HashMap就是用这个方式来定位数组元素的，这种方式比取模的速度更快。）</p><p>会预先分配内存,可以做到完全的内存复用。在系统的运行过程中，不会有新的空间需要分配或者老的空间需要回收。因此，可以大大减少系统分配空间以及回收空间的额外开销。</p><p>关于RingBuffer可以直观的看一下下面的这幅图片（网上copy的），表示取到编号为4的数据。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/image-20191218180458585.png" class=""><p><strong>2.消费者等待策略</strong></p><p>BlockingWaitStrategy：这是默认的策略。使用锁和条件进行数据的监控和线程的唤醒。因为涉及到线程的切换，是最节省CPU，但在高并发下性能表现最糟糕的一种等待策略。</p><p>SleepingWaitStrategy:会自旋等待数据，如果不成功，才让出cpu，最终进行线程休眠，以确保不占用太多的CPU数据，因此可能产生比较高的平均延时。比较适合对延时要求不高的场合，好处是对生产者线程的影响最小。典型的应用场景是异步日志。</p><p>YieldingWaitStrategy:用于低延时的场合。消费者线程不断循环监控缓冲区变化，在循环内部，会使用Thread.yield()让出cpu给别的线程执行时间。</p><p>BusySpinWaitStrategy:开启的是一个死循环监控，消费者线程会尽最大努力监控缓冲区变化，因此，CPU负担比较大</p><p><strong>3.Disruptor的应用场景</strong></p><p>Disruptor号称能够在一个线程里每秒处理 6 百万订单,实际上我也没有测试过。Disruptor实际上内部是使用环形队列来实现的，所以一般来说，在消费者和生产者的场景中都可以考虑使用Disruptor。比如像日志处理之类的。实际上，我个人觉得Disruptor就像是Java里面的ArrayBlockingQueue的替代者，因为Disruptor可以提供更高的并发度和吞吐量。从下面这幅官网的图就可以直观的感受到Disruptor和ArrayBlockingQueue之间的效率的对比。(注意这是一个对数对数尺度，不是线性的。)</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640.webp" class=""><h1 id="资料二（Disruptor为什么这么快？）"><a href="#资料二（Disruptor为什么这么快？）" class="headerlink" title="资料二（Disruptor为什么这么快？）"></a>资料二（Disruptor为什么这么快？）</h1><p><strong>Padding Cache Line，体验高速缓存的威力</strong></p><p>我们先来看看 Disruptor 里面一段神奇的代码。这段代码里，Disruptor 在 RingBufferPad 这个类里面定义了 p1，p2 一直到 p7 这样 7 个 long 类型的变量。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RingBufferPad</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5, p6, p7;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721121761.webp" class=""><p>面临这样一个情况，Disruptor 里发明了一个神奇的代码技巧，这个技巧就是缓存行填充。Disruptor 在 RingBufferFields 里面定义的变量的前后，分别定义了 7 个 long 类型的变量。前面的 7 个来自继承的 RingBufferPad 类，后面的 7 个则是直接定义在 RingBuffer 类里面。这 14 个变量没有任何实际的用途。我们既不会去读他们，也不会去写他们。</p><p>而 RingBufferFields 里面定义的这些变量都是 final 的，第一次写入之后不会再进行修改。所以，一旦它被加载到 CPU Cache 之后，只要被频繁地读取访问，就不会再被换出 Cache 了。这也就意味着，对于这个值的读取速度，会是一直是 CPU Cache 的访问速度，而不是内存的访问速度。</p><p><strong>使用 RingBuffer，利用缓存和分支预测</strong></p><p>其实这个利用 CPU Cache 的性能的思路，贯穿了整个 Disruptor。Disruptor 整个框架，其实就是一个高速的生产者 - 消费者模型（Producer-Consumer）下的队列。生产者不停地往队列里面生产新的需要处理的任务，而消费者不停地从队列里面处理掉这些任务。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721233410.webp" class=""><p>如果你熟悉算法和数据结构，那你应该非常清楚，如果要实现一个队列，最合适的数据结构应该是链表。我们只要维护好链表的头和尾，就能很容易实现一个队列。生产者只要不断地往链表的尾部不断插入新的节点，而消费者只需要不断从头部取出最老的节点进行处理就好了。我们可以很容易实现生产者 - 消费者模型。实际上，Java 自己的基础库里面就有 LinkedBlockingQueue 这样的队列库，可以直接用在生产者 - 消费者模式上。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721247878.webp" class=""><p>不过，Disruptor 里面并没有用 LinkedBlockingQueue，而是使用了一个 RingBuffer 这样的数据结构，这个 RingBuffer 的底层实现则是一个固定长度的数组。比起链表形式的实现，数组的数据在内存里面会存在空间局部性。</p><p>就像上面我们看到的，数组的连续多个元素会一并加载到 CPU Cache 里面来，所以访问遍历的速度会更快。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个 Cache Line 加载后数据连续从高速缓存里面被访问到的优势。</p><p>除此之外，数据的遍历访问还有一个很大的优势，就是 CPU 层面的分支预测会很准确。这可以使得我们更有效地利用了 CPU 里面的多级流水线，我们的程序就会跑得更快。</p><p><strong>总结延伸</strong></p><p>好了，不知道讲完这些，你有没有体会到 Disruptor 这个框架的神奇之处呢？</p><p>CPU 从内存加载数据到 CPU Cache 里面的时候，不是一个变量一个变量加载的，而是加载固定长度的 Cache Line。如果是加载数组里面的数据，那么 CPU 就会加载到数组里面连续的多个数据。所以，数组的遍历很容易享受到 CPU Cache 那风驰电掣的速度带来的红利。</p><p>对于类里面定义的单独的变量，就不容易享受到 CPU Cache 红利了。因为这些字段虽然在内存层面会分配到一起，但是实际应用的时候往往没有什么关联。于是，就会出现多个 CPU Core 访问的情况下，数据频繁在 CPU Cache 和内存里面来来回回的情况。而 Disruptor 很取巧地在需要频繁高速访问的变量，也就是 RingBufferFields 里面的 indexMask 这些字段前后，各定义了 7 个没有任何作用和读写请求的 long 类型的变量。</p><p>这样，无论在内存的什么位置上，这些变量所在的 Cache Line 都不会有任何写更新的请求。我们就可以始终在 Cache Line 里面读到它的值，而不需要从内存里面去读取数据，也就大大加速了 Disruptor 的性能。</p><p>这样的思路，其实渗透在 Disruptor 这个开源框架的方方面面。作为一个生产者 - 消费者模型，Disruptor 并没有选择使用链表来实现一个队列，而是使用了 RingBuffer。RingBuffer 底层的数据结构则是一个固定长度的数组。这个数组不仅让我们更容易用好 CPU Cache，对 CPU 执行过程中的分支预测也非常有利。更准确的分支预测，可以使得我们更好地利用好 CPU 的流水线，让代码跑得更快。</p><h1 id="资料三（Disruptor无锁框架为啥这么快）"><a href="#资料三（Disruptor无锁框架为啥这么快）" class="headerlink" title="资料三（Disruptor无锁框架为啥这么快）"></a>资料三（Disruptor无锁框架为啥这么快）</h1><p><strong>1.1 CPU缓存</strong></p><p>在现代计算机当中，CPU是大脑，最终都是由它来执行所有的运算。而内存(RAM)则是血液，存放着运行的数据；但是，由于CPU和内存之间的工作频率不同，CPU如果直接去访问内存的话，系统性能将会受到很大的影响，所以在CPU和内存之间加入了三级缓存，分别是L1、L2、L3。</p><p>当CPU执行运算时，它首先会去L1缓存中查找数据，找到则返回；如果L1中不存在，则去L2中查找，找到即返回；如果L2中不存在，则去L3中查找，查到即返回。如果三级缓存中都不存在，最终会去内存中查找。对于CPU来说，走得越远，就越消耗时间，拖累性能。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721576044.webp" class=""><p>在三级缓存中，越靠近CPU的缓存，速度越快，容量也越小，所以L1缓存是最快的，当然制作的成本也是最高的，其次是L2、L3。</p><p>CPU频率，就是CPU运算时的工作的频率（1秒内发生的同步脉冲数）的简称，单位是Hz。主频由过去MHZ发展到了当前的GHZ（1GHZ=10^3MHZ=10^6KHZ= 10^9HZ）。</p><p>内存频率和CPU频率一样，习惯上被用来表示内存的速度，内存频率是以MHz（兆赫）为单位来计量的。目前较为主流的内存频率1066MHz、1333MHz、1600MHz的DDR3内存，2133MHz、2400MHz、2666MHz、2800MHz、3000MHz、3200MHz的DDR4内存。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721594437.webp" class=""><p>可以看得出，如果CPU直接访问内存，是一件相当耗时的操作。</p><p><strong>1.2 缓存行</strong></p><p>当数据被加载到三级缓存中，它是以缓存行的形式存在的，不是一个单独的项，也不是单独的指针。</p><p>在CPU缓存中，数据是以缓存行(cache line)为单位进行存储的，每个缓存行的大小一般为32—256个字节，常用CPU中缓存行的大小是64字节；CPU每次从内存中读取数据的时候，会将相邻的数据也一并读取到缓存中，填充整个缓存行；</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721623615.webp" class=""><p>可想而知，当我们遍历数组的时候，CPU遍历第一个元素时，与之相邻的元素也会被加载到了缓存中，对于后续的遍历来说，CPU在缓存中找到了对应的数据，不需要再去内存中查找，效率得到了巨大的提升；</p><p>但是，在多线程环境中，也会出现伪共享的情况，造成程序性能的降低，堪称无形的性能杀手。</p><p><strong>1.2.1 缓存命中</strong></p><p>通过具体的例子，来阐述缓存命中和未命中之间的效率：</p><p>测试代码：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheHit</span> </span>&#123;<br><br>    <span class="hljs-comment">//二维数组：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span>[][] longs;<br><br>    <span class="hljs-comment">//一维数组长度：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> length = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建二维数组,并赋值：</span><br>        longs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[length][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span> ;x &lt; length;x++)&#123;<br>            longs[x] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">6</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span> ;y&lt;<span class="hljs-number">6</span>;y++)&#123;<br>                longs[x][y] = <span class="hljs-number">1L</span>;<br>            &#125;<br>        &#125;<br>        cacheHit();<br>         cacheMiss();<br>    &#125;<br>    <span class="hljs-comment">//缓存命中：</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheHit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>; x &lt; length; x++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;<span class="hljs-number">6</span>;y++)&#123;<br>                sum += longs[x][y];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">"命中耗时："</span>+(System.nanoTime() - start));<br>    &#125;<br>    <span class="hljs-comment">//缓存未命中：</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheMiss</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x &lt; <span class="hljs-number">6</span>;x++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y &lt; length;y++)&#123;<br>                sum += longs[y][x];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">"未命中耗时："</span>+(System.nanoTime() - start));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">未命中耗时：<span class="hljs-number">43684518</span><br>命中耗时：<span class="hljs-number">19244507</span><br></code></pre></td></tr></table></figure><p>在Java中，一个long类型是8字节，而一个缓存行是64字节，因此一个缓存行可以存放8个long类型。但是，在内存中的布局中，对象不仅包含了实例数据(long类型变量)，还包含了对象头。对象头在32位系统上占用8字节，而64位系统上占用16字节。</p><p>所以，在上面的例子中，笔者向二维数组中填充了6个元素，占用了48字节。</p><p>在cacheHit()的例子中，当第一次遍历的时候，获取longs[0][0]，而longs[0][0]—longs[0][5]也同时被加载到了缓存行中，接下来获取longs[0][1]，已存在缓存行中，直接从缓存中获取数据，不用再去内存中查找，以此类推；</p><p>在cacheMiss()的例子中，当第一次遍历的时候，也是获取longs[0][0]的数据，longs[0][0]—longs[0][5]也被加载到了缓存行中，接下来获取long[1][0]，不存在缓存行中，去内存中查找，以此类推；</p><p>以上的例子可以充分说明缓存在命中和未命中的情况下，性能之间的差距。</p><p><strong>1.2.2 伪共享</strong></p><p>由于CPU加载机制，某个数据被加载的同时，其相邻的数据也会被加载到CPU当中。在得到CPU免费加载的同时，也产生了不好的情况；俗话说得好，凡事都有利有弊。</p><p>在我们的java程序中，当多个线程修改两个独立变量的时候，如果这两个变量存在于一个缓存行中，那么就有很大的概率产生伪共享。</p><p>这是为什么呢？</p><p>现如今，CPU都是多核处理器，一般为2核或者4核，当我们程序运行时，启动了多个线程。例如：核心1启动了1个线程，核心2启动了1个线程，这2个线程分别要修改不同的变量，其中核心1的线程要修改x变量，而核心2的线程要修改y变量，但是x、y变量在内存中是相邻的数据，他们被加载到了同一个缓存行当中，核心1的缓存行有x、y，核心2的缓存行也有x、y。</p><p>那么，只要有一个核心中的线程修改了变量，另一个核心的缓存行就会失效，导致数据需要被重新到内存中读取，无意中影响了系统的性能，这就是伪共享。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721831140.webp" class=""><p>cpu的伪共享问题本质是：几个在内存中相邻的数据，被CPU的不同核心加载在同一个缓存行当中，数据被修改后，由于数据存在同一个缓存行当中，进而导致缓存行失效，引起缓存命中降低。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721844773.webp" class=""><p>代码例子：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FalseShare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-comment">//线程数、数组大小：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_THREADS = <span class="hljs-number">4</span>; <span class="hljs-comment">// change</span><br><br>    <span class="hljs-comment">//数组迭代的次数：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> ITERATIONS = <span class="hljs-number">500L</span> * <span class="hljs-number">1000L</span> * <span class="hljs-number">1000L</span>;<br><br>    <span class="hljs-comment">//线程需要处理的数组元素角标：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> handleArrayIndex;<br><br>    <span class="hljs-comment">//操作数组：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> VolatileLong[] longs = <span class="hljs-keyword">new</span> VolatileLong[NUM_THREADS];<br><br>    <span class="hljs-comment">//对数组的元素进行赋值：</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; longs.length; i++) &#123;<br>            longs[i] = <span class="hljs-keyword">new</span> VolatileLong();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FalseShare</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> handleArrayIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.handleArrayIndex = handleArrayIndex;<br>    &#125;<br><br>    <span class="hljs-comment">//启动线程，每一个线程操作一个数组的元素，一一对应：</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//程序睡眠必须加上：</span><br>        Thread.sleep(<span class="hljs-number">10000</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = System.nanoTime();<br><br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[NUM_THREADS];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> FalseShare(i));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : threads) &#123;<br>            t.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : threads) &#123;<br>            t.join();<br>        &#125;<br>        System.out.println(System.nanoTime() - start);<br>    &#125;<br><br>    <span class="hljs-comment">//对数组的元素进行操作：</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> i = ITERATIONS;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> != --i) &#123;<br>            longs[handleArrayIndex].value = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//数组元素：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileLong</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5; <span class="hljs-comment">//代码1</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p6;<span class="hljs-comment">//代码1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：（纳秒）</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">未注释代码<span class="hljs-number">1</span>：<span class="hljs-number">19830512</span>      <span class="hljs-number">18472356</span>     <span class="hljs-number">19993249</span>    <span class="hljs-number">19841462</span><br>注释代码<span class="hljs-number">1</span>：  <span class="hljs-number">21141471</span>      <span class="hljs-number">25611265</span>     <span class="hljs-number">19939633</span>    <span class="hljs-number">29976847</span><br></code></pre></td></tr></table></figure><p>通过测试结果，可以看出，在注释掉代码后，性能明显下降。让我们来阐述下原因：</p><p>通过代码，我们可以看出来，程序模拟的情况就是每一个线程操作数组中的一个元素，例如：线程1操作longs[0]，线程2操作longs[1]，线程3操作longs[2]…以此类推；之前说过，CPU缓存中是以缓存行为单位来进行存储的，一个缓存行大小为64字节。在程序中VolatileLong对象，正好满足64字节，为什么这么说？</p><p>在Java程序中，对象在内存中的分布：对象头（Header），实例数据（Instance Data），对齐填充（Padding）；</p><p>其中，对象头在32位系统上占用8字节，64位系统上占用16字节；实例数据也就是我们平常是所用到的基本类型和引用类型；对齐填充是对象在内存区域内的补充，jvm要求对象在内存区域的大小必须是8的整数倍，所以当对象头+实例数据的和不是8的整数倍时，就需要用到对齐填充，少多少就填充多少无效数据；</p><p>综上所述，VolatileLong=对象头(12字节)+value(8字节)+p1-p5(40字节)+p6(4字节) = 64字节，正好填充满整个缓存行；</p><p>当我们没有注释掉代码的时候，数组的各个元素将分布在不同的缓存行当中；而当注释掉代码的时候，数组的元素有很大的几率分布在同一个缓存行当中；当不同线程操作元素的时候，就会产生冲突，产生伪共享，影响系统性能；</p><p>经过上面的叙述，你大概对伪共享有了一定的了解，但是你会不会有这样的疑问？为什么其中1个核心缓存行的数据被修改了，其余核心中的缓存行就失效了？是什么机制产生了这样的情况？</p><p>以下，我们就来简单的介绍CPU的一致性协议MESI，就是这个协议保证了Cache的一致性；</p><p><strong>1.2.3 MESI协议</strong></p><p>多核理器中，每个核心都有自己的cache，内存中的数据可以同时处于不同的cache中，若各个核心独立修改自己的cache，就会出现不一致问题。为了解决一致性问题，MESI协议被引入。</p><p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的支持写回策略的缓存一致性协议，该协议最早被应用在Intel奔腾系列的CPU中。</p><p>其实，MESI协议就是规定了缓存行的4种状态，以及这4种状态之间的流转，以来保证不同核心中缓存的一致；每种状态在缓存行中用2个bit位来进行描述，分别是修改态（M）、独享态（E）、共享态（S）、无效态（I）；</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721907495.webp" class=""><ul><li>E(Exclusive)：x变量只存在于core1中；</li></ul><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721931430.webp" class=""><ul><li>S(Shared):x变量存在于core1 core2 core3中</li></ul><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721944728.webp" class=""><ul><li>M(Modified)：core1修改了x变量，core2 core3的缓存行被置为无效状态</li></ul><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721956301.webp" class=""><p>在CPU中，每个核心不但控制着自己缓存行的读写操作，而且还监听这其他核心中缓存行的读写操作；每个缓存行的状态受到本核心和其他核心的双重影响；</p><p>下面，我们就阐述下这4中状态的流转：</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721967959.webp" class=""><figure class="hljs highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sas">(1)I--本地读请求：CPU读取变量<span class="hljs-meta">x</span>，如果其他核中的缓存有变量<span class="hljs-meta">x</span>，且缓存行的状态为M，则将该核心的变量<span class="hljs-meta">x</span>更新到内存，本核心的再从内存中读取取数据，加载到缓存行中，两个核心的缓存行状态都变成S；如果其他核心的缓存行状态为S或者E，本核心从内存中杜取数据，之后所有核心中的包含变量<span class="hljs-meta">x</span>的缓存行状态都变成S。<br><br>(2)I--本地读请求：CPU读取变量<span class="hljs-meta">x</span>，如果其他核中的缓存没有变量<span class="hljs-meta">x</span>，则本核心从内存中读取变量<span class="hljs-meta">x</span>，存入本核心的缓存行当中，该缓存行状态变成E；<br><br>(3)I--本地写请求：CPU读取写入变量<span class="hljs-meta">x</span>，如果其他核中没有此变量，则从内存中读取，在本核心中修改，此缓存行状态变为M；如果其他缓存行中有变量<span class="hljs-meta">x</span>，并且状态为M,则需要先将其他核心中的变量<span class="hljs-meta">x</span>写回内存，本核心再从内存中读取；如果其他缓存行中有变量<span class="hljs-meta">x</span>，并且状态为E/S，则将其他核心中的缓存行状态置为I，本核心在从内存中读取变量<span class="hljs-meta">x</span>，之后将本核心的缓存行置为M；<br><br>注意，一个缓存除在Invalid状态外都可以满足CPU的读请求，一个invalid的缓存行必须从主存中读取（变成S或者 E状态）来满足该CPU的读请求。<br><br>(4)S--远程写请求：多个核心共享变量<span class="hljs-meta">X</span>，其他核心将变量<span class="hljs-meta">x</span>修改，本核心中的缓存行不能使用，状态变为I；<br><br>(5)S--本地读请求：多个核心共享变量<span class="hljs-meta">X</span>，本核心读取本缓存中的变量<span class="hljs-meta">x</span>，状态不变；<br><br>(6)S--远程读请求：多个核心共享变量<span class="hljs-meta">X</span>，其他核心要读取变量<span class="hljs-meta">X</span>，从主内存中读取变量<span class="hljs-meta">x</span>，状态置为S，本核心状态S不变；<br><br>(7)S--本地写请求：多个核心共享变量<span class="hljs-meta">X</span>，本核心修改本缓存行中的变量<span class="hljs-meta">x</span>，必须先将其他核心中所拥有变量<span class="hljs-meta">x</span>的缓存行状态变成I，本核心缓存行状态置为M；该操作通常使用RequestFor Ownership (RFO)广播的方式来完成；<br><br>(8)E--远程读请求：只有本核心拥有变量<span class="hljs-meta">x</span>，其他核心也要读取变量<span class="hljs-meta">x</span>,从内存中读取变量<span class="hljs-meta">x</span>，并将所有拥有变量<span class="hljs-meta">x</span>的缓存行置为S状态；<br><br>(9)E--本地读请求：只有本核心拥有变量<span class="hljs-meta">x</span>，本核心需要读取变量<span class="hljs-meta">x</span>，读取本地缓存行中的变量<span class="hljs-meta">x</span>即可，状态不变依旧为E；<br><br>(10)E--远程写请求：只有本核心拥有变量<span class="hljs-meta">x</span>，其他核心需要修改变量<span class="hljs-meta">x</span>，其他核心从内存中读取变量<span class="hljs-meta">x</span>，进行修改，状态变成M，而本核心中缓存行变为状态I；<br><br>(11)E--本地写请求：只有本核心拥有变量<span class="hljs-meta">x</span>，本核心修改本缓存行中的变量<span class="hljs-meta">x</span>，状态置为M；<br><br>(12)M--本地写请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，本核心进行修改<span class="hljs-meta">x</span>操作，缓存行状态不变；<br><br>(13)M--本地读请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，本核心进行读取<span class="hljs-meta">x</span>操作，缓存行状态不变；<br><br>(14)M--远程读请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，其他核心需要读取变量<span class="hljs-meta">x</span>,先将本核心中的变量<span class="hljs-meta">x</span>写回到内存中，在将本缓存行状态置为S，其他核心拥有变量<span class="hljs-meta">x</span>的缓存行状态也变为S；<br><br>(15)M--远程写请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，其他和核心需要修改变量<span class="hljs-meta">x</span>，先将本核心中的变量<span class="hljs-meta">x</span>写回内存，再将本核心中缓存行置为I。其他核心的在从缓存行中读取变量<span class="hljs-meta">x</span>，修改后置为M；<br></code></pre></td></tr></table></figure><p>以上就是MESI协议的状态流转；如果对状态流转还有疑问的话，还可以结合以下图例进行学习：</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722004805.webp" class=""><p><strong>1.3 CAS</strong></p><p>那么，CAS是什么呢？</p><p>在Java中，多线程之间如何保证数据的一致性？想必大部分都会异口同声地说出锁—-synchronized锁。在JDK1.5之前，的确是使用synchronized锁来保证数据的一致性。但是，synchronized锁是一种比较重的锁，俗称悲观锁。在较多线程的竞争下，加锁、释放锁会对系统性能产生很大的影响，而且一个线程持有锁，会导致其他线程的挂起，直至锁的释放。</p><p>那么，有没有比较轻的锁呢，答案是有的！与之相对应的是乐观锁！乐观锁虽然名称中带有锁，但实际在代码中是不加锁的，乐观锁大多实现体现在数据库sql层面，通常是的做法是：为数据增加一个版本标识，在表中增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> XXX_TABLE <span class="hljs-keyword">SET</span> MONEY = <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">VERSION</span> = <span class="hljs-number">11</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ID</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">VERSION</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这就是乐观锁！</p><p>上面说到了数据库层面的乐观锁，那么代码层面有没有类似的实现？答案是，有的！那就是我们本小节的主角—CAS；</p><p>CAS是一个CPU级别的指令，翻译为Compare And Swap比较并交换；</p><p>CAS是对内存中共享数据操作的一种指令，该指令就是用乐观锁实现的方式，对共享数据做原子的读写操作。原子本意是“不能被进一步分割的最小粒子”，而原子操作意为”不可被中断的一个或一系列操作”。原子变量能够保证原子性的操作，意思是某个任务在执行过程中，要么全部成功，要么全部失败回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。</p><p>CAS有3个操作数，内存中的值V，预期内存中的值A，要修改成的值B。当内存值V和预期值相同时，就将内存值V修改为B，否则什么都不做。</p><p>例如：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CasTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> memoryValue = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expectValue;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> updateValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CasTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expectValue,<span class="hljs-keyword">int</span> updateValue)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.expectValue = expectValue;<br>        <span class="hljs-keyword">this</span>.updateValue = updateValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(memoryValue==expectValue)&#123;<br>            <span class="hljs-keyword">this</span>.memoryValue = updateValue;<br>            System.out.println(<span class="hljs-string">"修改成功"</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">"修改失败"</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] agrs)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CasTest casTest1 = <span class="hljs-keyword">new</span> CasTest(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(casTest1);<br>        t1.start();<br><br>        Thread t2= <span class="hljs-keyword">new</span> Thread(casTest1);<br>        t2.start();<br><br>        t1.join();<br>        t2.join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java中，主要使用了Unsafe类来实现CAS操作，利用JNI来完成CPU指令的调用。JNI：java native interface为java本地调用，也就是说允许java调用其他计算机语言（例如：C、C++等）；</p><p>在java.util.concurrent.atomic包下(AtomicInteger为例)：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6214790243416807050L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, valueOffset, expect, update);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际最终调用了sun.misc.Unsafe类：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4, <span class="hljs-keyword">int</span> var5)</span></span>;<br></code></pre></td></tr></table></figure><p>可以看到Unsafe的compareAndSwapInt方法，使用了native修饰符，是一个本地方法调用，最终由C++代码来操作CPU。至于具体实现，有兴趣的朋友可以去参考openJDK中Unsafe类；</p><p>与synchronized锁相比较而言，CAS最大的优势就是非阻塞，在代码层面，多线程情况下不阻塞其他线程的执行，从而达到既保证数据的安全，又提高了系统的性能。</p><p><strong>1.4 Disruptor中的运用</strong></p><p>上面，说了分别说了CAS、缓存行、伪共享。接下来，就来看看再Disruptor中是如何使用的！</p><p>在多生产者的环境下，更新下一个可用的序列号地方，我们使用CAS（Compare And Swap）操作。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722127388.webp" class=""><p>Disruptor中多生产者情况下，获取下一个可用序列号的实现:</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiProducerSequencer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequencer</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>        &#125;<br>        <span class="hljs-keyword">long</span> current;<br>        <span class="hljs-keyword">long</span> next;<br>        <span class="hljs-keyword">do</span>&#123;<br>            current = cursor.get();<br>            next = current + n;<br>            <span class="hljs-keyword">long</span> wrapPoint = next - bufferSize;<br>            <span class="hljs-keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();<br>            <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current)&#123;<br>                <span class="hljs-keyword">long</span> gatingSequence = Util.getMinimumSequence(gatingSequences, current);<br><br>                <span class="hljs-keyword">if</span> (wrapPoint &gt; gatingSequence)&#123;<br>                    waitStrategy.signalAllWhenBlocking();<br>                    LockSupport.parkNanos(<span class="hljs-number">1</span>); <span class="hljs-comment">// TODO, should we spin based on the wait strategy?</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                gatingSequenceCache.set(gatingSequence);<br><br>            <span class="hljs-comment">//对current,next进行compareAndSet，cursor就是序列号对象：</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cursor.compareAndSet(current, next))&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Disruptor通过缓存行填充的方式来解决伪共享：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LhsPadding</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5, p6, p7;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LhsPadding</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RhsPadding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Value</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> p9, p10, p11, p12, p13, p14, p15;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RhsPadding</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>Sequence是Disruptor中序列号对象，value是对象具体的序列值，通过上面的方式，value不会与其他需要操作的变量存在同一个缓存行中。</p><h1 id="资料四（Disruptor之概览）"><a href="#资料四（Disruptor之概览）" class="headerlink" title="资料四（Disruptor之概览）"></a>资料四（Disruptor之概览）</h1><p><strong>概述</strong></p><p>“多核危机”驱动了并发编程的复兴，然后并发编程和一般的系统相比，复杂性有个很大梯度的上升。多线程开发很大困难在于：多个线程间存在依赖关系时，如何进行协调。依赖一方面是执行顺序的依赖，如某个线程执行需要依赖其他线程执行或其它线程的某些阶段执行结果，Java为我们提供的解决方案是：wait/notify、lock/condition、join、yield、Semaphore、CountDownLatch、CyclicBarrier以及JDK7新增的一个Phaser等；数据依赖主要是多个线程对同一资源并发修改导致的数据状态不一致问题，Java中主要依靠Lock和CAS两种方案，也就是我们熟知的悲观锁、乐观锁。</p><p>然而，当你在并发编程方面慢慢有些经验并开始在项目中使用时，你会发现仅仅依赖JDK提供的上面所说开发工具类是远远不够的， JDK提供的工具类都只能解决一个个功能“点”的问题。并发编程复杂性一个体现就是：多个顺序执行流在多核CPU中同时并行执行与我们已经习惯的单个数据顺序流执行的方式产生了很大的冲突。</p><p>好比：现在你开车从A地到B地去，传统的开发模式就像从A地到B地之间只存在一条公路，你只需要延着这个公路一直开下去就可以达到B地；假如经过多年发展，现在A地到B地横起有10条公路，纵起有10条公路，它们之间相互交叉形成错综复杂的公路网，你再开车从A地到B地就会存在太多的选择，可能从东南西北任何方向出发最终都能到达B地。这就体现了并发编程和传统编程复杂性的对比：传统编程由于只存在一个顺序执行流，可以很好的预判程序的执行流程；而并发编程存在太多的顺序执行流导致很难准确的预判出它们真正的执行流程，一旦出现问题也很难排查，就好比上面的例子第二种情况，你很难预判你开车的真正路线，而且可能存在每次路线都不一样情况。</p><p>我认为一个并发编程项目好坏其中一个关键核心就是：项目的整体结构是否清晰。很简单的一个例子，调用notify()方法唤醒挂起在指定对象上的休眠线程，如果没有一个清晰简单的架构设计，可能会导致在该对象上进行休眠的对象散落到系统中各处代码上，很难把控具体唤醒的是哪个线程从而与你的业务逻辑发生偏差导致bug的出现。当然，项目结构清晰在传统编程中也是非常看重的，只有结构清晰的架构才会让人易于理解，同时和他人沟通探讨时方便描述，但是在并发编程中这点尤为重要，因为并发编程的复杂性更高，没有一个清晰的结构设计，你可能经过大量测试修改暂时做出了一个看似没有bug的项目，但是后期需求变更或者是其他人来维护这个项目时，很难下手导致后期会引入大量的bug，而且不利于项目功能的扩展。</p><p>常用的并发编程使用的模型有并行模型、流水线模型、生产者/消费者模型、Actor模型等，采用模型设计一方面是因为这些模型都是大牛们经过长时间实际生产经验的积累总结出的并发编程方面一些好的解决方案；另一方面，采用模型设计可以解决相关人员之间沟通信息不对等问题，降低沟通学习成本。</p><p>并行模型是JDK8中Stream所采用的实现并发编程的方式，并行模型非常简单，就是为每个任务分配一个线程直到该任务执行结束，示意图如下：</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722373615.webp" class=""><p>并行模型太过简单导致对任务的精细化控制不足，一个任务可能会被分解为多个阶段，而每个阶段的子任务特性可能差别很大，这时并行模型就无能为力了。并行模型只适合于CPU密集型且任务中不含IO阻塞等情况的任务。这时，就演进出流水线模型，示意图如下：</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722417189.webp" class=""><p>流水线模型在实际的并发编程中使用比较常见，我们所说的Pipeline设计模型、Netty框架等都是这一思想的体现。</p><p>生产者/消费者模型在并发编程中也是使用频度非常高的一个模型，生产者/消费者模型可以很容易地将生产和消费进行解耦，优化系统整体结构，并且由于存在缓冲区，可以缓解两端性能不匹配的问题。</p><p>Actor模型其典型代表就是Akka，基于Akka可以轻松实现一个分布式异步数据处理集群系统，非常强大，后期我们有机会可以再深入讨论下Akka。</p><p>好了，说了这么多，终于要开始正题：Disruptor，官方宣传基于该框架构建的系统单线程可以支撑每秒处理600万订单，此框架真乃惊为天人。Disruptor在生产者/消费者模型上获得尽量高的吞吐量和尽量低的延迟，其目标就是在性能优化方面做到极致。国内国外都存在大量的知名项目在广泛使用，比如我们所熟知的strom底层就依赖Disruptor的实现，其在并发、缓存区、生产者/消费者模型、事务处理等方面都存在一些性能优秀的方案，因此是非常值得深入研究的。</p><p><strong>生产者/消费者模型</strong></p><p>生产者/消费者模型在编程中使用频度非常高的一个模型，生产者/消费者模型可以很容易地将生产和消费进行解耦，优化系统整体结构，并且由于存在缓冲区，可以缓解两端性能不匹配的问题。生产者/消费者和我们所熟悉的设计模式中的观察者模型很相似，生产者类似于被观察者，消费者类似于观察者，被观察者的任何变动都以事件的方式通知到观察者；同理，生产者生产的数据都要传递给消费者最终都要被消费者处理。</p><p>一般项目开发中，我们可以使用JDK提供的阻塞队列BlockingQueue很简单的实现一个生产者/消费者模型，其中生产者线程负责提交需求，消费者线程负责处理任务，二者之间通过共享内存缓冲区进行通信。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722441766.webp" class=""><p>BlockingQueue实现类主要有两个：ArrayBlockingQueue和LinkedBlockingQueue，底层实现一个是基于数组的，一个是基于链表的，这种实现方式的差异导致了它们使用场景的不一样。在生产者/消费者模型中的缓存设计上肯定优先使用ArrayBlockingQueue，但是查看ArrayBlockingQueue底层源码会发现，读写操作通过重入锁实现同步，而且读写操作使用的是同一把锁，并没有实现读写锁分离；另外，锁本身的成本还是比较高的，锁容易导致线程上下文频繁的发生切换，了解CPU核存储硬件架构的可能会知道，每核CPU都会存在一个独享的高速缓存L1，假如线程切换到其它CPU上执行会导致之前CPU高速缓存L1中的数据不能再被使用，降低了高速缓存使用效率。因此，在高并发场景下，性能不是很优越。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//向Queue中写入数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       checkNotNull(e);<br>       <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>       lock.lockInterruptibly();<span class="hljs-comment">//可中断方式获取锁，实现同步</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == items.length)<br>               notFull.await();<br>           insert(e);<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>&#125;<br><br><span class="hljs-comment">//从Queue中取出数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>       lock.lockInterruptibly();<span class="hljs-comment">//可中断方式获取锁，实现同步</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>               notEmpty.await();<br>           <span class="hljs-keyword">return</span> dequeue();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Disruptor消息生产模型</strong></p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722855401.webp" class=""><p>Producer生产出一个消息事件Event，需要放入到RingBuffer中，流程大致如下：</p><p>1、首先调用Sequencer.next()方法，获取RingBuffer上可用的序号用于将新生成的消息事件放入；</p><p>2、Sequencer首先对nextValue+1代表当前需要申请的RingBuffer序号(nextValue标记了之前已经申请过的序号,nextValue+1就是下一个可申请的序号)，但是nextValue+1指向的RingBuffer槽位存放的消息可能并没有被消费，如果直接返回这个序号给生产者，就会导致生产一方将该槽位的消息事件重新填充覆盖导致之前数据丢失，这里就需要一个判断：判断申请的RingBuffer序号代表的槽位之前的消息事件是否已被消费，判断逻辑如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//n表示此次生产者期望获取多少个序号，通常是1</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>    &#125;<br>    <span class="hljs-keyword">long</span> nextValue = <span class="hljs-keyword">this</span>.nextValue;<br>    <span class="hljs-comment">//这里n一般是1，代表申请1个可用槽位，nextValue+n就代表了期望申请的可用槽位序号</span><br>    <span class="hljs-keyword">long</span> nextSequence = nextValue + n;<br>    <span class="hljs-comment">//减掉RingBuffer的bufferSize值，用于判断是否出现‘绕圈覆盖’</span><br>    <span class="hljs-keyword">long</span> wrapPoint = nextSequence - bufferSize;<br>    <span class="hljs-comment">//cachedValue缓存之前获取的最慢消费者消费到的槽位序号</span><br>    <span class="hljs-keyword">long</span> cachedGatingSequence = <span class="hljs-keyword">this</span>.cachedValue;<br>    <span class="hljs-comment">//如果申请槽位序号-bufferSize比最慢消费者序号还大，代表生产者绕了一圈后又追赶上了消费者，这时候就不能继续生产了，否则把消费者还没消费的消息事件覆盖</span><br>    <span class="hljs-keyword">if</span>(wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123;<br>        <span class="hljs-comment">/**<br>         cursor代表当前已经生产完成的序号，了解多线程可见性可能会知道：<br>         1、CPU和内存间速度不匹配，硬件架构上一般会在内存和CPU间还会存在L1、L2、L3三级缓存<br>         2、特别是L1高速缓存是CPU间相互独立不能共享的，线程操作可以看着基于L1缓存进行操作，就会导致线程间修改不会立即被其它线程感知，只有L1缓存的修改写入到主存然后其它线程将主存修改刷新到自己的L1缓存，这时线程1的修改才会被其它线程感知到<br>         3、线程修改对其它线程不能立即可见特别是在高并发下可能会带来些问题，JAVA中使用volatile可以解决可见性问题<br>         4、这里就是采用UNSAFE.putLongVolatile()插入一个StoreLoad内存屏障，具体可见JMM模型，主要保证cursor的真实值对所有的消费线程可见，避免不可见下消费线程无法消费问题<br>         */</span><br>        cursor.setVolatile(nextValue);<br>        <span class="hljs-keyword">long</span> minSequence;<br>        <span class="hljs-comment">//Util.getMinimumSequence(gatingSequences, nextValue)获取当前时刻所有消费线程中，消费最慢的序号</span><br>        <span class="hljs-comment">//上面说过cachedValue是缓存的消费者最慢的序号</span><br>        <span class="hljs-comment">//这样做目的：每次都去获取真实的最慢消费线程序号比较浪费资源，而是获取一批可用序号后，生产者只有使用完后，才继续获取当前最慢消费线程最小序号，重新获取最新资源</span><br>        <span class="hljs-keyword">while</span>(wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue))) &#123;<br>            <span class="hljs-comment">//如果获取最新最慢消费线程最小序号后，依然没有可用资源，做两件事：</span><br>            <span class="hljs-comment">//    1、唤醒waitStrategy上所有休眠线程，这里即是消费线程(避免因消费线程休眠而无法消费消息事件导致生产线程一直获取不到资源情况)</span><br>            <span class="hljs-comment">//    2、自旋休眠1纳秒</span><br>            <span class="hljs-comment">//可以看到，next()方法是一个阻塞接口，如果一直获取不到可用资源，就会一直阻塞在这里</span><br>            waitStrategy.signalAllWhenBlocking();<br>            LockSupport.parkNanos(<span class="hljs-number">1</span> L);<br>        &#125;<br>        <span class="hljs-comment">//有可用资源时，将当前最慢消费线程序号缓存到cachedValue中，下次再申请时就可不必再进入if块中获取真实的最慢消费线程序号，只有这次获取到的被生产者使用完才会继续进入if块</span><br>        <span class="hljs-keyword">this</span>.cachedValue = minSequence;<br>    &#125;<br>    <span class="hljs-comment">//申请成功，将nextValue重新设置，下次再申请时继续在该值基础上申请</span><br>    <span class="hljs-keyword">this</span>.nextValue = nextSequence;<br>    <span class="hljs-comment">//返回申请到RingBuffer序号</span><br>    <span class="hljs-keyword">return</span> nextSequence;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、申请到可用序号后，提取RingBuffer中该序号中的Event，并重置Event状态为当前最新事件状态</p><p>4、重置完成后，调用Sequencer.publish()提交序号，提交序号主要就是修改cursor值，cursor标记已经生产完成序号，这样消费线程就可以来消费事件了</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-comment">//修改cursor序号，消费者就可以进行消费</span><br>    cursor.set(sequence);<br>    <span class="hljs-comment">//唤醒消费线程，比如消费线程消息到无可用消息时可能会进入休眠状态，当放入新消息就需要唤醒休眠的消费线程</span><br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：消息事件生产主要包含三个步骤：</p><p>1、申请序号：表示从RingBuffer上获取可用的资源</p><p>2、填充事件：表示获取到RingBuffer上可用资源后，将新事件放入到该资源对应的槽位上</p><p>3、提交序号：表示第二部新事件放入到RingBuffer槽位全部完成，提交序号可供消费线程开始消费</p><p><strong>Disruptor消息处理模型</strong></p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576723548323.webp" class=""><p>消息处理端需要从RingBuffer中提取可用的消息事件，并注入到用户的业务逻辑中进行处理，流程大致如下：</p><p>1、消费端核心类是EventProcessor，它实现了Runnable接口，Disruptor在启动的时候会将所有注册上来的EventProcessor提交到线程池中执行，因此，一个EventProcessor可以看着一个独立的线程流用于处理RingBuffer上的数据</p><p>2、EventProcessor通过调用SequenceBarrier.waitFor()方法获取可用消息事件的序号，其实SequenceBarrier内部还是调用WaitStrategy.waitFor()方法，WaitStrategy等待策略主要封装如果获取消息时没有可用消息时如何处理的逻辑信息，是自旋、休眠、直接返回等，不同场景需要使用不同策略才能实现最佳的性能</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* ProcessingSequenceBarrier中核心方法只有一个：waitFor(long sequence)，传入希望消费得到起始序号，返回值代表可用于消费处理的序号，一般返回可用序号&gt;=sequence，但也不一定，具体看WaitStrategy实现<br>* 总结：<br>*      1、sequence：EventProcessor传入的需要进行消费的起始sequence<br>*      2、这里并不保证返回值availableSequence一定等于given sequence，他们的大小关系取决于采用的WaitStrategy<br>*          a.YieldingWaitStrategy在自旋100次尝试后，会直接返回dependentSequence的最小seq，这时并不保证返回值&gt;=given sequence<br>*          b.BlockingWaitStrategy则会阻塞等待given sequence可用为止，可用并不是说availableSequence == given sequence，而应当是指 &gt;=<br>*          c.SleepingWaitStrategy:首选会自旋100次，然后执行100次Thread.yield()，还是不行则LockSupport.parkNanos(1L)直到availableSequence &gt;= given sequence<br>*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span><br><span class="hljs-keyword">throws</span> AlertException, InterruptedException, TimeoutException </span>&#123;<br>    checkAlert();<br>    <span class="hljs-comment">//调用WaitStrategy获取RingBuffer上可用消息序号，无可消费消息是该接口可能会阻塞，具体逻辑由WaitStrategy实现</span><br>    <span class="hljs-keyword">long</span> availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span>(availableSequence &lt; sequence) &#123;<br>        <span class="hljs-keyword">return</span> availableSequence;<br>    &#125;<br>    <span class="hljs-comment">//获取消费者可以消费的最大的可用序号，支持批处理效应，提升处理效率。</span><br>    <span class="hljs-comment">//当availableSequence &gt; sequence时，需要遍历 sequence --&gt; availableSequence，找到最前一个准备就绪，可以被消费的event对应的seq。</span><br>    <span class="hljs-comment">//最小值为：sequence-1</span><br>    <span class="hljs-keyword">return</span> sequencer.getHighestPublishedSequence(sequence, availableSequence);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、通过waitFor()返回的是一批可用消息的序号，比如申请消费7好槽位，waitFor()返回的可能是8表示从6到8这一批数据都已生产完毕可以进行消费</p><p>4、EventProcessor按照顺序从RingBuffer中取出消息事件，然后调用EventHandler.onEvent()触发用户的业务逻辑进行消息处理</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//读取可消费消息序号</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);<br>        <span class="hljs-keyword">if</span>(batchStartAware != <span class="hljs-keyword">null</span>) &#123;<br>            batchStartAware.onBatchStart(availableSequence - nextSequence + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(nextSequence &lt;= availableSequence) &#123;<br>            <span class="hljs-comment">//循环提取所有可供消费的消息事件</span><br>            event = dataProvider.get(nextSequence);<br>            <span class="hljs-comment">//将提取的消息事件注入到封装用户业务逻辑的Handler中</span><br>            eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);<br>            nextSequence++;<br>        &#125;<br>        sequence.set(availableSequence);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、当这批次的消息处理完成后，继续重复上面操作调用waitFor()继续获取可用的消息序号，周而复始</p><p>好了，这节主要对Disruptor的生产模型和消费模型进行了一个简单的介绍，后面会逐渐对Disruptor涉及到的每个核心组件进行分析，了解它们优秀的设计思想。</p><h1 id="资料五（Disruptor源码解析-实战）"><a href="#资料五（Disruptor源码解析-实战）" class="headerlink" title="资料五（Disruptor源码解析 + 实战）"></a>资料五（Disruptor源码解析 + 实战）</h1><p><strong>juc下的队列</strong></p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576725625080.webp" class=""><p>1：从上图可以看出，juc下的队列基本采用加锁方式保证线程安全。通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在限定的范围）。而加锁的方式可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。</p><p>2：加锁的方式通常严重影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。</p><p>3：有界队列通常采用数组实现。但是采用数组实现又会引发另外一个问题false sharing(伪共享)。关于什么是伪共享之前的文章已经讲解。</p><p><strong>Disruptor</strong></p><p><strong>Disruptor是什么</strong></p><p>1：Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）</p><p>2：Disruptor实现对了队列的功能并且是一个有界队列。可以用于生产者-消费者模型。</p><p><strong>Disruptor为什么快</strong></p><p>1：数据结构采用ringbuffer。其实可以理解成一个数组entries。每一个slot存储一个事件对象。初始化时，就已经分配好内存，而且新发布的数据只会覆盖，所以更少的GC。</p><p>2：Disruptor采用缓存行填充机制的形式解决了fasle sharing。保证读取变量的时候从cache line读取。</p><p>3：Disroptor中维护了一个long类型的sequence(序列)。每次根据位运算操作可以快速定位到实际slot，sequece&amp;(entries.length-1)=index，比如一共有4槽，9&amp;(8-1)=1。提示：队列的大小必须要2^n。</p><p>4：线程同时访问，由于他们都通过sequence访问ringBuffer，通过CAS取代了加锁，这也是并发编程的原则：把同步块最小化到一个变量上。这个sequence一直采用自增的形式。</p><p><strong>Disruptor核心类</strong></p><p>1：RingBuffer：Disruptor最主要的组件，仅仅负责存储和更新事件对象。</p><p>2：Sequence：Disruptor使用Sequence来表示一个特殊组件处理的序号。和Disruptor一样，每一个消费者（EventProcessor）都维持着一个Sequence。大部分的并发代码依赖这这个值。这个类维护了一个long类型的value，采用的unsafe进行的更新操作。</p><p>3：Sequencer：这是Disruptor真正的核心。实现了这个接口的两种生产者（单生产者和多生产者）均实现了所有的并发算法，为了在生产者和消费者之间进行准确快速的数据传递。</p><p>4：SequenceBarrier：由Sequencer生成，并且包含了已经发布的Sequence的引用，这些Sequence源于Sequencer和一些独立的消费者的Sequence。它包含了决定是否有供消费者消费的Event的逻辑。用来权衡当消费者无法从RingBuffer里面获取事件时的处理策略。（例如：当生产者太慢，消费者太快，会导致消费者获取不到新的事件会根据该策略进行处理，默认会堵塞）</p><p>5：WaitStrategy：决定一个消费者将如何等待生产者将Event置入Disruptor的策略。用来权衡当生产者无法将新的事件放进RingBuffer时的处理策略。（例如：当生产者太快，消费者太慢，会导致生产者获取不到新的事件槽来插入新事件，则会根据该策略进行处理，默认会堵塞）</p><p>6：Event：从生产者到消费者过程中所处理的数据单元。Disruptor中没有代码表示Event，因为它完全是由用户定义的。</p><p>7：EventProcessor：主要事件循环，处理Disruptor中的Event，并且拥有消费者的Sequence。它有一个实现类是BatchEventProcessor，包含了event loop有效的实现，并且将回调到一个EventHandler接口的实现对象。</p><p>8：EventHandler：由用户实现并且代表了Disruptor中的一个消费者的接口。</p><p>9：WorkHandler：在work模式下使用。由用户实现并且代表了Disruptor中的多个消费者的接口。</p><p>10：WorkProcessor：确保每个sequence只被一个processor消费，在同一个WorkPool中的处理多个WorkProcessor不会消费同样的sequence。</p><p>11：WorkerPool：一个WorkProcessor池，其中WorkProcessor将消费Sequence，所以任务可以在实现WorkHandler接口的worker之间移交</p><p>12：LifecycleAware：当BatchEventProcessor启动和停止时，实现这个接口用于接收通知。</p><p><strong>Sequence(序列)</strong></p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576725694032.webp" class=""><p>1：Sequence是用来标记事件发布者和事件消费者的位置。</p><p>2：Sequence真正计数的是value，采用缓冲行填充防止false sharing。在value的前后各有7个long型的填充值，这些值在这里的作用是做cpu cache line填充，防止发生伪共享。最坏的情况就是value位于cache line的头或者尾。</p><p><strong>框架类结构关系图</strong></p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576725713396.webp" class=""><p><strong>Cursored  获取当前序列值</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cursored</span></span>&#123;<br>    <span class="hljs-comment">/**<br>     * 获取当前序列值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getCursor</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1：Cursored接口只提供了一个获取当前序列值的方法。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sequenced</span></span>&#123;<br>    <span class="hljs-comment">//获取队列的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBufferSize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//判断队列中是否还有可用的容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAvailableCapacity</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> requiredCapacity)</span></span>;<br>    <span class="hljs-comment">//获取队列中剩余的有效容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">remainingCapacity</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//申请下一个sequence，用于事件发布者发布数据，申请失败则自旋</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//申请n个sequence，用于事件发布者发布数据，申请失败则自旋</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>    <span class="hljs-comment">//尝试获取一个sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">tryNext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InsufficientCapacityException</span>;<br>    <span class="hljs-comment">//尝试获取n个sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">tryNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> <span class="hljs-keyword">throws</span> InsufficientCapacityException</span>;<br>    <span class="hljs-comment">//发布sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>    <span class="hljs-comment">//批量发布sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lo, <span class="hljs-keyword">long</span> hi)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Sequencer</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sequencer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cursored</span>, <span class="hljs-title">Sequenced</span></span>&#123;<br>    <span class="hljs-comment">//游标初始值</span><br>    <span class="hljs-keyword">long</span> INITIAL_CURSOR_VALUE = -<span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">//初始化RingBuffer为指定的sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">claim</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>    <span class="hljs-comment">//消费者调用，判断sequence是否可以消费</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAvailable</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>    <span class="hljs-comment">//将sequence添加到gating sequences中</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addGatingSequences</span><span class="hljs-params">(Sequence... gatingSequences)</span></span>;<br>    <span class="hljs-comment">//从gating sequences中移除指定的sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeGatingSequence</span><span class="hljs-params">(Sequence sequence)</span></span>;<br>    <span class="hljs-comment">//事件处理者用来追踪ringBuffer中可以用的sequence</span><br>    <span class="hljs-function">SequenceBarrier <span class="hljs-title">newBarrier</span><span class="hljs-params">(Sequence... sequencesToTrack)</span></span>;<br>    <span class="hljs-comment">//事件发布者获取gating sequence中最小的sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getMinimumSequence</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//消费者用来获取从nextSequence到availableSequence之间最大的sequence。如果是多线程生产者判断nextSequence是否可用，否则返回nextSequence-1。单线程直接返回availableSequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getHighestPublishedSequence</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nextSequence, <span class="hljs-keyword">long</span> availableSequence)</span></span>;<br>    <span class="hljs-comment">//我也不知道干啥的</span><br>    &lt;T&gt; <span class="hljs-function">EventPoller&lt;T&gt; <span class="hljs-title">newPoller</span><span class="hljs-params">(DataProvider&lt;T&gt; provider,Sequence... gatingSequences)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1：Sequencer中的方法大多是给事件发布者使用。newBarrier()给事件处理者使用。</p><p><strong>AbstractSequencer 管理事件处理者序列和事件发布者发布序列。</strong></p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java">public abstract class AbstractSequencer implements Sequencer &#123;<br>    //用来对gatingSequences做原子操作的。Sequence[]里面存储的是事件处理者处理到的序列。<br>    //如果不懂AtomicReferenceFieldUpdater请www.google.com<br>    private static final AtomicReferenceFieldUpdater&lt;AbstractSequencer, Sequence[]&gt; SEQUENCE_UPDATER =<br>        AtomicReferenceFieldUpdater.newUpdater(AbstractSequencer.class, Sequence[].class, "gatingSequences");<br>    //队列大小<br>    protected final int bufferSize;<br>    //等待策略<br>    protected final WaitStrategy waitStrategy;<br>    //事件发布者的已经发布到的sequence       <br>    protected final Sequence cursor = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);<br>    //事件处理者处理到的序列对象<br>    protected volatile Sequence[] gatingSequences = new Sequence[0];<br><br>    /**<br>     *检查队列大小是否是2^n，判断buffersize大小<br>     */<br>    public AbstractSequencer(int bufferSize, WaitStrategy waitStrategy) &#123;<br>        if (bufferSize &lt; 1) &#123;<br>            throw new IllegalArgumentException("bufferSize must not be less than 1");&#125;<br>        if (Integer.bitCount(bufferSize) != 1) &#123;<br>            throw new IllegalArgumentException("bufferSize must be a power of 2"); &#125;<br>        this.bufferSize = bufferSize;<br>        this.waitStrategy = waitStrategy;<br>    &#125;<br><br>    /**<br>     * 获取事件发布者的序列<br>     */<br>    @Override<br>    public final long getCursor() &#123;<br>        return cursor.get();<br>    &#125;<br><br>    /**<br>     * 获取大小<br>     */<br>    @Override<br>    public final int getBufferSize() &#123;<br>        return bufferSize;<br>    &#125;<br><br>    /**<br>     * 把事件消费者序列维护到gating sequence<br>     */<br>    @Override<br>    public final void addGatingSequences(Sequence... gatingSequences) &#123;<br>        SequenceGroups.addSequences(this, SEQUENCE_UPDATER, this, gatingSequences);<br>    &#125;<br><br>    /**<br>     *  从gating sequence移除序列<br>     */<br>    @Override<br>    public boolean removeGatingSequence(Sequence sequence) &#123;<br>        return SequenceGroups.removeSequence(this, SEQUENCE_UPDATER, sequence);<br>    &#125;<br><br>    /**<br>     * 获取gating sequence中事件处理者处理到最小的序列值<br>     */<br>    @Override<br>    public long getMinimumSequence() &#123;<br>        return Util.getMinimumSequence(gatingSequences, cursor.get());<br>    &#125;<br><br>    /**<br>     * 创建了一个序列栅栏<br>     */<br>    @Override<br>    public SequenceBarrier newBarrier(Sequence... sequencesToTrack) &#123;<br>        return new ProcessingSequenceBarrier(this, waitStrategy, cursor, sequencesToTrack);<br>    &#125;<br><br>    /**<br>     * 这个方法不解释，我也不知道目前用来干嘛的。有知道的大佬可以赐教一下。谢谢<br>     */<br>    @Override<br>    public &lt;T&gt; EventPoller&lt;T&gt; newPoller(DataProvider&lt;T&gt; dataProvider, Sequence... gatingSequences) &#123;<br>        return EventPoller.newInstance(dataProvider, this, new Sequence(), cursor, gatingSequences);<br>    &#125;<br>    //重写toString<br>    @Override<br>    public String toString() &#123;<br>        return "AbstractSequencer&#123;" +<br>            "waitStrategy=" + waitStrategy +<br>            ", cursor=" + cursor +<br>            ", gatingSequences=" + Arrays.toString(gatingSequences) +<br>            '&#125;';<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SingleProducerSequencer 单线程事件发布者。</strong></p><p>1：从上面的图可以看出SingleProducerSequencer间接继承了AbstractSequencer。</p><p>2：SingleProducerSequencerFields维护事件发布者发布的序列和事件处理者处理到的最小序列。</p><p>3：SingleProducerSequencerPad缓冲行填充，防止false sharing。</p><p><strong>next()申请序列</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//该方法是事件发布者申请序列</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>    &#125;<br>     <span class="hljs-comment">//获取事件发布者发布到的序列值</span><br>    <span class="hljs-keyword">long</span> nextValue = <span class="hljs-keyword">this</span>.nextValue;<br>    <span class="hljs-keyword">long</span> nextSequence = nextValue + n;<br>    <span class="hljs-comment">//wrap 代表申请的序列绕一圈以后的位置</span><br>    <span class="hljs-keyword">long</span> wrapPoint = nextSequence - bufferSize;<br>    <span class="hljs-comment">//获取事件处理者处理到的序列值</span><br>    <span class="hljs-keyword">long</span> cachedGatingSequence = <span class="hljs-keyword">this</span>.cachedValue;<br>    <span class="hljs-comment">/** 1.事件发布者要申请的序列值大于事件处理者当前的序列值且事件发布者要申请的序列值减去环的长度要小于事件处理者的序列值。<br>      * 2.满足(1)，可以申请给定的序列。<br>      * 3.不满足(1)，就需要查看一下当前事件处理者的最小的序列值(可能有多个事件处理者)。如果最小序列值大于等于<br>      * 当前事件处理者的最小序列值大了一圈，那就不能申请了序列(申请了就会被覆盖)，<br>      * */</span><br>    <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123;<br>        <span class="hljs-comment">//wrapPoint &gt; cachedGatingSequence 代表绕一圈并且位置大于事件处理者处理到的序列</span><br>        <span class="hljs-comment">//cachedGatingSequence &gt; nextValue 说明事件发布者的位置位于事件处理者的屁股后面</span><br>        <span class="hljs-comment">//维护父类中事件生产者的序列</span><br>        cursor.setVolatile(nextValue);<br>        <span class="hljs-keyword">long</span> minSequence;<br>        <span class="hljs-comment">//如果事件生产者绕一圈以后大于事件处理者的序列，那么会在此处自旋</span><br>        <span class="hljs-keyword">while</span> (wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue))) &#123;<br>            LockSupport.parkNanos(<span class="hljs-number">1L</span>);<br>        &#125;<br>        <span class="hljs-comment">//缓存最小值</span><br>        <span class="hljs-keyword">this</span>.cachedValue = minSequence;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.nextValue = nextSequence;<br>    <span class="hljs-keyword">return</span> nextSequence;<br>&#125;<br><br><span class="hljs-comment">//事件发布调用的方法。唤醒阻塞的消费者</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    cursor.set(sequence);<br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实战单线程生产者</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">/**<br>     * Create a new Disruptor.<br>     * <span class="hljs-doctag">@param</span> eventFactory 事件对象的数据<br>     * <span class="hljs-doctag">@param</span> ringBufferSize 数组大小，必须是2^n<br>     * <span class="hljs-doctag">@param</span> threadFactory 线程工厂<br>     * <span class="hljs-doctag">@param</span> producerType 生产者策略。ProducerType.SINGLE和ProducerType.MULTI 单个生产者还是多个生产者.<br>     * <span class="hljs-doctag">@param</span> waitStrategy 等待策略。用来平衡事件发布者和事件处理者之间的处理效率。提供了八种策略。默认是BlockingWaitStrategy<br>     */</span><br>    <span class="hljs-comment">//初始化的逻辑大概是创建根据ProducerType初始化创造SingleProducerSequencer或MultiProducerSequencer。</span><br>    <span class="hljs-comment">//初始化Ringbuffer的时候会根据buffsiz把事件对象放入entries数组。</span><br>    Disruptor&lt;TradeBO&gt; disruptor = <span class="hljs-keyword">new</span> Disruptor&lt;&gt;(() -&gt; <span class="hljs-keyword">new</span> TradeBO(), <span class="hljs-number">2</span>,<br>                                                   r -&gt; &#123;<br>                                                       Thread thread = <span class="hljs-keyword">new</span> Thread(r);<br>                                                       thread.setName(<span class="hljs-string">"实战单线程生产者"</span>);<br>                                                       <span class="hljs-keyword">return</span> thread;<br>                                                   &#125;, ProducerType.SINGLE, <span class="hljs-keyword">new</span> BlockingWaitStrategy());<br>    <span class="hljs-comment">//关联事件处理者。初始化BatchEventProcessor。把事件处理者加入gating sequence</span><br>    disruptor.handleEventsWith(<span class="hljs-keyword">new</span> ConsumerA());<br>    disruptor.handleEventsWith(<span class="hljs-keyword">new</span> ConsumerB());<br>    <span class="hljs-comment">//启动消费者线程。BatchEventProcessor间接实现了Runnable。所以这一步就是启动线程。如果事件发布太快，消费太慢会根据不同的waitstrategy等待。</span><br>    disruptor.start();<br>    <span class="hljs-comment">//发布事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> finalI = i;<br>        <span class="hljs-comment">//初始化了EventTranslator。意思就是给最开始初始化的对象赋值</span><br>        EventTranslator eventTranslator = (EventTranslator&lt;TradeBO&gt;) (event, sequence) -&gt; &#123;<br>            event.setId(finalI);<br>            event.setPrice((<span class="hljs-keyword">double</span>) finalI);<br>        &#125;;<br>        <span class="hljs-comment">//发布首先要申请序列，如果申请不到会自旋。</span><br>        disruptor.publishEvent(eventTranslator);<br>    &#125;<br>    disruptor.shutdown();<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">TradeBO</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(TradeBO event, <span class="hljs-keyword">long</span> sequence,<br>                        <span class="hljs-keyword">boolean</span> endOfBatch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"ConsumerB id="</span> + event.getId() + <span class="hljs-string">"price="</span> + event.getPrice());<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">TradeBO</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(TradeBO event, <span class="hljs-keyword">long</span> sequence,<br>                        <span class="hljs-keyword">boolean</span> endOfBatch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"ConsumerB id="</span> + event.getId() + <span class="hljs-string">"   price="</span> + event.getPrice());<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TradeBO</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> Double price;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MultiProducerSequencer</strong></p><p><strong>成员变量</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取unsafe</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE = Util.getUnsafe();<br><span class="hljs-comment">//获取int[]的偏移量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> BASE = UNSAFE.arrayBaseOffset(<span class="hljs-keyword">int</span>[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><span class="hljs-comment">//获取元素的大小，也就是int的大小4个字节</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> SCALE = UNSAFE.arrayIndexScale(<span class="hljs-keyword">int</span>[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><span class="hljs-comment">//gatingSequenceCache是gatingSequence。用来标识事件处理者的序列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequence gatingSequenceCache = <span class="hljs-keyword">new</span> Sequence(Sequencer.INITIAL_CURSOR_VALUE);<br><span class="hljs-comment">//availableBuffer用来追踪每个槽的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] availableBuffer;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> indexMask;<br><span class="hljs-comment">//转了几圈</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> indexShift;<br></code></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiProducerSequencer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bufferSize, <span class="hljs-keyword">final</span> WaitStrategy waitStrategy)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化父类</span><br>    <span class="hljs-keyword">super</span>(bufferSize, waitStrategy);<br>    <span class="hljs-comment">//初始化availableBuffer</span><br>    availableBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bufferSize];<br>    indexMask = bufferSize - <span class="hljs-number">1</span>;<br>    indexShift = Util.log2(bufferSize);<br>    <span class="hljs-comment">//这个逻辑是。计算availableBuffer中每个元素的偏移量</span><br>    <span class="hljs-comment">//定位数组每个值的地址就是(index * SCALE) + BASE</span><br>    initialiseAvailableBuffer();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialiseAvailableBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = availableBuffer.length - <span class="hljs-number">1</span>; i != <span class="hljs-number">0</span>; i--) &#123;<br>        setAvailableBufferValue(i, -<span class="hljs-number">1</span>);<br>    &#125;<br>    setAvailableBufferValue(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAvailableBufferValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> bufferAddress = (index * SCALE) + BASE;<br>    <span class="hljs-comment">//修改内存偏移地址为bufferAddress的值，改为flag</span><br>    UNSAFE.putOrderedInt(availableBuffer, bufferAddress, flag);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>next()申请序列</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>    &#125;<br>    <span class="hljs-keyword">long</span> current;<br>    <span class="hljs-keyword">long</span> next;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//获取事件发布者发布序列</span><br>        current = cursor.get();<br>        <span class="hljs-comment">//新序列位置</span><br>        next = current + n;<br>        <span class="hljs-comment">//wrap 代表申请的序列绕一圈以后的位置</span><br>        <span class="hljs-keyword">long</span> wrapPoint = next - bufferSize;<br>        <span class="hljs-comment">//获取事件处理者处理到的序列值</span><br>        <span class="hljs-keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();<br>        <span class="hljs-comment">/** 1.事件发布者要申请的序列值大于事件处理者当前的序列值且事件发布者要申请的序列值减去环的长度要小于事件处理者的序列值。<br>         * 2.满足(1)，可以申请给定的序列。<br>         * 3.不满足(1)，就需要查看一下当前事件处理者的最小的序列值(可能有多个事件处理者)。如果最小序列值大于等于<br>         * 当前事件处理者的最小序列值大了一圈，那就不能申请了序列(申请了就会被覆盖)，<br>         * */</span><br>        <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current) &#123;<br>            <span class="hljs-comment">//wrapPoint &gt; cachedGatingSequence 代表绕一圈并且位置大于事件处理者处理到的序列</span><br>            <span class="hljs-comment">//cachedGatingSequence &gt; current 说明事件发布者的位置位于事件处理者的屁股后面</span><br><br>            <span class="hljs-comment">//获取最小的事件处理者序列</span><br>            <span class="hljs-keyword">long</span> gatingSequence = Util.getMinimumSequence(gatingSequences, current);<br>            <span class="hljs-keyword">if</span> (wrapPoint &gt; gatingSequence) &#123;<br>                LockSupport.parkNanos(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//赋值</span><br>            gatingSequenceCache.set(gatingSequence);<br>            <span class="hljs-comment">//通过cas修改</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cursor.compareAndSet(current, next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>publish()事件发布</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-comment">//这里的操作逻辑大概是修改数组中的序列值</span><br>    setAvailable(sequence);<br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAvailable</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    setAvailableBufferValue(calculateIndex(sequence), calculateAvailabilityFlag(sequence));<br>&#125;<br><span class="hljs-comment">//计算数组中位置 sequence&amp;(buffsize-1)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateIndex</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">int</span>) sequence) &amp; indexMask;<br>&#125;<br><span class="hljs-comment">//计算数组中的存储的数据</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateAvailabilityFlag</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (sequence &gt;&gt;&gt; indexShift);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAvailableBufferValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> bufferAddress = (index * SCALE) + BASE;<br>    UNSAFE.putOrderedInt(availableBuffer, bufferAddress, flag);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MultiProducerSequencer和SingleProducerSequencer区别</strong></p><p>1：SingleProducerSequencer内部维护cachedValue(事件消费者序列)，nextValue(事件发布者序列)。并且采用padding填充。这个类是线程不安全的。<br>2：MultiProducerSequencer每次获取序列都是从Sequence中获取的。Sequence中针对value的操作都是原子的。</p><p><strong>RingBuffer</strong></p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576726006366.webp" class=""><p><strong>EventSequencer</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个接口是一个空方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventSequencer</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">DataProvider</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Sequenced</span></span>&#123;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>DataProvider</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DataProvider 提供了根据序列获取对应的对象</span><br><span class="hljs-comment">//有两个地方调用。这个Event对象需要被生产者获取往里面填充数据。第二个是在消费时，获取这个Event对象用于消费。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DataProvider</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>EventSink  这个类提供了各种发布的姿势。</strong></p><p>1：EventSink接口是用来发布Event的，在发布的同时，调用绑定的Translator来初始化并填充Event。</p><p>2：填充Event是通过实现EventTranslator，EventTranslatorOneArg，EventTranslatorTwoArg，EventTranslatorThreeArg，EventTranslatorVararg这些EventTranslator来做的。</p><p>3：发布流程：申请下一个序列-&gt;申请成功则获取对应槽的Event-&gt;利用translator初始化并填充对应槽的Event-&gt;发布Event 。translator用户实现，用于初始化Event。</p><p><strong>RingBufferPad  用于缓存行填充</strong></p><p><strong>RingBufferFields 这个类的逻辑比较重要，讲解了event在数组中存储位置</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RingBufferFields</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">com</span>.<span class="hljs-title">lmax</span>.<span class="hljs-title">disruptor</span>.<span class="hljs-title">RingBufferPad</span> </span>&#123;<br>    <span class="hljs-comment">//Buffer数组填充</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BUFFER_PAD;<br>    <span class="hljs-comment">//Buffer数组起始基址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> REF_ARRAY_BASE;<br>    <span class="hljs-comment">//数组引用每个引用占用的大小=2^REF_ELEMENT_SHIFT</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REF_ELEMENT_SHIFT;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE = Util.getUnsafe();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//获取Object[]引用大小。我本机4字节</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scale = UNSAFE.arrayIndexScale(Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">4</span> == scale) &#123;<br>            REF_ELEMENT_SHIFT = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">8</span> == scale) &#123;<br>            REF_ELEMENT_SHIFT = <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unknown pointer size"</span>);<br>        &#125;<br>        <span class="hljs-comment">//填充32或者16</span><br>        BUFFER_PAD = <span class="hljs-number">128</span> / scale;<br>        <span class="hljs-comment">// 计算Buffer数组起始基址。我本机是从32开始</span><br>        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>) + (<span class="hljs-title">BUFFER_PAD</span> &lt;&lt; <span class="hljs-title">REF_ELEMENT_SHIFT</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> indexMask;<br>    <span class="hljs-comment">//保存了RingBuffer每个槽的Event对象。这个entries不会被修改。ps:引用不会被修改</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] entries;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bufferSize;<br>    <span class="hljs-comment">//sequencer=SingleProducerSequencer or MultiProducerSequencer的引用</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Sequencer sequencer;<br><br>    RingBufferFields(<br>        EventFactory&lt;E&gt; eventFactory,<br>        Sequencer sequencer) &#123;<br>        <span class="hljs-keyword">this</span>.sequencer = sequencer;<br>        <span class="hljs-keyword">this</span>.bufferSize = sequencer.getBufferSize();<br><br>        <span class="hljs-keyword">if</span> (bufferSize &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"bufferSize must not be less than 1"</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Integer.bitCount(bufferSize) != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"bufferSize must be a power of 2"</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.indexMask = bufferSize - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.entries = <span class="hljs-keyword">new</span> Object[sequencer.getBufferSize() + <span class="hljs-number">2</span> * BUFFER_PAD];<br>        fill(eventFactory);<br>    &#125;<br>    <span class="hljs-comment">//填充entries</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(EventFactory&lt;E&gt; eventFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bufferSize; i++) &#123;<br>            entries[BUFFER_PAD + i] = eventFactory.newInstance();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> E <span class="hljs-title">elementAt</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SequenceBarrier接口 消费者使用</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SequenceBarrier</span> </span>&#123;<br><br>    <span class="hljs-comment">/**<br>         * 等待一个序列变为可用，然后消费这个序列。消费线程中使用<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> <span class="hljs-keyword">throws</span> AlertException, InterruptedException, TimeoutException</span>;<br><br>    <span class="hljs-comment">/**<br>         * 获取当前可以读取的序列值。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getCursor</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**<br>         * 当前栅栏是否发过通知。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlerted</span><span class="hljs-params">()</span></span>;           <br>    <span class="hljs-comment">/**<br>         * 通知消费者状态变化，然后停留在这个状态上，直到状态被清除。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alert</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**<br>         * 清楚通知状态。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearAlert</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**<br>         * 检测是否发生了通知，如果已经发生了抛出AlertException异常。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkAlert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> AlertException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ProcessingSequenceBarrier</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessingSequenceBarrier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SequenceBarrier</span> </span>&#123;<br><span class="hljs-comment">//等待策略</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WaitStrategy waitStrategy;<br><span class="hljs-comment">//当消费者之前没有依赖关系的时候，那么dependentSequence=cursorSequence</span><br><span class="hljs-comment">//存在依赖关系的时候，dependentSequence 里存放的是一组依赖的Sequence，get方法得到的是最小的序列值</span><br><span class="hljs-comment">//所谓的依赖关系是有两个消费者A、B，其中B需要在A之后进行消费，这A的序列就是B需要依赖的序列，因为B的消费速度不能超过A。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequence dependentSequence;<br><span class="hljs-comment">//判断是否执行shutdown</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> alerted = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">//cursorSequence 代表的是写指针。代表事件发布者发布到那个位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequence cursorSequence;<br><span class="hljs-comment">//sequencer=SingleProducerSequencer or MultiProducerSequencer的引用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequencer sequencer;<br><br>ProcessingSequenceBarrier(<br>        <span class="hljs-keyword">final</span> Sequencer sequencer,<br>        <span class="hljs-keyword">final</span> WaitStrategy waitStrategy,<br>        <span class="hljs-keyword">final</span> Sequence cursorSequence,<br>        <span class="hljs-keyword">final</span> Sequence[] dependentSequences) &#123;<br>    <span class="hljs-keyword">this</span>.sequencer = sequencer;<br>    <span class="hljs-keyword">this</span>.waitStrategy = waitStrategy;<br>    <span class="hljs-keyword">this</span>.cursorSequence = cursorSequence;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == dependentSequences.length) &#123;<br>        dependentSequence = cursorSequence;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dependentSequence = <span class="hljs-keyword">new</span> FixedSequenceGroup(dependentSequences);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span><br>        <span class="hljs-keyword">throws</span> AlertException, InterruptedException, TimeoutException </span>&#123;<br>    <span class="hljs-comment">//检查是否中断</span><br>    checkAlert();<br>    <span class="hljs-comment">//根据不同的策略获取可用的序列</span><br>    <span class="hljs-keyword">long</span> availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">//判断申请的序列和可用的序列大小</span><br>    <span class="hljs-keyword">if</span> (availableSequence &lt; sequence) &#123;<br>        <span class="hljs-keyword">return</span> availableSequence;<br>    &#125;<br>    <span class="hljs-comment">//如果是单线程生产者直接返回availableSequence</span><br>    <span class="hljs-comment">//多线程生产者判断是否可用，不可用返回sequence-1</span><br>    <span class="hljs-keyword">return</span> sequencer.getHighestPublishedSequence(sequence, availableSequence);<br>&#125;<br><span class="hljs-comment">//获取当前序列</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCursor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dependentSequence.get();<br>&#125;<br><span class="hljs-comment">//判断是否中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlerted</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> alerted;<br>&#125;<br><span class="hljs-comment">//中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alert</span><span class="hljs-params">()</span> </span>&#123;<br>    alerted = <span class="hljs-keyword">true</span>;<br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br><span class="hljs-comment">//清除中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearAlert</span><span class="hljs-params">()</span> </span>&#123;<br>    alerted = <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">//检查是否中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAlert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> AlertException </span>&#123;<br>    <span class="hljs-keyword">if</span> (alerted) &#123;<br>        <span class="hljs-keyword">throw</span> AlertException.INSTANCE;<br>     &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>事件处理 EventProcessor</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">//获取事件处理器使用的序列引用。 </span><br>    <span class="hljs-function">Sequence <span class="hljs-title">getSequence</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//中断</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">halt</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//判断是否运行</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BatchEventProcessor event模式单线程处理</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重点讲run方法，其它方法都比较简单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchEventProcessor</span>&lt;<span class="hljs-title">T</span>&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title">EventProcessor</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//启动任务</span><br>        <span class="hljs-keyword">if</span> (running.compareAndSet(IDLE, RUNNING)) &#123;<br>            <span class="hljs-comment">//清除中断状态</span><br>            sequenceBarrier.clearAlert();<br>            <span class="hljs-comment">//判断一下消费者是否实现了LifecycleAware ,如果实现了这个接口，那么此时会发送一个启动通知</span><br>            notifyStart();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//判断任务是否启动</span><br>                <span class="hljs-keyword">if</span> (running.get() == RUNNING) &#123;<br>                    <span class="hljs-comment">//处理事件</span><br>                    processEvents();<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//判断一下消费者是否实现了LifecycleAware ,如果实现了这个接口，那么此时会发送一个停止通知</span><br>                notifyShutdown();<br>                <span class="hljs-comment">//重新设置状态</span><br>                running.set(IDLE);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 线程已经启动</span><br>            <span class="hljs-keyword">if</span> (running.get() == RUNNING) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Thread is already running"</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//这里就是  notifyStart();notifyShutdown();</span><br>                earlyExit();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processEvents</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个event</span><br>        T event = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//获取要申请的序列</span><br>        <span class="hljs-keyword">long</span> nextSequence = sequence.get() + <span class="hljs-number">1L</span>;<br>        <span class="hljs-comment">//循环处理事件。除非超时或者中断。</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//根据等待策略来等待可用的序列值。 </span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);<br>                <span class="hljs-keyword">if</span> (batchStartAware != <span class="hljs-keyword">null</span>) &#123;<br>                    batchStartAware.onBatchStart(availableSequence - nextSequence + <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-comment">//根据可用的序列值获取事件。批量处理nextSequence到availableSequence之间的事件。</span><br>                <span class="hljs-keyword">while</span> (nextSequence &lt;= availableSequence) &#123;<br>                    <span class="hljs-comment">//获取事件</span><br>                    event = dataProvider.get(nextSequence);<br>                    <span class="hljs-comment">//触发事件</span><br>                    eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);<br>                    nextSequence++;<br>                &#125;<br>                <span class="hljs-comment">//设置事件处理者处理到的序列值。事件发布者会根据availableSequence判断是否发布事件 </span><br>                sequence.set(availableSequence);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> TimeoutException e) &#123;<br>                <span class="hljs-comment">//超时异常</span><br>                notifyTimeout(sequence.get());<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> AlertException ex) &#123;<br>                <span class="hljs-comment">//中断异常</span><br>                <span class="hljs-keyword">if</span> (running.get() != RUNNING) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable ex) &#123;<br>                <span class="hljs-comment">//这里可能用户消费者事件出错。如果自己实现了ExceptionHandler那么就不会影响继续消费</span><br>                exceptionHandler.handleEventException(ex, nextSequence, event);<br>                <span class="hljs-comment">//如果出现异常则设置为nextSequence</span><br>                sequence.set(nextSequence);<br>                nextSequence++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>WorkProcessor  work模式多线程处理</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//判断线程是否启动</span><br>    <span class="hljs-keyword">if</span> (!running.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Thread is already running"</span>);<br>    &#125;<br>    <span class="hljs-comment">//清除中断状态</span><br>    sequenceBarrier.clearAlert();<br>    <span class="hljs-comment">//判断一下消费者是否实现了LifecycleAware ,如果实现了这个接口，那么此时会发送一个启动通知</span><br>    notifyStart();<br>    <span class="hljs-comment">//事件处理标志</span><br>    <span class="hljs-keyword">boolean</span> processedSequence = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">long</span> cachedAvailableSequence = Long.MIN_VALUE;<br>    <span class="hljs-keyword">long</span> nextSequence = sequence.get();<br>    T event = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//判断上一个事件是否已经处理完毕。  </span><br>            <span class="hljs-keyword">if</span> (processedSequence) &#123;<br>                <span class="hljs-comment">//置为false</span><br>                processedSequence = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-comment">//获取下一个序列</span><br>                    nextSequence = workSequence.get() + <span class="hljs-number">1L</span>;<br>                    <span class="hljs-comment">//更新当前已经处理到的</span><br>                    sequence.set(nextSequence - <span class="hljs-number">1L</span>);<br>                &#125;<br>            <span class="hljs-comment">//多个WorkProcessor共享一个workSequence，可以实现互斥消费，因为只有一个线程可以CAS更新成功</span><br>                <span class="hljs-keyword">while</span> (!workSequence.compareAndSet(nextSequence - <span class="hljs-number">1L</span>, nextSequence));<br>            &#125;<br>           <span class="hljs-comment">//检查序列值是否需要申请。</span><br>            <span class="hljs-keyword">if</span> (cachedAvailableSequence &gt;= nextSequence) &#123;<br>                <span class="hljs-comment">//获取事件</span><br>                event = ringBuffer.get(nextSequence);<br>               <span class="hljs-comment">//交给workHandler处理事件。  </span><br>                workHandler.onEvent(event);<br>               <span class="hljs-comment">//设置事件处理完成标识</span><br>                processedSequence = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//申请可用序列</span><br>                cachedAvailableSequence = sequenceBarrier.waitFor(nextSequence);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> TimeoutException e) &#123;<br>            notifyTimeout(sequence.get());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> AlertException ex) &#123;<br>            <span class="hljs-keyword">if</span> (!running.get()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable ex) &#123;<br>            <span class="hljs-comment">//设置异常事件处理</span><br>            exceptionHandler.handleEventException(ex, nextSequence, event);<br>            processedSequence = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//同上</span><br>    notifyShutdown();<br>    <span class="hljs-comment">//停止</span><br>    running.set(<span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>WorkerPool</strong></p><p>1：多个WorkProcessor组成一个WorkerPool。<br>2：维护workSequence事件处理者处理的序列。</p><p><strong>waitStrategy 等待策略</strong></p><p>BlockingWaitStrategy：默认的等待策略。利用锁和等待机制的WaitStrategy，CPU消耗少，但是延迟比较高</p><p>BusySpinWaitStrategy：自旋等待。这种策略会利用CPU资源来避免系统调用带来的延迟抖动，当线程可以绑定到指定CPU(核)的时候可以使用这个策略。</p><p>LiteBlockingWaitStrategy：实现方法也是阻塞等待</p><p>SleepingWaitStrategy：是另一种较为平衡CPU消耗与延迟的WaitStrategy，在不同次数的重试后，采用不同的策略选择继续尝试或者让出CPU或者sleep。这种策略延迟不均匀。</p><p>TimeoutBlockingWaitStrategy：实现方法是阻塞给定的时间，超过时间的话会抛出超时异常。</p><p>YieldingWaitStrategy：实现方法是先自旋(100次)，不行再临时让出调度(yield)。和SleepingWaitStrategy一样也是一种高性能与CPU资源之间取舍的折中方案，但这个策略不会带来显著的延迟抖动。</p><p>PhasedBackoffWaitStrategy：实现方法是先自旋(10000次)，不行再临时让出调度(yield)，不行再使用其他的策略进行等待。可以根据具体场景自行设置自旋时间、yield时间和备用等待策略。</p><p><strong>实战多线程消费者</strong></p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个RingBuffer，注意容量是2。</span><br>    RingBuffer&lt;TradeBO&gt; ringBuffer = RingBuffer.createSingleProducer(() -&gt; <span class="hljs-keyword">new</span> TradeBO(), <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//创建2个WorkHandler其实就是创建2个WorkProcessor</span><br>    WorkerPool&lt;TradeBO&gt; workerPool =<br>        <span class="hljs-keyword">new</span> WorkerPool&lt;TradeBO&gt;(ringBuffer, ringBuffer.newBarrier(),<br>                                <span class="hljs-keyword">new</span> IgnoreExceptionHandler(),<br>                                <span class="hljs-keyword">new</span> ConsumerC(), <span class="hljs-keyword">new</span> ConsumerD());<br>    <span class="hljs-comment">//将WorkPool的工作序列集设置为ringBuffer的追踪序列。</span><br>    ringBuffer.addGatingSequences(workerPool.getWorkerSequences());<br>    <span class="hljs-comment">//创建一个线程池用于执行Workhandler。</span><br>    Executor executor = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//启动WorkPool。</span><br>    workerPool.start(executor);<br>    <span class="hljs-comment">//往RingBuffer上发布事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> finalI = i;<br>        EventTranslator eventTranslator = (EventTranslator&lt;TradeBO&gt;) (event, sequence) -&gt; &#123;<br>            event.setId(finalI);<br>            event.setPrice((<span class="hljs-keyword">double</span>) finalI);<br>        &#125;;<br>        ringBuffer.publishEvent(eventTranslator);<br>        System.out.println(<span class="hljs-string">"发布["</span> + finalI + <span class="hljs-string">"]"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//程序执行结果。可以看出，多个线程消费者处理位于不同位置的事件</span><br>发布[<span class="hljs-number">0</span>]<br>    ConsumerC id=<span class="hljs-number">0</span>   price=<span class="hljs-number">0.0</span><br>    发布[<span class="hljs-number">1</span>]<br>    发布[<span class="hljs-number">2</span>]<br>    ConsumerC id=<span class="hljs-number">2</span>   price=<span class="hljs-number">2.0</span><br>    ConsumerD id=<span class="hljs-number">1</span>   price=<span class="hljs-number">1.0</span><br>    ConsumerC id=<span class="hljs-number">3</span>   price=<span class="hljs-number">3.0</span><br>    发布[<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>DSL</strong></p><p>1:所谓DSL我的理解就是消费者这里相互依赖。</p><img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576726329157.webp" class=""><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">dw.consumeWith(handler1a, handler2a);<br>dw.after(handler1a).consumeWith(handler1b);<br>dw.after(handler2a).consumeWith(handler2b);<br>dw.after(handler1b, handler2b).consumeWith(handler3);<br>ProducerBarrier producerBarrier = dw.createProducerBarrier();<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Disruptor </tag>
            
            <tag> 高效队列 </tag>
            
            <tag> 伪共享 </tag>
            
            <tag> CAS </tag>
            
            <tag> DSL </tag>
            
            <tag> MESI 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是ZooKeeper</title>
      <link href="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/"/>
      <url>/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文摘抄自： <a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653193977&idx=1&sn=12319f8cb81f55a40ac461bd0ad9d74e&chksm=8c99f423bbee7d35056ce7ec1b321f33aad15c309de6eba0086cb31a48b975ccb1d695d5a251&mpshare=1&scene=23&srcid=1009q5vbBfA0ssZhVnm61nEd&sharer_sharetime=1570673341100&sharer_shareid=f8be6084b82cc018b018588532bb3fe1#rd" target="_blank" rel="noopener"> 程序员小灰——什么是ZooKeeper？</a></p></blockquote><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640.webp" class=""><a id="more"></a><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571208.webp" class=""><center><b>—————  第二天  —————</b></center><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571211.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571216.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/0.jpg" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571231.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571236.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571243.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571252.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571259.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571263.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571267.webp" class=""><hr/><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571275.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571283.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571287.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673571295.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673628957.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673628968.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673628973.webp" class=""><h1 id="Zookeeper的数据模型"><a href="#Zookeeper的数据模型" class="headerlink" title="Zookeeper的数据模型"></a>Zookeeper的数据模型</h1><p>Zookeeper的数据模型是什么样子呢？它很像数据结构当中的树，也很像文件系统的目录。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692556.webp" class=""><p>树是由节点所组成，Zookeeper的数据存储也同样是基于节点，这种节点叫做<strong>Znode</strong>。</p><p>但是，不同于树的节点，Znode的引用方式是<strong>路径引用</strong>，类似于文件路径：</p><p> /动物/仓鼠</p><p> /植物/荷花</p><p>这样的层级结构，让每一个Znode节点拥有唯一的路径，就像命名空间一样对不同信息作出清晰的隔离。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692564.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692568.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692576.webp" class=""><p><strong>data</strong>：Znode存储的数据信息。</p><p><strong>ACL</strong>：记录Znode的访问权限，即哪些人或哪些IP可以访问本节点。</p><p><strong>stat</strong>：包含Znode的各种元数据，比如事务ID、版本号、时间戳、大小等等。</p><p><strong>child</strong>：当前节点的子节点引用，类似于二叉树的左孩子右孩子。</p><p>这里需要注意一点，Zookeeper是为读多写少的场景所设计。Znode并不是用来存储大规模业务数据，而是用于存储少量的状态和配置信息，<strong>每个节点的数据最大不能超过1MB</strong>。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692584.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692592.webp" class=""><h1 id="Zookeeper的基本操作和事件通知"><a href="#Zookeeper的基本操作和事件通知" class="headerlink" title="Zookeeper的基本操作和事件通知"></a>Zookeeper的基本操作和事件通知</h1><p>Zookeeper包含了哪些基本操作呢？这里列举出比较常用的API：</p><p><strong>create</strong>：创建节点</p><p><strong>delete</strong>：删除节点</p><p><strong>exists</strong>：判断节点是否存在</p><p><strong>getData</strong>：获得一个节点的数据</p><p><strong>setData</strong>：设置一个节点的数据</p><p><strong>getChildren</strong>：获取节点下的所有子节点这其中，exists，getData，getChildren属于读操作。Zookeeper客户端在请求读操作的时候，可以选择是否设置<strong>Watch</strong>。</p><p>Watch是什么意思呢？</p><p>我们可以理解成是注册在特定Znode上的触发器。当这个Znode发生改变，也就是调用了create，delete，setData方法的时候，将会触发Znode上注册的对应事件，请求Watch的客户端会接收到<strong>异步通知</strong>。</p><p>具体交互过程如下：</p><p>1.客户端调用getData方法，watch参数是true。服务端接到请求，返回节点数据，并且在对应的哈希表里插入被Watch的Znode路径，以及Watcher列表。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692596.webp" class=""><p>2.当被Watch的Znode已删除，服务端会查找哈希表，找到该Znode对应的所有Watcher，异步通知客户端，并且删除哈希表中对应的Key-Value。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692604.webp" class=""><h1 id="Zookeeper的一致性"><a href="#Zookeeper的一致性" class="headerlink" title="Zookeeper的一致性"></a>Zookeeper的一致性</h1><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692613.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692617.webp" class=""><p>Zookeeper的集群长成什么样呢？就像下图这样：</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692620.webp" class=""><p>Zookeeper Service集群是一主多从结构。</p><p>在更新数据时，首先更新到主节点（这里的节点是指服务器，不是Znode），再同步到从节点。</p><p>在读取数据时，直接读取任意从节点。</p><p>为了保证主从节点的数据一致性，Zookeeper采用了<strong>ZAB协议</strong>，这种协议非常类似于一致性算法<strong>Paxos</strong>和<strong>Raft</strong>。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692628.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692636.webp" class=""><p>在学习ZAB之前，我们需要首先了解ZAB协议所定义的三种节点状态：</p><p><strong>Looking</strong> ：选举状态。</p><p><strong>Following</strong> ：Follower节点（从节点）所处的状态。</p><p><strong>Leading</strong> ：Leader节点（主节点）所处状态。</p><p>我们还需要知道<strong>最大ZXID</strong>的概念：</p><p>最大ZXID也就是节点本地的最新事务编号，包含<strong>epoch</strong>和计数两部分。epoch是纪元的意思，相当于Raft算法选主时候的term。</p><p>假如Zookeeper当前的主节点挂掉了，集群会进行<strong>崩溃恢复</strong>。ZAB的崩溃恢复分成三个阶段：</p><p><strong>1.Leader election</strong></p><p>选举阶段，此时集群中的节点处于Looking状态。它们会各自向其他节点发起投票，投票当中包含自己的服务器ID和最新事务ID（ZXID）。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692644.webp" class=""><p>接下来，节点会用自身的ZXID和从其他节点接收到的ZXID做比较，如果发现别人家的ZXID比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前已知最大的ZXID所属节点。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692651.webp" class=""><p>每次投票后，服务器都会统计投票数量，判断是否有某个节点得到半数以上的投票。如果存在这样的节点，该节点将会成为准Leader，状态变为Leading。其他节点的状态变为Following。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692659.webp" class=""><p>这就相当于，一群武林高手经过激烈的竞争，选出了武林盟主。</p><p><strong>2.Discovery</strong></p><p>发现阶段，用于在从节点中发现最新的ZXID和事务日志。或许有人会问：既然Leader被选为主节点，已经是集群里数据最新的了，为什么还要从节点中寻找最新事务呢？</p><p>这是为了防止某些意外情况，比如因网络原因在上一阶段产生多个Leader的情况。</p><p>所以这一阶段，Leader集思广益，接收所有Follower发来各自的最新epoch值。Leader从中选出最大的epoch，基于此值加1，生成新的epoch分发给各个Follower。</p><p>各个Follower收到全新的epoch后，返回ACK给Leader，带上各自最大的ZXID和历史事务日志。Leader选出最大的ZXID，并更新自身历史日志。</p><p><strong>3.Synchronization</strong></p><p>同步阶段，把Leader刚才收集得到的最新历史事务日志，同步给集群中所有的Follower。只有当半数Follower同步成功，这个准Leader才能成为正式的Leader。</p><p>自此，故障恢复正式完成。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692668.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692672.webp" class=""><p>什么是<strong>Broadcast</strong>呢？简单来说，就是Zookeeper常规情况下更新数据的时候，由Leader广播到所有的Follower。其过程如下：</p><p>1.客户端发出写入数据请求给任意Follower。</p><p>2.Follower把写入数据请求转发给Leader。</p><p>3.Leader采用二阶段提交方式，先发送Propose广播给Follower。</p><p>4.Follower接到Propose消息，写入日志成功后，返回ACK消息给Leader。</p><p>5.Leader接到半数以上ACK消息，返回成功给客户端，并且广播Commit请求给Follower。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673692680.webp" class=""><p>Zab协议既不是强一致性，也不是弱一致性，而是处于两者之间的<strong>单调一致性</strong>。它依靠事务ID和版本号，保证了数据的更新和读取是有序的。</p><h1 id="Zookeeper的应用"><a href="#Zookeeper的应用" class="headerlink" title="Zookeeper的应用"></a>Zookeeper的应用</h1><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673740840.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673740844.webp" class=""><p><strong>1.分布式锁</strong></p><p>这是雅虎研究员设计Zookeeper的初衷。利用Zookeeper的临时顺序节点，可以轻松实现分布式锁。</p><p><strong>2.服务注册和发现</strong></p><p>利用Znode和Watcher，可以实现分布式服务的注册和发现。最著名的应用就是阿里的分布式RPC框架Dubbo。</p><p><strong>3.共享配置和状态信息</strong></p><p>Redis的分布式解决方案Codis，就利用了Zookeeper来存放数据路由表和 codis-proxy 节点的元信息。同时 codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy。</p><p>此外，Kafka、HBase、Hadoop，也都依靠Zookeeper同步节点信息，实现高可用。</p><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673740848.webp" class=""><img src="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/640-1570673740856.webp" class=""><p><strong>几点补充：</strong></p><p>1.ZAB协议相对比较复杂，小灰对此也只是浅层次的理解，有兴趣的小伙伴们可以去官方社区进行进一步学习。</p><p><strong>2.本漫画纯属娱乐，还请大家尽量珍惜当下的工作，切勿模仿小灰的行为哦。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> 服务注册与发现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<div>    <img src="index/about.gif" style="width:100%;"/></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/help/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"/>
      <url>/help/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h1 id="默认修改"><a href="#默认修改" class="headerlink" title="默认修改"></a>默认修改</h1><p>查看该文件夹中的 tag.js 文件和tagcloud.js 文件。</p><h1 id="清理文件"><a href="#清理文件" class="headerlink" title="清理文件"></a>清理文件</h1><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><h1 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h1><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><h1 id="部署到gitee"><a href="#部署到gitee" class="headerlink" title="部署到gitee"></a>部署到gitee</h1><figure class="hljs highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/help/tag.js"/>
      <url>/help/tag.js</url>
      
        <content type="html"><![CDATA['use strict';/** * 解决 asset_img 图片不渲染问题，替换 node_modules\hexo\lib\extend\tag.js 文件 */const stripIndent = require('strip-indent');const { cyan } = require('chalk');const nunjucks = require('nunjucks');const { inherits } = require('util');const Promise = require('bluebird');function Tag() {  this.env = new nunjucks.Environment(null, {    autoescape: false  });}Tag.prototype.register = function(name, fn, options) {  if (!name) throw new TypeError('name is required');  if (typeof fn !== 'function') throw new TypeError('fn must be a function');  if (options == null || typeof options === 'boolean') {    options = {ends: options};  }  let tag;  if (options.async) {    if (fn.length > 2) {      fn = Promise.promisify(fn);    } else {      fn = Promise.method(fn);    }    if (options.ends) {      tag = new NunjucksAsyncBlock(name, fn);    } else {      tag = new NunjucksAsyncTag(name, fn);    }  } else if (options.ends) {    tag = new NunjucksBlock(name, fn);  } else {    tag = new NunjucksTag(name, fn);  }  this.env.addExtension(name, tag);};const placeholder = '\uFFFC';const rPlaceholder = /(?:<|&lt;)!--\uFFFC(\d+)--(?:>|&gt;)/g;function getContextLineNums(min, max, center, amplitude) {  const result = [];  let lbound = Math.max(min, center - amplitude);  const hbound = Math.min(max, center + amplitude);  while (lbound <= hbound) result.push(lbound++);  return result;}const LINES_OF_CONTEXT = 5;function getContext(lines, errLine, location, type) {  const colorize = cyan;  const message = [    location + ' ' + type,    colorize('    =====               Context Dump               ====='),    colorize('    === (line number probably different from source) ===')  ];  Array.prototype.push.apply(message,    // get LINES_OF_CONTEXT lines surrounding `errLine`    getContextLineNums(1, lines.length, errLine, LINES_OF_CONTEXT)      .map(lnNum => {        const line = '  ' + lnNum + ' | ' + lines[lnNum - 1];        if (lnNum === errLine) {          return colorize.bold(line);        }        return colorize(line);      })  );  message.push(colorize(    '    =====             Context Dump Ends            ====='));  return message;}/** * Provide context for Nunjucks error * @param  {Error}    err Nunjucks error * @param  {string}   str string input for Nunjucks * @return {Error}    New error object with embedded context */function formatNunjucksError(err, input) {  const match = err.message.match(/Line (\d+), Column \d+/);  if (!match) return err;  const errLine = parseInt(match[1], 10);  if (isNaN(errLine)) return err;  // trim useless info from Nunjucks Error  const splited = err.message.replace('(unknown path)', '').split('\n');  const e = new Error();  e.name = 'Nunjucks Error';  e.line = errLine;  e.location = splited[0];  e.type = splited[1].trim();  e.message = getContext(input.split(/\r?\n/), errLine, e.location, e.type).join('\n');  return e;}Tag.prototype.render = function(str, options, callback) {  if (!callback && typeof options === 'function') {    callback = options;    options = {};  }  const cache = [];  const escapeContent = str => `<!--${placeholder}${cache.push(str) - 1}-->`;  str = str.replace(/<pre><code.*?>[\s\S]*?<\/code><\/pre>/gm, escapeContent);  return Promise.fromCallback(cb => { this.env.renderString(str, options, cb); })    .catch(err => Promise.reject(formatNunjucksError(err, str)))    .then(result => result.replace(rPlaceholder, (_, index) => cache[index]));};function NunjucksTag(name, fn) {  this.tags = [name];  this.fn = fn;}NunjucksTag.prototype.parse = function(parser, nodes, lexer) {  const node = this._parseArgs(parser, nodes, lexer);  return new nodes.CallExtension(this, 'run', node, []);};NunjucksTag.prototype._parseArgs = (parser, nodes, lexer) => {  const tag = parser.nextToken();  const node = new nodes.NodeList(tag.lineno, tag.colno);  const argarray = new nodes.Array(tag.lineno, tag.colno);  let token;  let argitem = '';  while ((token = parser.nextToken(true))) {    if (token.type === lexer.TOKEN_WHITESPACE || token.type === lexer.TOKEN_BLOCK_END) {      if (argitem !== '') {        const argnode = new nodes.Literal(tag.lineno, tag.colno, argitem.trim());        argarray.addChild(argnode);        argitem = '';      }      if (token.type === lexer.TOKEN_BLOCK_END) {        break;      }    } else {      argitem += token.value;    }  }  node.addChild(argarray);  return node;};NunjucksTag.prototype.run = function(context, args) {  return this._run(context, args, '');};NunjucksTag.prototype._run = function(context, args, body) {  return Reflect.apply(this.fn, context.ctx, [args, body]);};function NunjucksBlock(name, fn) {  Reflect.apply(NunjucksTag, this, [name, fn]);}inherits(NunjucksBlock, NunjucksTag);NunjucksBlock.prototype.parse = function(parser, nodes, lexer) {  const node = this._parseArgs(parser, nodes, lexer);  const body = this._parseBody(parser, nodes, lexer);  return new nodes.CallExtension(this, 'run', node, [body]);};NunjucksBlock.prototype._parseBody = function(parser, nodes, lexer) {  const body = parser.parseUntilBlocks(`end${this.tags[0]}`);  parser.advanceAfterBlockEnd();  return body;};NunjucksBlock.prototype.run = function(context, args, body) {  return this._run(context, args, trimBody(body));};function trimBody(body) {  return stripIndent(body()).replace(/^\n?|\n?$/g, '');}function NunjucksAsyncTag(name, fn) {  Reflect.apply(NunjucksTag, this, [name, fn]);}inherits(NunjucksAsyncTag, NunjucksTag);NunjucksAsyncTag.prototype.parse = function(parser, nodes, lexer) {  const node = this._parseArgs(parser, nodes, lexer);  return new nodes.CallExtensionAsync(this, 'run', node, []);};NunjucksAsyncTag.prototype.run = function(context, args, callback) {  return this._run(context, args, '').then(result => {    callback(null, result);  }, callback);};function NunjucksAsyncBlock(name, fn) {  Reflect.apply(NunjucksBlock, this, [name, fn]);}inherits(NunjucksAsyncBlock, NunjucksBlock);NunjucksAsyncBlock.prototype.parse = function(parser, nodes, lexer) {  const node = this._parseArgs(parser, nodes, lexer);  const body = this._parseBody(parser, nodes, lexer);  return new nodes.CallExtensionAsync(this, 'run', node, [body]);};NunjucksAsyncBlock.prototype.run = function(context, args, body, callback) {  // enable async tag nesting  body((err, result) => {    // wrapper for trimBody expecting    // body to be a function    body = () => result || '';    this._run(context, args, trimBody(body)).then(result => {      callback(err, result);    });  });};module.exports = Tag;]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/help/tagcloud.js"/>
      <url>/help/tagcloud.js</url>
      
        <content type="html"><![CDATA['use strict';/** * 该文件是生成标签页样式的js文件，在使用时需要替换掉 node_modules\hexo\lib\plugins\helper\tagcloud.js 这个文件才能正常显示 */const { Color } = require('hexo-util');function tagcloudHelper(tags, options) {  if (!options && (!tags || !Object.prototype.hasOwnProperty.call(tags, 'length'))) {    options = tags;    tags = this.site.tags;  }  if (!tags || !tags.length) return '';  options = options || {};  const min = options.min_font || 10;  const max = options.max_font || 20;  const orderby = options.orderby || 'name';  const order = options.order || 1;  const unit = options.unit || 'px';  let color = options.color;  const { transform } = options;  const separator = options.separator || ' ';  const result = [];  let startColor, endColor;  if (color) {    startColor = new Color(options.start_color);    endColor = new Color(options.end_color);    if (!startColor || !endColor) color = false;  }  // Sort the tags  if (orderby === 'random' || orderby === 'rand') {    tags = tags.random();  } else {    tags = tags.sort(orderby, order);  }  // Limit the number of tags  if (options.amount) {    tags = tags.limit(options.amount);  }  const sizes = [];  tags.sort('length').forEach(tag => {    const { length } = tag;    if (sizes.includes(length)) return;    sizes.push(length);  });  const length = sizes.length - 1;  tags.forEach(tag => {    const ratio = length ? sizes.indexOf(tag.length) / length : 0;    const size = min + ((max - min) * ratio);    let style = `font-size: ${parseFloat(size.toFixed(2))}${unit};`;    // if (color) {    //   const midColor = startColor.mix(endColor, ratio);    //   style += ` color: ${midColor.toString()}`;    // }    result.push(      `<a class="post-tag button" href="${this.url_for(tag.path)}" ref="tag" style="${style}">${transform ? transform(tag.name) : tag.name}</a>`    );  });  return result.join(separator);}module.exports = tagcloudHelper;]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
