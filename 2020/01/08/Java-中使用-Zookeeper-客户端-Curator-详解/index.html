<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="ZGYSYY, 我不是老司机, 后端开发, Java技术文章, Spring, SpringCloud, JVM调优, 程序员, 高并发编程, IT网站, 分布式, 中间件, 微服务, 个人技术博客">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="我不是老司机" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" aria-label=\"复制\"><i class=\"far fa-copy\"></i></button>",
              "</div>",
              "<div class=\"titlebar-center\">",
                "code",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" aria-label=\"复制\"><i class=\"far fa-copy\"></i></button>",
              "</div>",
              "<div class=\"titlebar-center\">",
                "code",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "<i class=\"far fa-check-square\"></i>";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "<i class=\"far fa-copy\"></i>";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>Java 中使用 Zookeeper 客户端 Curator 详解 | 我不是老司机 - I am not an old driver ! </title>
  <meta name="generator" content="Hexo 4.2.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">我不是老司机</a></h1>
        <h2 class="subtitle">I am not an old driver ! </h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://zgysyy.github.io/2020/01/08/Java-%E4%B8%AD%E4%BD%BF%E7%94%A8-Zookeeper-%E5%AE%A2%E6%88%B7%E7%AB%AF-Curator-%E8%AF%A6%E8%A7%A3/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="ZGY">
       <meta itemprop="description" content="不逼逼自己，都不知道自己到底有多LOW！(¬､¬)">
       <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="我不是老司机">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">Java 中使用 Zookeeper 客户端 Curator 详解</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-01-08T19:46:55+08:00">2020-01-08 19:46:55</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%90%8E%E7%AB%AF/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%90%8E%E7%AB%AF/Java/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>因为最近项目需要使用Zookeeper这个中间件，提前了解一下它的客户端Curator的使用。</p>
<p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。Patrixck Hunt（Zookeeper）以一句“Guava is to Java that Curator to Zookeeper”给Curator予高度评价。</p>
<p>Curator无疑是Zookeeper客户端中的瑞士军刀，它译作”馆长”或者’’管理者’’，不知道是不是开发小组有意而为之，笔者猜测有可能这样命名的原因是说明Curator就是Zookeeper的馆长(脑洞有点大：Curator就是动物园的园长)。<br>Curator包含了几个包：</p>
<ul>
<li>curator-framework：对zookeeper的底层api的一些封装。</li>
<li>curator-client：提供一些客户端的操作，例如重试策略等。</li>
<li>curator-recipes：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等。</li>
</ul>
<a id="more"></a>

<p>Maven依赖（注意zookeeper版本  这里对应的是3.4.6）</p>
<figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="Curator的基本Api"><a href="#Curator的基本Api" class="headerlink" title="Curator的基本Api"></a>Curator的基本Api</h1><h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p><strong>方式一</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/*<br>    创建重试策略对象，参数含义如下：<br>    - baseSleepTimeMs: 基本睡眠时间。<br>    - maxRetries：最大重试次数。<br>    */</span><br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">/*<br>    创建客户端对象，参数含义如下：<br>    - connectString：服务器列表，格式为 `host1:port,host2:port,...`。<br>    - sessionTimeoutMs：会话超时时间， 默认 60000 ms。<br>    - connectionTimeoutMs：连接超时时间，默认 60000 ms。<br>    - retryPolicy：重试策略<br>    */</span><br>    CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retryPolicy);<br>    <span class="hljs-comment">// 连接 zookeeper 服务器</span><br>    client.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方式二</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .build();<br>    client.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>创建包含隔离命名空间的会话</strong></p>
<p>为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（NameSpace），即指定一个Zookeeper的根路径（官方术语：为Zookeeper添加“Chroot”特性）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一课子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>		CuratorFramework client =<br>		CuratorFrameworkFactory.builder()<br>				.connectString(connectionInfo)<br>				.sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>				.connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>				.retryPolicy(retryPolicy)<br>				.namespace(<span class="hljs-string">"base"</span>)<br>				.build();<br></code></pre></td></tr></table></figure>

<h2 id="数据节点基本操作（增删改查）"><a href="#数据节点基本操作（增删改查）" class="headerlink" title="数据节点基本操作（增删改查）"></a>数据节点基本操作（增删改查）</h2><p><strong>Zookeeper的节点创建模式：</strong></p>
<ul>
<li>PERSISTENT：持久化</li>
<li>PERSISTENT_SEQUENTIAL：持久化并且带序列号</li>
<li>EPHEMERAL：临时</li>
<li>EPHEMERAL_SEQUENTIAL：临时并且带序列号</li>
</ul>
<p>增删改查操作如下</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .build();<br>    client.start();<br>    <span class="hljs-comment">// 删除一个节点，并且递归删除其所有的子节点</span><br>    client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/study"</span>);<br>    LOGGER.info(<span class="hljs-string">"清除上一次测试的数据成功！"</span>);<br>&#125;<br><br><span class="hljs-comment">/**<br> * 基本操作<br> * <span class="hljs-doctag">@throws</span> Exception<br> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">"study"</span>)<br>        .build();<br>    client.start();<br>    <span class="hljs-comment">/**<br>     * 创建节点<br>     */</span><br>    <span class="hljs-comment">// 创建一个节点，初始内容为空</span><br>    client.create().forPath(<span class="hljs-string">"/name"</span>);<br>    <span class="hljs-comment">// 创建一个节点，附带初始化内容</span><br>    client.create().forPath(<span class="hljs-string">"/name2"</span>, <span class="hljs-string">"创建一个节点，附带初始化内容"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br>    <span class="hljs-comment">// 创建一个节点，指定创建模式（临时节点），内容为空</span><br>    client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/name3"</span>);<br>    <span class="hljs-comment">// 创建一个节点，指定创建模式（临时节点），附带初始化内容</span><br>    client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/name4"</span>, <span class="hljs-string">"创建一个节点，指定创建模式（临时节点），附带初始化内容"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br>    <span class="hljs-comment">// 创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</span><br>    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/parent/name5"</span>, <span class="hljs-string">"创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br><br>    <span class="hljs-comment">/**<br>     * 更新数据节点数据<br>     */</span><br>    <span class="hljs-comment">// 更新一个节点的数据内容</span><br>    client.setData().forPath(<span class="hljs-string">"/name2"</span>, <span class="hljs-string">"更新一个节点的数据内容"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br>    <span class="hljs-comment">// 更新一个节点的数据内容，强制指定版本进行更新</span><br>    client.setData().withVersion(<span class="hljs-number">0</span>).forPath(<span class="hljs-string">"/name"</span>, <span class="hljs-string">"更新一个节点的数据内容，强制指定版本进行更新"</span>.getBytes(Charset.forName(<span class="hljs-string">"utf-8"</span>)));<br><br>    <span class="hljs-comment">/**<br>     * 读取节点<br>     */</span><br>    <span class="hljs-comment">// 读取一个节点的数据内容</span><br>    String s = <span class="hljs-keyword">new</span> String(client.getData().forPath(<span class="hljs-string">"/name2"</span>), Charset.forName(<span class="hljs-string">"utf-8"</span>));<br>    LOGGER.info(<span class="hljs-string">"读取一个节点的数据内容, s: [&#123;&#125;]"</span>, s);<br>    <span class="hljs-comment">// 读取一个节点的数据内容，同时获取到该节点的stat</span><br>    Stat stat = <span class="hljs-keyword">new</span> Stat();<br>    s = <span class="hljs-keyword">new</span> String(client.getData().storingStatIn(stat).forPath(<span class="hljs-string">"/name"</span>), Charset.forName(<span class="hljs-string">"utf-8"</span>));<br>    LOGGER.info(<span class="hljs-string">"读取一个节点的数据内容，同时获取到该节点的stat, s: [&#123;&#125;], stat: [&#123;&#125;]"</span>, s, stat);<br><br>    <span class="hljs-comment">/**<br>     * 删除节点<br>     */</span><br>    <span class="hljs-comment">// 删除一个节点</span><br>    client.delete().forPath(<span class="hljs-string">"/name"</span>);<br>    <span class="hljs-comment">// 删除一个节点，并且递归删除其所有的子节点</span><br>    client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/parent"</span>);<br><br>    <span class="hljs-comment">/**<br>     * 检查节点是否存在，不存在时对象为 null<br>     */</span><br>    stat = client.checkExists().forPath(<span class="hljs-string">"/name5"</span>);<br>    LOGGER.info(<span class="hljs-string">"检查节点是否存在, stat: [&#123;&#125;]"</span>, stat);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>CuratorFramework的实例包含inTransaction( )接口方法，调用此方法开启一个ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交。一个例子如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">"study"</span>)<br>        .build();<br>    client.start();<br><br>    <span class="hljs-comment">// 事务操作，保证原子性</span><br>    client.inTransaction()<br>        .create().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/name"</span>, <span class="hljs-string">"aaaaa"</span>.getBytes())<br>        .and().setData().forPath(<span class="hljs-string">"/name"</span>, <span class="hljs-string">"bbb"</span>.getBytes())<br>        .and().commit();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h2><p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator提供异步接口，引入了BackgroundCallback接口用于处理异步接口调用之后服务端返回的结果信息。BackgroundCallback接口中一个重要的回调值为CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p>
<p><strong>CuratorEventType</strong></p>
<table>
<thead>
<tr>
<th align="center">事件类型</th>
<th align="center">对应CuratorFramework实例的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CREATE</td>
<td align="center">#create()</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">#delete()</td>
</tr>
<tr>
<td align="center">EXISTS</td>
<td align="center">#checkExists()</td>
</tr>
<tr>
<td align="center">GET_DATA</td>
<td align="center">#getData()</td>
</tr>
<tr>
<td align="center">SET_DATA</td>
<td align="center">#setData()</td>
</tr>
<tr>
<td align="center">CHILDREN</td>
<td align="center">#getChildren()</td>
</tr>
<tr>
<td align="center">SYNC</td>
<td align="center">#sync(String,Object)</td>
</tr>
<tr>
<td align="center">GET_ACL</td>
<td align="center">#getACL()</td>
</tr>
<tr>
<td align="center">SET_ACL</td>
<td align="center">#setACL()</td>
</tr>
<tr>
<td align="center">WATCHED</td>
<td align="center">#Watcher(Watcher)</td>
</tr>
<tr>
<td align="center">CLOSING</td>
<td align="center">#close()</td>
</tr>
</tbody></table>
<p><strong>响应码(#getResultCode())</strong></p>
<table>
<thead>
<tr>
<th align="center">响应码</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">OK，即调用成功</td>
</tr>
<tr>
<td align="center">-4</td>
<td align="center">ConnectionLoss，即客户端与服务端断开连接</td>
</tr>
<tr>
<td align="center">-110</td>
<td align="center">NodeExists，即节点已经存在</td>
</tr>
<tr>
<td align="center">-112</td>
<td align="center">SessionExpired，即会话过期</td>
</tr>
</tbody></table>
<p>一个异步创建节点的例子如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test04App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br><span class="hljs-meta">@Before</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .build();<br>    client.start();<br>    <span class="hljs-comment">// 删除一个节点，并且递归删除其所有的子节点</span><br>    Stat stat = client.checkExists().forPath(<span class="hljs-string">"/study"</span>);<br>    <span class="hljs-keyword">if</span> (stat != <span class="hljs-keyword">null</span>) &#123;<br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/study"</span>);<br>    &#125;<br>    LOGGER.info(<span class="hljs-string">"清除上一次测试的数据成功！"</span>);<br>&#125;<br><br><span class="hljs-comment">/**<br> * 异步操作<br> * <span class="hljs-doctag">@throws</span> Exception<br> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">"study"</span>)<br>        .build();<br>    client.start();<br><br>    Executor executor = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).inBackground(<span class="hljs-keyword">new</span> BackgroundCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(CuratorFramework client, CuratorEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            LOGGER.info(<span class="hljs-string">"开始调用回调方法，WatchedEvent: [&#123;&#125;], ResultCode: [&#123;&#125;]"</span>, event.getType(), event.getResultCode());<br>        &#125;<br>    &#125;, executor).forPath(<span class="hljs-string">"/name"</span>);<br><br>    <span class="hljs-comment">// 不让程序结束，否则看不到回调方法的调用</span><br>    <span class="hljs-keyword">for</span> (;;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><b>注意：</b>如果#inBackground()方法不指定executor，那么会默认使用Curator的EventThread去进行异步处理。</p>
<h1 id="Curator-高级特性"><a href="#Curator-高级特性" class="headerlink" title="Curator 高级特性"></a>Curator 高级特性</h1><p><b>提醒：</b>强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，curator-recipes下的所有Api将会失效或者过期，尽管后面所有的例子都没有使用到ConnectionStateListener。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Zookeeper原生支持通过注册Watcher来进行事件监听，但是开发者需要反复注册(Watcher只能单次注册单次使用)。Cache是Curator中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听。Curator提供了三种Watcher(Cache)来监听结点的变化。</p>
<h3 id="Path-Cache"><a href="#Path-Cache" class="headerlink" title="Path Cache"></a>Path Cache</h3><p>Path Cache用来监控一个ZNode的子节点. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过PathChildrenCacheListener通知。</p>
<p>实际使用时会涉及到四个类：</p>
<ul>
<li>PathChildrenCache</li>
<li>PathChildrenCacheEvent</li>
<li>PathChildrenCacheListener</li>
<li>ChildData</li>
</ul>
<p>通过下面的构造函数创建Path Cache:</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathChildrenCache</span><span class="hljs-params">(CuratorFramework client, String path, <span class="hljs-keyword">boolean</span> cacheData)</span></span><br></code></pre></td></tr></table></figure>

<p>想使用cache，必须调用它的start方法，使用完后调用close方法。 可以设置StartMode来实现启动的模式。</p>
<p>StartMode有下面几种：</p>
<ol>
<li>NORMAL：正常初始化。</li>
<li>BUILD_INITIAL_CACHE：在调用start()之前会调用rebuild()。</li>
<li>POST_INITIALIZED_EVENT： 当Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件。</li>
</ol>
<p><code>public void addListener(PathChildrenCacheListener listener)</code>可以增加listener监听缓存的变化。</p>
<p><code>getCurrentData()</code>方法返回一个List<code>&lt;ChildData&gt;</code>对象，可以遍历所有的子节点。</p>
<p>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作，案例如下代码所示：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.*;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 10:31<br> * <span class="hljs-doctag">@description</span> Test05App, Curator 高级特性案例<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test05App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test05App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建客户端 CuratorFramework 对象</span><br>        CuratorFramework client = CuratorFrameworkFactory.builder()<br>                .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>                .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .build();<br>        <span class="hljs-comment">// 连接 zookeeper服务器</span><br>        client.start();<br>        <span class="hljs-comment">// 创建一个 PathChildrenCache 对象来监听对应路径下的的子节点</span><br>        PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache (client, <span class="hljs-string">"/example/cache"</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 开始监听子节点变化</span><br>        pathChildrenCache.start();<br>        <span class="hljs-comment">// 当子节点数据变化时需要处理的逻辑</span><br>        pathChildrenCache.getListenable().addListener((clientFramework, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"事件类型为：&#123;&#125;"</span>, event.getType());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != event.getData()) &#123;<br>                LOGGER.info(<span class="hljs-string">"节点路径为：&#123;&#125;，节点数据为：&#123;&#125;"</span>, event.getData().getPath(), <span class="hljs-keyword">new</span> String(event.getData().getData()));<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache/test01"</span>, <span class="hljs-string">"01"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache/test02"</span>, <span class="hljs-string">"02"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache/test01"</span>, <span class="hljs-string">"01_V2"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 遍历缓存中的数据</span><br>        <span class="hljs-keyword">for</span> (ChildData childData : pathChildrenCache.getCurrentData()) &#123;<br>            LOGGER.info(<span class="hljs-string">"获取childData对象数据, Path: [&#123;&#125;], Data: [&#123;&#125;]"</span>, childData.getPath(), <span class="hljs-keyword">new</span> String(childData.getData()));<br>        &#125;<br><br>        <span class="hljs-comment">// 删除数据</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache/test01"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 删除数据</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache/test02"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 关闭监听</span><br>        pathChildrenCache.close();<br><br>        <span class="hljs-comment">// 删除测试用的数据，如果存在子节点，一并删除</span><br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/example"</span>);<br><br>        <span class="hljs-comment">// 断开与 zookeeper 的连接</span><br>        client.close();<br>        LOGGER.info(<span class="hljs-string">"程序执行完毕"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><b>注意：</b>如果new PathChildrenCache(client, PATH, true)中的参数cacheData值设置为false，则示例中的event.getData().getData()、data.getData()将返回null，cache将不会缓存节点数据。</p>
<p><b>注意：</b>示例中的TimeUnit.MILLISECONDS.sleep(10)可以注释掉，但是注释后事件监听的触发次数会不全，这可能与PathCache的实现原理有关，不能太过频繁的触发事件！</p>
<h3 id="Node-Cache"><a href="#Node-Cache" class="headerlink" title="Node Cache"></a>Node Cache</h3><p>Node Cache与Path Cache类似，Node Cache只是监听某一个特定的节点。它涉及到下面的三个类：</p>
<ul>
<li>NodeCache - Node Cache实现类</li>
<li>NodeCacheListener - 节点监听器</li>
<li>ChildData - 节点数据</li>
</ul>
<p><b>注意：</b>使用cache，依然要调用它的start()方法，使用完后调用close()方法。</p>
<p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.ChildData;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 11:19<br> * <span class="hljs-doctag">@description</span> Test06App, Curator 高级特性 Node Cache<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test06App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test06App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建客户端 CuratorFramework 对象</span><br>        CuratorFramework client = CuratorFrameworkFactory.builder()<br>                .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>                .build();<br><br>        <span class="hljs-comment">// 连接 zookeeper服务器</span><br>        client.start();<br><br>        <span class="hljs-comment">// 创建一个 NodeCache 对象来监听指定节点</span><br>        NodeCache nodeCache = <span class="hljs-keyword">new</span> NodeCache(client, <span class="hljs-string">"/example/cache"</span>);<br>        <span class="hljs-comment">// 当节点数据变化时需要处理的逻辑</span><br>        nodeCache.getListenable().addListener(() -&gt; &#123;<br>            ChildData currentData = nodeCache.getCurrentData();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != currentData) &#123;<br>                LOGGER.info(<span class="hljs-string">"节点数据：Path[&#123;&#125;], Data: [&#123;&#125;]"</span>,currentData.getPath() , <span class="hljs-keyword">new</span> String(currentData.getData()));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LOGGER.info(<span class="hljs-string">"节点被删除！"</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 开始监听子节点变化</span><br>        nodeCache.start();<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01_V1"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 获取节点数据</span><br>        String s = <span class="hljs-keyword">new</span> String(client.getData().forPath(<span class="hljs-string">"/example/cache"</span>));<br>        LOGGER.info(<span class="hljs-string">"数据s：[&#123;&#125;]"</span>, s);<br><br>        <span class="hljs-comment">// 删除节点</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 删除测试用的数据，如果存在子节点，一并删除</span><br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/example"</span>);<br><br>        <span class="hljs-comment">// 关闭监听</span><br>        nodeCache.close();<br><br>        <span class="hljs-comment">// 断开与 zookeeper 的连接</span><br>        client.close();<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！"</span>);<br><br>        <span class="hljs-comment">// 为了查看打印日志，不加这段代码看不到节点监听处理逻辑</span><br>        <span class="hljs-keyword">for</span> (;;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><b>注意：</b>示例中的TimeUnit.MILLISECONDS.sleep(100)可以注释，但是注释后事件监听的触发次数会不全，这可能与NodeCache的实现原理有关，不能太过频繁的触发事件！</p>
<p><b>注意：</b>NodeCache只能监听一个节点的状态变化。</p>
<h3 id="Tree-Cache"><a href="#Tree-Cache" class="headerlink" title="Tree Cache"></a>Tree Cache</h3><p>Tree Cache可以监控整个树上的所有节点，类似于PathCache和NodeCache的组合，主要涉及到下面四个类：</p>
<ul>
<li>TreeCache - Tree Cache实现类</li>
<li>TreeCacheListener - 监听器类</li>
<li>TreeCacheEvent - 触发的事件类</li>
<li>ChildData - 节点数据</li>
</ul>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCache;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 11:45<br> * <span class="hljs-doctag">@description</span> Test07App, Curator 高级特性 Tree Cache<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test07App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test07App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建客户端 CuratorFramework 对象</span><br>        CuratorFramework client = CuratorFrameworkFactory.builder()<br>                .connectionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .connectString(<span class="hljs-string">"127.0.0.1:2181"</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">5000</span>)<br>                .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>                .build();<br><br>        <span class="hljs-comment">// 连接 zookeeper服务器</span><br>        client.start();<br><br>        <span class="hljs-comment">// 创建一个 NodeCache 对象来监听指定节点下的所有节点</span><br>        TreeCache treeCache = <span class="hljs-keyword">new</span> TreeCache(client, <span class="hljs-string">"/example/cache"</span>);<br>        <span class="hljs-comment">// 当指定节点下的某个节点数据变化时需要处理的逻辑</span><br>        treeCache.getListenable().addListener((curatorFramework, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"事件类型：&#123;&#125;， 路径：&#123;&#125;，数据：&#123;&#125;"</span>,<br>                    event.getType(),<br>                    event.getData() == <span class="hljs-keyword">null</span>? <span class="hljs-keyword">null</span>:event.getData().getPath(),<br>                    event.getData() == <span class="hljs-keyword">null</span>? <span class="hljs-keyword">null</span>:<span class="hljs-keyword">new</span> String(event.getData().getData()));<br>        &#125;);<br><br>        <span class="hljs-comment">// 开始监听指定节点下的所有节点变化</span><br>        treeCache.start();<br><br>        <span class="hljs-comment">// 创建节点</span><br>        client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01_V2"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 修改数据</span><br>        client.setData().forPath(<span class="hljs-string">"/example/cache"</span>, <span class="hljs-string">"test01_V3"</span>.getBytes());<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 删除节点</span><br>        client.delete().forPath(<span class="hljs-string">"/example/cache"</span>);<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 删除测试用的数据，如果存在子节点，一并删除</span><br>        client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/example"</span>);<br><br>        <span class="hljs-comment">// 关闭监听</span><br>        treeCache.close();<br><br>        <span class="hljs-comment">// 断开与 zookeeper 的连接</span><br>        client.close();<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！"</span>);<br><br>        <span class="hljs-comment">// 为了查看打印日志，不加这段代码看不到节点监听处理逻辑</span><br>        <span class="hljs-keyword">for</span> (;;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><b>注意：</b>在此示例中没有使用TimeUnit.MILLISECONDS.sleep(100)，但是事件触发次数也是正常的。</p>
<p><b>注意：</b>TreeCache在初始化(调用start()方法)的时候会回调TreeCacheListener实例一个事TreeCacheEvent，而回调的TreeCacheEvent对象的Type为INITIALIZED，ChildData为null，此时event.getData().getPath()很有可能导致空指针异常，这里应该主动处理并避免这种情况。</p>
<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>使用场景如下，当我们的某些功能要提供高可用时，比如，服务器突然崩溃了，导致功能不能访问，这时就可以把该功能部署到多台机器上，但是并不是让这些机器上的功能同时对外提供服务，而是选一台机器上的功能对外提供服务，其他机器上的功能用作备用，当正在对外提供服务的机器出现故障时，我们就执行 Leader 选举，再选择一台机器来对外提供服务，这样就保证了服务的高可用。</p>
<p>Curator 有两种 leader 选举的方式,分别是<strong>LeaderSelector</strong>和<strong>LeaderLatch</strong>。</p>
<h3 id="LeaderLatch"><a href="#LeaderLatch" class="headerlink" title="LeaderLatch"></a>LeaderLatch</h3><p>LeaderLatch有两个构造函数：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderLatch</span><span class="hljs-params">(CuratorFramework client, String latchPath)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderLatch</span><span class="hljs-params">(CuratorFramework client, String latchPath,  String id)</span></span><br></code></pre></td></tr></table></figure>

<p>LeaderLatch的启动：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">leaderLatch.start( );<br></code></pre></td></tr></table></figure>

<p>一旦启动，LeaderLatch 会和其它使用相同<code>latchPath</code>的其它 LeaderLatch 交涉，然后其中一个最终会被选举为leader，可以通过<code>leaderLatch.hasLeadership()</code>方法查看LeaderLatch实例是否leader,<code>true</code>说明当前实例是leader。</p>
<p><b>异常处理：</b> LeaderLatch实例可以增加ConnectionStateListener来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader不再认为自己还是leader。当LOST后连接重连后RECONNECTED,LeaderLatch会删除先前的ZNode然后重新创建一个。LeaderLatch用户必须考虑导致leadership丢失的连接问题。 强烈推荐你使用ConnectionStateListener。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderLatch;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderLatchListener;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 15:11<br> * <span class="hljs-doctag">@description</span> Test08App, Curator 高级特性 leader 选举<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test08App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test08App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-comment">/**<br>     * 使用 LeaderLatch<br>     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;CuratorFramework&gt; clientList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;LeaderLatch&gt; leaderLatchList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>            clientList.add(client);<br><br>            <span class="hljs-keyword">final</span> LeaderLatch latch = <span class="hljs-keyword">new</span> LeaderLatch(client, <span class="hljs-string">"/francis/leader"</span>, <span class="hljs-string">"#client"</span> + i);<br>            latch.addListener(<span class="hljs-keyword">new</span> LeaderLatchListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isLeader</span><span class="hljs-params">()</span> </span>&#123;<br>                    LOGGER.info(<span class="hljs-string">"I am Leader, id: [&#123;&#125;]"</span>, latch.getId());<br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notLeader</span><span class="hljs-params">()</span> </span>&#123;<br>                    LOGGER.info(<span class="hljs-string">"I am not Leader, id: [&#123;&#125;]"</span>, latch.getId());<br>                &#125;<br>            &#125;);<br>            leaderLatchList.add(latch);<br><br>            client.start();<br>            latch.start();<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"程序停止10秒开始"</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>        LOGGER.info(<span class="hljs-string">"程序停止10秒结束"</span>);<br><br>        LeaderLatch currentLatch = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (LeaderLatch latch : leaderLatchList) &#123;<br>            <span class="hljs-keyword">if</span> (latch.hasLeadership()) &#123;<br>                currentLatch = latch;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        LOGGER.info(<span class="hljs-string">"current leader is &#123;&#125;"</span>, currentLatch.getId());<br>        currentLatch.close();<br>        LOGGER.info(<span class="hljs-string">"release the leader &#123;&#125;"</span>, currentLatch.getId());<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">for</span> (LeaderLatch latch : leaderLatchList) &#123;<br>            <span class="hljs-keyword">if</span> (latch.hasLeadership()) &#123;<br>                currentLatch = latch;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        LOGGER.info(<span class="hljs-string">"current leader is &#123;&#125;"</span>, currentLatch.getId());<br>        currentLatch.close();<br>        LOGGER.info(<span class="hljs-string">"release the leader &#123;&#125;"</span>, currentLatch.getId());<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">for</span> (LeaderLatch latch : leaderLatchList) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != latch.getState() &amp;&amp; !latch.getState().equals(LeaderLatch.State.CLOSED)) &#123;<br>                CloseableUtils.closeQuietly(latch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (CuratorFramework client : clientList) &#123;<br>            CloseableUtils.closeQuietly(client);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先我们创建了5个LeaderLatch，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。<br>通过hasLeadership查看自己是否是leader， 如果是的话返回true。<br>可以通过.getLeader().getId()可以得到当前的leader的ID。<br>只能通过close释放当前的领导权。</p>
<h3 id="LeaderSelector"><a href="#LeaderSelector" class="headerlink" title="LeaderSelector"></a>LeaderSelector</h3><p>LeaderSelector使用的时候主要涉及下面几个类：</p>
<ul>
<li>LeaderSelector</li>
<li>LeaderSelectorListener</li>
<li>LeaderSelectorListenerAdapter</li>
<li>CancelLeadershipException</li>
</ul>
<p>核心类是LeaderSelector，它的构造函数如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderSelector</span><span class="hljs-params">(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderSelector</span><span class="hljs-params">(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)</span></span><br></code></pre></td></tr></table></figure>

<p>类似LeaderLatch,LeaderSelector必须start: <code>leaderSelector.start();</code> 一旦启动，当实例取得领导权时你的listener的takeLeadership()方法被调用。当这个方法执行完后，该实例就会放弃 leader 的执行权。</p>
<p><b>注意：</b>当你不再使用LeaderSelector实例时，应该调用它的close方法。</p>
<p>示例代码如下，推荐继承 LeaderSelectorListenerAdapter 类并实现 Closeable 接口：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.io.Closeable;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/25 17:10<br> * <span class="hljs-doctag">@description</span> Test09App, Curator 高级特性 leader 选举<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test09App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test09App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;CuratorFramework&gt; clients = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;LeaderSelectorAdapter&gt; examples = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>,<br>                    <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">20000</span>, <span class="hljs-number">3</span>));<br>            clients.add(client);<br>            LeaderSelectorAdapter selectorAdapter = <span class="hljs-keyword">new</span> LeaderSelectorAdapter(client, <span class="hljs-string">"/francis/leader"</span>, <span class="hljs-string">"Client #"</span> + i);<br>            examples.add(selectorAdapter);<br>            <span class="hljs-comment">// 连接 zookeeper 服务器</span><br>            client.start();<br>            <span class="hljs-comment">// 开始执行 leader 选举</span><br>            selectorAdapter.start();<br>        &#125;<br><br>        <span class="hljs-comment">// 测试完毕后，关闭选举和会话</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">30</span>);<br>        LOGGER.info(<span class="hljs-string">"开始回收数据了哦！"</span>);<br>        <span class="hljs-keyword">for</span> (LeaderSelectorAdapter example : examples) &#123;<br>            CloseableUtils.closeQuietly(example);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (CuratorFramework client : clients) &#123;<br>            CloseableUtils.closeQuietly(client);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeaderSelectorAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LeaderSelectorListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LeaderSelector leaderSelector;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger leaderCount = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaderSelectorAdapter</span><span class="hljs-params">(CuratorFramework client, String path, String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.leaderSelector = <span class="hljs-keyword">new</span> LeaderSelector(client, path, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-comment">// 希望一个 selector 放弃 leader 后还要重新参与leader选举</span><br>            <span class="hljs-keyword">this</span>.leaderSelector.autoRequeue();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            leaderSelector.start();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            leaderSelector.close();<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 当某个实例成为 leader 后就会执行这个方法，当这个方法执行完后，该实例就会放弃 leader 的执行权。<br>         * <span class="hljs-doctag">@param</span> client<br>         * <span class="hljs-doctag">@throws</span> Exception<br>         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeLeadership</span><span class="hljs-params">(CuratorFramework client)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> waitSeconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">5</span>);<br>            LOGGER.info(<span class="hljs-string">"&#123;&#125; 现在是 leader，接下来我会一直当 leader &#123;&#125; 秒钟，除开这一次，我已经当过 &#123;&#125; 次 leader 了！"</span>, name, waitSeconds, leaderCount.getAndIncrement());<br>            TimeUnit.SECONDS.sleep(waitSeconds);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么推荐继承 LeaderSelectorListenerAdapter 类来实现 leader 选举？</strong></p>
<p>查看 LeaderSelectorListenerAdapter 源代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Licensed to the Apache Software Foundation (ASF) under one<br> * or more contributor license agreements.  See the NOTICE file<br> * distributed with this work for additional information<br> * regarding copyright ownership.  The ASF licenses this file<br> * to you under the Apache License, Version 2.0 (the<br> * "License"); you may not use this file except in compliance<br> * with the License.  You may obtain a copy of the License at<br> *<br> *   http://www.apache.org/licenses/LICENSE-2.0<br> *<br> * Unless required by applicable law or agreed to in writing,<br> * software distributed under the License is distributed on an<br> * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br> * KIND, either express or implied.  See the License for the<br> * specific language governing permissions and limitations<br> * under the License.<br> */</span><br><span class="hljs-keyword">package</span> org.apache.curator.framework.recipes.leader;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><br><span class="hljs-comment">/**<br> * An implementation of &#123;<span class="hljs-doctag">@link</span> LeaderSelectorListener&#125; that adds the recommended handling<br> * for connection state problems<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeaderSelectorListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LeaderSelectorListener</span><br></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( (newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST) )<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CancelLeadershipException();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的意思就是，如果当前实例发生SUSPENDED（暂停）或者LOST（丢失）连接问题，最好直接抛CancelLeadershipException，此时，leaderSelector实例会尝试中断并且取消正在执行takeLeadership（）方法的线程。</p>
<p>看 org.apache.curator.framework.recipes.leader.LeaderSelector 如下代码：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        listener.stateChanged(client, newState);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> ( CancelLeadershipException dummy )<br>    &#123;<br>        leaderSelector.interruptLeadership();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过 debug 调试，当程序抛出 CancelLeadershipException 异常时会执行方法 <code>leaderSelector.interruptLeadership();</code>，该方法的作用就是让该实例放弃 leader 执行权。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p>
<h3 id="可重入共享锁-Shared-Reentrant-Lock"><a href="#可重入共享锁-Shared-Reentrant-Lock" class="headerlink" title="可重入共享锁 Shared Reentrant Lock"></a>可重入共享锁 Shared Reentrant Lock</h3><p><strong>Shared意味着锁是全局可见的</strong>， 客户端都可以请求锁。 Reentrant和JDK的ReentrantLock类似，即可重入， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。 它是由类InterProcessMutex来实现。 它的构造函数为：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path)</span></span><br></code></pre></td></tr></table></figure>

<p>通过<code>acquire()</code>获得锁，并提供超时机制：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time,TimeUnit unit)</span></span>;<br></code></pre></td></tr></table></figure>

<p>通过<code>release()</code>方法释放锁。 InterProcessMutex 实例可以重用。</p>
<p><b>特别提醒：</b>错误处理 还是强烈推荐你使用 ConnectionStateListener 处理连接状态的改变。 当连接LOST时你不再拥有锁。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/26 14:04<br> * <span class="hljs-doctag">@description</span> Test10App<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test10App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test10App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建需要共享的资源对象</span><br>        <span class="hljs-keyword">final</span> FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        <span class="hljs-comment">// 创建线程池对象</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">final</span> ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    client.start();<br>                    InterProcessMutexDemo mutexDemo = <span class="hljs-keyword">new</span> InterProcessMutexDemo(client, <span class="hljs-string">"/examples/locks"</span>, resource, <span class="hljs-string">"我是客户端: "</span> + index);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                        mutexDemo.doWork(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序出现异常！"</span>, e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 关闭会话</span><br>                    CloseableUtils.closeQuietly(client);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br><br>            <span class="hljs-comment">// 交给线程池执行</span><br>            executorService.submit(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 当线程池中的所有任务执行完后，关闭线程池</span><br>        executorService.shutdown();<br><br>        <span class="hljs-comment">// 等待除主线程外其他线程都执行完毕</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 锁<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterProcessMutexDemo</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> InterProcessMutex lock;<br>        <span class="hljs-keyword">private</span> FakeLimitedResource resource;<br>        <span class="hljs-keyword">private</span> String clientName;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMutexDemo</span><span class="hljs-params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> InterProcessMutex(client, lockPath);<br>            <span class="hljs-keyword">this</span>.resource = resource;<br>            <span class="hljs-keyword">this</span>.clientName = clientName;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-comment">/*try &#123;<br>                // 如果获取不到锁<br>                LOGGER.info("&#123;&#125;， 第一次加锁", this.clientName);<br>                if (!lock.acquire(time, unit)) &#123;<br>                    throw new RuntimeException(this.clientName + "，第一次获取锁失败！");<br>                &#125;<br><br>                // 第二次获取锁测试可重入性<br>                try &#123;<br>                    LOGGER.info("&#123;&#125;， 第二次加锁", this.clientName);<br>                    if (!lock.acquire(time, unit)) &#123;<br>                        throw new RuntimeException(this.clientName + "，第二次获取锁失败！");<br>                    &#125;<br>                    LOGGER.info("&#123;&#125; 获取到了锁！", this.clientName);<br>                    resource.use();<br>                &#125; finally &#123;<br>                    LOGGER.info("&#123;&#125; 资源使用完毕，释第二次加的锁！", this.clientName);<br>                    lock.release();<br>                &#125;<br><br>                LOGGER.info("&#123;&#125; 获取到了锁！", this.clientName);<br>                resource.use();<br>            &#125; finally &#123;<br>                LOGGER.info("&#123;&#125; 资源使用完毕，释第一次加的锁！", this.clientName);<br>                lock.release();<br>            &#125;*/</span><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果获取不到锁</span><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125;， 第一次加锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, unit)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-keyword">this</span>.clientName + <span class="hljs-string">"，第一次获取锁失败！"</span>);<br>                &#125;<br><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125;， 第二次加锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, unit)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-keyword">this</span>.clientName + <span class="hljs-string">"，第二次获取锁失败！"</span>);<br>                &#125;<br><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 获取到了锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                resource.use();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 资源使用完毕，释第一次加的锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                lock.release();<br>                lock.release();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><b>这里有个地方特别注意：</b>在上面的示例代码中，加多少次锁就要释放几次锁，不然在下次获取锁的时候就会高概率的抛异常。原因是 Curator 的分布式锁机制导致的，它创建的 zookeeper 节点的类型是<strong>临时顺序</strong>节点，而在获取节点的时候会先获取最先创建（序号最小）的节点。如果加 n 次锁过后没有释放 n 次锁，那么这个节点就依然还存活在 zookeeper 节点中，因此导致其他线程获取其他节点（序号不是最小的节点）时就获取不到锁，获取不了锁就会抛异常。之所以说是高概率而不是绝对，是因为在上面示例代码中是多线程环境，在代码中有这样一段代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关闭会话</span><br>CloseableUtils.closeQuietly(client);<br></code></pre></td></tr></table></figure>

<p>所以当某个线程的客户端被关闭后，也相当于 zookeeper 中对应的节点也没有了，自然另外的线程就能获取到锁了。</p>
<p>这个代码我研究了好久，各种猜测，最后 debug 才明白是怎么回事，所以特地记录在此！</p>
<h3 id="不可重入共享锁-Shared-Lock"><a href="#不可重入共享锁-Shared-Lock" class="headerlink" title="不可重入共享锁 Shared Lock"></a>不可重入共享锁 Shared Lock</h3><p>这个锁和上面的 InterProcessMutex 相比，就是少了 Reentrant 的功能，也就意味着它不能在同一个线程中重入。这个类是 <code>InterProcessSemaphoreMutex</code> ,使用方法和 <code>InterProcessMutex</code> 类似。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/27 14:43<br> * <span class="hljs-doctag">@description</span> Test11App, Curator 高级特性——不可重入共享锁 示例代码<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test11App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test11App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 创建共享资源对象</span><br>        <span class="hljs-keyword">final</span> FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        <span class="hljs-comment">// 创建线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 重试策略对象</span><br>        <span class="hljs-keyword">final</span> ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Runnable task = () -&gt; &#123;<br>                CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    client.start();<br>                    InterProcessSemaphoreMutexDemo mutexDemo = <span class="hljs-keyword">new</span> InterProcessSemaphoreMutexDemo(client, <span class="hljs-string">"/examples/locks"</span>, resource, <span class="hljs-string">"客户端"</span> + index);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>                        mutexDemo.doWork(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    CloseableUtils.closeQuietly(client);<br>                &#125;<br>            &#125;;<br><br>            <span class="hljs-comment">// 交给线程池执行</span><br>            executorService.submit(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 当线程池中的所有任务执行完后，关闭线程池</span><br>        executorService.shutdown();<br>        <span class="hljs-comment">// 等待除主线程外其他线程都执行完毕</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterProcessSemaphoreMutexDemo</span> </span>&#123;<br><br>        <span class="hljs-comment">/**<br>         * 不可重入贡献锁对象<br>         */</span><br>        <span class="hljs-keyword">private</span> InterProcessSemaphoreMutex lock;<br>        <span class="hljs-comment">/**<br>         * 共享资源对象<br>         */</span><br>        <span class="hljs-keyword">private</span> FakeLimitedResource resource;<br>        <span class="hljs-comment">/**<br>         * 客户端名称<br>         */</span><br>        <span class="hljs-keyword">private</span> String clientName;<br><br>        <span class="hljs-comment">/**<br>         * <span class="hljs-doctag">@param</span> client 连接 zookeeper 的客户端对象<br>         * <span class="hljs-doctag">@param</span> lockPath 锁路径<br>         * <span class="hljs-doctag">@param</span> resource 共享资源对象<br>         * <span class="hljs-doctag">@param</span> clientName 客户名称<br>         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessSemaphoreMutexDemo</span><span class="hljs-params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> InterProcessSemaphoreMutex(client, lockPath);<br>            <span class="hljs-keyword">this</span>.resource = resource;<br>            <span class="hljs-keyword">this</span>.clientName = clientName;<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 业务功能<br>         * <span class="hljs-doctag">@param</span> time<br>         * <span class="hljs-doctag">@param</span> unit<br>         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 第一次获取锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, unit)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 第一次没有获取到锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 这个示例代码是不可重入锁，所以这里会获取不了锁</span><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 第二次获取锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!lock.acquire(time, TimeUnit.SECONDS)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 第二次没有获取到锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 获取到了锁，马上开始使用资源！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">this</span>.resource.use();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOGGER.error(<span class="hljs-string">"业务功能发生了异常！"</span>, e);<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 业务功能处理完了，马上开始释放锁！"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                    <span class="hljs-keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;<br>                        lock.release();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;<br>                        lock.release();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.info(<span class="hljs-string">"释放锁发生了异常！"</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行后发现，有且只有一个 client 成功获取第一个锁(第一个 acquire() 方法返回 true )，然后它自己阻塞在第二个 acquire() 方法，获取第二个锁失败，方法返回 false。这样也就验证了 <code>InterProcessSemaphoreMutex</code> 实现的锁是不可重入的。</p>
<h3 id="可重入读写锁-Shared-Reentrant-Read-Write-Lock"><a href="#可重入读写锁-Shared-Reentrant-Read-Write-Lock" class="headerlink" title="可重入读写锁 Shared Reentrant Read Write Lock"></a>可重入读写锁 Shared Reentrant Read Write Lock</h3><p>类似JDK的<strong>ReentrantReadWriteLock</strong>。一个读写锁管理一对相关的锁。一个负责读操作，另外一个负责写操作。读操作在写锁没被使用时可同时由多个进程使用，而写锁在使用时不允许读(阻塞)。</p>
<p>此锁是可重入的。<strong>一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁</strong>。这也意味着<strong>写锁可以降级成读锁， 比如请求写锁 —&gt;请求读锁—&gt;释放读锁 —-&gt;释放写锁</strong>。从读锁升级成写锁是不行的。</p>
<p>可重入读写锁主要由两个类实现：<code>InterProcessReadWriteLock</code>、<code>InterProcessMutex</code>。使用时首先创建一个<code>InterProcessReadWriteLock</code>实例，然后再根据你的需求得到读锁或者写锁，读写锁的类型是<code>InterProcessMutex</code>。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 13:59<br> * <span class="hljs-doctag">@description</span> Test12App, 可重入读写锁 Shared Reentrant Read Write Lock<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test12App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test12App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">final</span> FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Runnable task = () -&gt; &#123;<br>                <span class="hljs-keyword">final</span> CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>, retry);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    client.start();<br>                    ReentrantReadWriteLockDemo demo = <span class="hljs-keyword">new</span> ReentrantReadWriteLockDemo(client, <span class="hljs-string">"/examples/locks"</span>, resource, <span class="hljs-string">"客户端"</span> + index);<br>                    demo.doWork(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    CloseableUtils.closeQuietly(client);<br>                &#125;<br>            &#125;;<br>            executorService.execute(task);<br>        &#125;<br><br>        executorService.shutdown();<br><br>        executorService.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantReadWriteLockDemo</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessReadWriteLock lock;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessMutex readLock;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessMutex writeLock;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FakeLimitedResource resource;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String clientName;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantReadWriteLockDemo</span><span class="hljs-params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> InterProcessReadWriteLock(client, lockPath);<br>            <span class="hljs-keyword">this</span>.readLock = <span class="hljs-keyword">this</span>.lock.readLock();<br>            <span class="hljs-keyword">this</span>.writeLock = <span class="hljs-keyword">this</span>.lock.writeLock();<br>            <span class="hljs-keyword">this</span>.resource = resource;<br>            <span class="hljs-keyword">this</span>.clientName = clientName;<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 业务功能<br>         * <span class="hljs-doctag">@param</span> time<br>         * <span class="hljs-doctag">@param</span> unit<br>         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.writeLock.acquire(time, unit)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 不能获取到写锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                &#125;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 已得到写锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.readLock.acquire(time, unit)) &#123;<br>                    LOGGER.info(<span class="hljs-string">"&#123;&#125; 不能获取到读锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br>                &#125;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 已得到读锁"</span>, <span class="hljs-keyword">this</span>.clientName);<br><br>                LOGGER.info(<span class="hljs-string">"开始使用共享资源"</span>);<br>                resource.use();<br>                LOGGER.info(<span class="hljs-string">"共享资源使用完毕"</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOGGER.error(<span class="hljs-string">"public void doWork(long time, TimeUnit unit) 方法发生异常！"</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    LOGGER.info(<span class="hljs-string">"业务处理完毕，开始释放锁"</span>);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readLock.isAcquiredInThisProcess()) &#123;<br>                        <span class="hljs-keyword">this</span>.readLock.release();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.writeLock.isAcquiredInThisProcess()) &#123;<br>                        <span class="hljs-keyword">this</span>.writeLock.release();<br>                    &#125;<br>                    LOGGER.info(<span class="hljs-string">"锁释放成功！"</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"public void doWork(long time, TimeUnit unit) 方法释放锁发生异常！"</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="信号量-Shared-Semaphore"><a href="#信号量-Shared-Semaphore" class="headerlink" title="信号量 Shared Semaphore"></a>信号量 Shared Semaphore</h3><p>一个计数的信号量类似JDK的Semaphore。 JDK中Semaphore维护的一组许可(<strong>permits</strong>)，而Curator中称之为租约(<strong>Lease</strong>)。 有两种方式可以决定semaphore的最大租约数。第一种方式是用户给定path并且指定最大LeaseSize。第二种方式用户给定path并且使用<code>SharedCountReader</code>类。<strong>如果不使用SharedCountReader, 必须保证所有实例在多进程中使用相同的(最大)租约数量,否则有可能出现A进程中的实例持有最大租约数量为10，但是在B进程中持有的最大租约数量为20，此时租约的意义就失效了。</strong></p>
<p>这次调用<code>acquire()</code>会返回一个租约对象。 客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。 租约还可以通过下面的方式返还：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnAll</span><span class="hljs-params">(Collection&lt;Lease&gt; leases)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnLease</span><span class="hljs-params">(Lease lease)</span></span><br></code></pre></td></tr></table></figure>

<p>注意你可以一次性请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Lease <span class="hljs-title">acquire</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> Collection&lt;Lease&gt; <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> qty)</span><br><span class="hljs-keyword">public</span> Lease <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span><br><span class="hljs-keyword">public</span> Collection&lt;Lease&gt; <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> qty, <span class="hljs-keyword">long</span> time, TimeUnit unit)</span></span><br></code></pre></td></tr></table></figure>

<p>Shared Semaphore使用的主要类包括下面几个：</p>
<ul>
<li>InterProcessSemaphoreV2</li>
<li>Lease</li>
<li>SharedCountReader</li>
</ul>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.Lease;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 14:55<br> * <span class="hljs-doctag">@description</span> Test13App, 信号量—Shared Semaphore<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test13App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test13App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        ExponentialBackoffRetry retry = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, retry);<br>        client.start();<br><br>        <span class="hljs-comment">// 定义信号量变量，最大租约为 10</span><br>        InterProcessSemaphoreV2 semaphore = <span class="hljs-keyword">new</span> InterProcessSemaphoreV2(client, <span class="hljs-string">"/examples/locks"</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 获取 5 个租约</span><br>        Collection&lt;Lease&gt; leases = semaphore.acquire(<span class="hljs-number">5</span>);<br>        LOGGER.info(<span class="hljs-string">"leases 租约数量为：&#123;&#125;"</span>, leases.size());<br><br>        <span class="hljs-comment">// 获取 1 个租约</span><br>        Lease lease = semaphore.acquire();<br>        LOGGER.info(<span class="hljs-string">"lease: [&#123;&#125;]"</span>, lease);<br><br>        <span class="hljs-comment">// 使用共享资源</span><br>        resource.use();<br><br>        <span class="hljs-comment">// 在 6 秒内获取 5 个租约，如果获取不了就返回 null</span><br>        Collection&lt;Lease&gt; leases2 = semaphore.acquire(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (leases2 != <span class="hljs-keyword">null</span>) &#123;<br>            LOGGER.info(<span class="hljs-string">"leases2 租约数量为：&#123;&#125;"</span>, leases2.size());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LOGGER.info(<span class="hljs-string">"在 6 秒内没有获取到 5 个租约，所以 leases2 为 null"</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 把使用的租约还给 semaphore</span><br>        semaphore.returnLease(lease);<br>        semaphore.returnAll(leases);<br>        <span class="hljs-keyword">if</span> (leases2 != <span class="hljs-keyword">null</span>) &#123;<br>            semaphore.returnAll(leases2);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先我们先获得了5个租约， 最后我们把它还给了semaphore。 接着请求了一个租约，因为semaphore还有5个租约，所以请求可以满足，返回一个租约，还剩4个租约。 然后再请求一个租约，因为租约不够，<strong>阻塞到超时，还是没能满足，返回结果为null(租约不足会阻塞到超时，然后返回null，不会主动抛出异常；如果不设置超时时间，会一致阻塞)。</strong></p>
<h3 id="多共享锁对象-Multi-Shared-Lock"><a href="#多共享锁对象-Multi-Shared-Lock" class="headerlink" title="多共享锁对象 Multi Shared Lock"></a>多共享锁对象 Multi Shared Lock</h3><p>Multi Shared Lock是一个锁的容器。 当调用<code>acquire()</code>， 所有的锁都会被<code>acquire()</code>，如果请求失败，所有的锁都会被release。 同样调用release时所有的锁都被release(<strong>失败被忽略</strong>)。 基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p>
<p>主要涉及两个类：</p>
<ul>
<li>InterProcessMultiLock</li>
<li>InterProcessLock</li>
</ul>
<p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMultiLock</span><span class="hljs-params">(List&lt;InterProcessLock&gt; locks)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title">InterProcessMultiLock</span><span class="hljs-params">(CuratorFramework client, List&lt;String&gt; paths)</span></span><br></code></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessLock;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMultiLock;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 16:03<br> * <span class="hljs-doctag">@description</span> Test14App, 多共享锁对象 —Multi Shared Lock<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test14App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test14App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FakeLimitedResource resource = <span class="hljs-keyword">new</span> FakeLimitedResource();<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        <span class="hljs-comment">// 创建一个可重入锁对象</span><br>        InterProcessLock lock = <span class="hljs-keyword">new</span> InterProcessMutex(client, <span class="hljs-string">"/examples/locks"</span>);<br>        <span class="hljs-comment">// 创建一个不可重入锁对象</span><br>        InterProcessLock lock2 = <span class="hljs-keyword">new</span> InterProcessSemaphoreMutex(client, <span class="hljs-string">"/examples/locks2"</span>);<br>        <span class="hljs-comment">// 创建多共享锁对象</span><br>        InterProcessLock lock3 = <span class="hljs-keyword">new</span> InterProcessMultiLock(Arrays.asList(lock, lock2));<br><br>        <span class="hljs-keyword">if</span> (!lock3.acquire(<span class="hljs-number">2000</span>, TimeUnit.SECONDS)) &#123;<br>            LOGGER.info(<span class="hljs-string">"获取所有的锁失败！"</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"获取所有的锁成功！lock 是否获取到了锁：&#123;&#125;, lock2 是否获取到了锁：&#123;&#125;"</span>, lock.isAcquiredInThisProcess(), lock2.isAcquiredInThisProcess());<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用共享资源</span><br>            resource.use();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放所有锁</span><br>            lock3.release();<br>            LOGGER.info(<span class="hljs-string">"释放所有的锁成功！lock 是否获取到了锁：&#123;&#125;, lock2 是否获取到了锁：&#123;&#125;"</span>, lock.isAcquiredInThisProcess(), lock2.isAcquiredInThisProcess());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 共享资源<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FakeLimitedResource</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicBoolean inUse = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>            <span class="hljs-comment">// 如果设置值失败</span><br>            <span class="hljs-keyword">if</span> (!inUse.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"该资源的原始值不是 false，所以设置值失败！"</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 模拟程序复杂业务</span><br>                <span class="hljs-keyword">int</span> seconds = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>                LOGGER.info(<span class="hljs-string">"模拟程序复杂业务，耗时 &#123;&#125; 秒"</span>, seconds);<br>                TimeUnit.SECONDS.sleep(seconds);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 强制将 inUse 设置为 false</span><br>                inUse.set(<span class="hljs-keyword">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>新建一个<code>InterProcessMultiLock</code>， 包含一个重入锁和一个非重入锁。 调用<code>acquire()</code>后可以看到线程同时拥有了这两个锁。 调用<code>release()</code>看到这两个锁都被释放了。</p>
<p><strong>最后再重申一次， 强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，锁将会丢失。</strong></p>
<h2 id="分布式计数器"><a href="#分布式计数器" class="headerlink" title="分布式计数器"></a>分布式计数器</h2><p>顾名思义，计数器是用来计数的, 利用ZooKeeper可以实现一个集群共享的计数器。 只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数(<code>SharedCount</code>)，一个用long来计数(<code>DistributedAtomicLong</code>)。</p>
<h3 id="分布式int计数器-SharedCount"><a href="#分布式int计数器-SharedCount" class="headerlink" title="分布式int计数器(SharedCount)"></a>分布式int计数器(SharedCount)</h3><p>这个类使用int类型来计数。 主要涉及三个类。</p>
<ul>
<li>SharedCount</li>
<li>SharedCountReader</li>
<li>SharedCountListener</li>
</ul>
<p><code>SharedCount</code>代表计数器， 可以为它增加一个<code>SharedCountListener</code>，当计数器改变时此Listener可以监听到改变的事件，而<code>SharedCountReader</code>可以读取到最新的值， 包括字面值和带版本信息的值VersionedValue。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCount;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCountListener;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCountReader;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 16:56<br> * <span class="hljs-doctag">@description</span> Test15App, 分布式int计数器—SharedCount<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test15App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> Random random = <span class="hljs-keyword">new</span> Random();<br>        SharedCounterDemo demo = <span class="hljs-keyword">new</span> SharedCounterDemo();<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">2000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br>        <span class="hljs-comment">// 创建计数器对象</span><br>        SharedCount sharedCount = <span class="hljs-keyword">new</span> SharedCount(client, <span class="hljs-string">"/examples/counter"</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 给计数器对象添加监听器</span><br>        sharedCount.addListener(demo);<br>        <span class="hljs-comment">// 启动计数器</span><br>        sharedCount.start();<br><br>        List&lt;SharedCount&gt; sharedCounts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> SharedCount SharedCount = <span class="hljs-keyword">new</span> SharedCount(client, <span class="hljs-string">"/examples/counter"</span>, <span class="hljs-number">0</span>);<br>            sharedCounts.add(sharedCount);<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                SharedCount.start();<br>                TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">10</span>));<br>                <span class="hljs-keyword">boolean</span> b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br>                <span class="hljs-keyword">while</span> (!b) &#123;<br>                    b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br>                &#125;<br>                LOGGER.info(<span class="hljs-string">"修改数据，b: [&#123;&#125;]"</span>, b);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br>            executorService.submit(task);<br>        &#125;<br><br>        executorService.shutdown();<br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br><br>        <span class="hljs-comment">// 关闭计数器</span><br>        <span class="hljs-keyword">for</span> (SharedCount count : sharedCounts) &#123;<br>            count.close();<br>        &#125;<br><br>        sharedCount.close();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedCounterDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SharedCountListener</span> </span>&#123;<br>        <span class="hljs-comment">/**<br>         * 数字更改时触发<br>         * <span class="hljs-doctag">@param</span> sharedCount<br>         * <span class="hljs-doctag">@param</span> newCount<br>         * <span class="hljs-doctag">@throws</span> Exception<br>         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countHasChanged</span><span class="hljs-params">(SharedCountReader sharedCount, <span class="hljs-keyword">int</span> newCount)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            LOGGER.info(<span class="hljs-string">"数据被修改为：&#123;&#125;"</span>, newCount);<br>        &#125;<br><br>        <span class="hljs-comment">/**<br>         * 状态更改时触发<br>         * <span class="hljs-doctag">@param</span> client<br>         * <span class="hljs-doctag">@param</span> newState<br>         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>            LOGGER.info(<span class="hljs-string">"状态被修改为了：&#123;&#125;"</span>, newState);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们使用<code>baseCount</code>来监听计数值(<code>addListener</code>方法来添加SharedCountListener )。 任意的SharedCount， 只要使用相同的path，都可以得到这个计数值。 然后我们使用5个线程为计数值增加一个10以内的随机数。相同的path的SharedCount对计数值进行更改，将会回调给<code>baseCount</code>的SharedCountListener。</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br><span class="hljs-keyword">while</span> (!b) &#123;<br>    b = SharedCount.trySetCount(sharedCount.getVersionedValue(), random.nextInt(<span class="hljs-number">100</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们使用<code>trySetCount</code>去设置计数器。 <strong>第一个参数提供当前的VersionedValue,如果期间其它client更新了此计数值， 你的更新可能不成功， 更新不成功会返回 false。所以失败了你可以尝试再更新一次。 而<code>setCount</code>是强制更新计数器的值</strong>。</p>
<p>注意计数器必须<code>start</code>,使用完之后必须调用<code>close</code>关闭它。</p>
<p>强烈推荐使用<code>ConnectionStateListener</code>。 在本例中<code>SharedCountListener</code>扩展<code>ConnectionStateListener</code>。</p>
<h3 id="分布式long计数器-DistributedAtomicLong"><a href="#分布式long计数器-DistributedAtomicLong" class="headerlink" title="分布式long计数器(DistributedAtomicLong)"></a>分布式long计数器(DistributedAtomicLong)</h3><p>再看一个Long类型的计数器。 除了计数的范围比<code>SharedCount</code>大了之外， 它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用<code>InterProcessMutex</code>方式来更新计数值。</p>
<p>可以从它的内部实现<code>DistributedAtomicValue.trySet()</code>中看出：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicValue &lt; <span class="hljs-keyword">byte</span>[] &gt; trySet(MakeValue makeValue) <span class="hljs-keyword">throws</span> Exception &#123;<br>    MutableAtomicValue &lt; <span class="hljs-keyword">byte</span>[] &gt; result = <span class="hljs-keyword">new</span> MutableAtomicValue &lt; <span class="hljs-keyword">byte</span>[] &gt; (<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    tryOptimistic(result, makeValue);<br>    <span class="hljs-keyword">if</span>(!result.succeeded() &amp;&amp; (mutex != <span class="hljs-keyword">null</span>)) &#123;<br>        tryWithMutex(result, makeValue);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此计数器有一系列的操作：</p>
<ul>
<li>get(): 获取当前值</li>
<li>increment()： 加一</li>
<li>decrement(): 减一</li>
<li>add()： 增加特定的值</li>
<li>subtract(): 减去特定的值</li>
<li>trySet(): 尝试设置计数值</li>
<li>forceSet(): 强制设置计数值</li>
</ul>
<p>你<strong>必须</strong>检查返回结果的<code>succeeded()</code>， 它代表此操作是否成功。 如果操作成功， <code>preValue()</code>代表操作前的值， <code>postValue()</code>代表操作后的值。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.atomic.AtomicValue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.atomic.DistributedAtomicLong;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.RetryNTimes;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2019/12/30 17:29<br> * <span class="hljs-doctag">@description</span> Test16App, 分布式long计数器—DistributedAtomicLong<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test16App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test16App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">2000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">/**<br>             * 重试策略对象，参数解释如下：<br>             * 第一个参数：重试次数<br>             * 第二个参数：重试之间的睡眠时间<br>             */</span><br>            RetryNTimes retryNTimes = <span class="hljs-keyword">new</span> RetryNTimes(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">final</span> DistributedAtomicLong atomicLong = <span class="hljs-keyword">new</span> DistributedAtomicLong(client, <span class="hljs-string">"/examples/counter"</span>, retryNTimes);<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 加 1</span><br>                    AtomicValue&lt;Long&gt; value = atomicLong.increment();<br>                    <span class="hljs-keyword">if</span> (value.succeeded()) &#123;<br>                        LOGGER.info(<span class="hljs-string">"修改前的值为：&#123;&#125;， 修改后的值为：&#123;&#125;"</span>, value.preValue(), value.postValue());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        LOGGER.info(<span class="hljs-string">"修改失败"</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序出现异常！"</span>, e);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br><br>            executorService.submit(task);<br>        &#125;<br><br>        executorService.shutdown();<br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>使用Curator也可以简化Ephemeral Node (<strong>临时节点</strong>)的操作。Curator也提供ZK Recipe的分布式队列实现。 利用ZK的 PERSISTENTS_EQUENTIAL节点， 可以保证放入到队列中的项目是按照顺序排队的。 如果单一的消费者从队列中取数据， 那么它是先入先出的，这也是队列的特点。 如果你严格要求顺序，你就的使用单一的消费者，可以使用Leader选举只让Leader作为唯一的消费者。</p>
<p>但是， 根据Netflix的Curator作者所说， ZooKeeper真心不适合做Queue，或者说ZK没有实现一个好的Queue，详细内容可以看 <a href="https://cwiki.apache.org/confluence/display/CURATOR/TN4" target="_blank" rel="noopener">Tech Note 4</a>， 原因有五：</p>
<ol>
<li>ZK有1MB 的传输限制。 实践中ZNode必须相对较小，而队列包含成千上万的消息，非常的大。</li>
<li>如果有很多节点，ZK启动时相当的慢。 而使用queue会导致好多ZNode. 你需要显著增大 initLimit 和 syncLimit.</li>
<li>ZNode很大的时候很难清理。Netflix不得不创建了一个专门的程序做这事。</li>
<li>当很大量的包含成千上万的子节点的ZNode时， ZK的性能变得不好</li>
<li>ZK的数据库完全放在内存中。 大量的Queue意味着会占用很多的内存空间。</li>
</ol>
<p>尽管如此， Curator还是创建了各种Queue的实现。 如果Queue的数据量不太多，数据量不太大的情况下，酌情考虑，还是可以使用的。</p>
<h3 id="分布式队列-DistributedQueue"><a href="#分布式队列-DistributedQueue" class="headerlink" title="分布式队列(DistributedQueue)"></a>分布式队列(DistributedQueue)</h3><p>DistributedQueue是最普通的一种队列。 它设计以下四个类：</p>
<ul>
<li>QueueBuilder - 创建队列使用QueueBuilder,它也是其它队列的创建类</li>
<li>QueueConsumer - 队列中的消息消费者接口</li>
<li>QueueSerializer - 队列消息序列化和反序列化接口，提供了对队列中的对象的序列化和反序列化</li>
<li>DistributedQueue - 队列实现类</li>
</ul>
<p>QueueConsumer是消费者，它可以接收队列的数据。处理队列中的数据的代码逻辑可以放在QueueConsumer.consumeMessage()中。</p>
<p><strong>正常情况下先将消息从队列中移除，再交给消费者消费。但这是两个步骤，不是原子的。</strong>可以调用Builder的lockPath()消费者加锁，当消费者消费数据时持有锁，这样其它消费者不能消费此消息。如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。最好还是单消费者模式使用队列。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.DistributedQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueBuilder;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueConsumer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueSerializer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/3 14:43<br> * <span class="hljs-doctag">@description</span> Test17App, 分布式队列—DistributedQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test17App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test17App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));<br>        CuratorFramework client2 = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">// 客户端启动</span><br>        client.start();<br>        <span class="hljs-comment">// 客户端2启动</span><br>        client2.start();<br><br>        <span class="hljs-comment">/**<br>         * 是线程不安全的<br>         */</span><br>        <span class="hljs-comment">// DistributedQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer("消费者A"), creQueueSerializer(), "/example/queue").buildQueue();</span><br>        <span class="hljs-comment">// DistributedQueue&lt;String&gt; queue2 = QueueBuilder.builder(client, createQueueConsumer("消费者B"), creQueueSerializer(), "/example/queue").buildQueue();</span><br><br>        <span class="hljs-comment">/**<br>         * 正常情况下先将消息从队列中移除，再交给消费者消费。但这是两个步骤，不是原子的。<br>         * 可以调用Builder的lockPath()消费者加锁，当消费者消费数据时持有锁，这样其它消费者不能消费此消息。<br>         * 如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。最好还是单消费者模式使用队列。<br>         */</span><br>        DistributedQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(<span class="hljs-string">"消费者A"</span>), creQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).lockPath(<span class="hljs-string">"/example/lock"</span>).buildQueue();<br>        DistributedQueue&lt;String&gt; queue2 = QueueBuilder.builder(client, createQueueConsumer(<span class="hljs-string">"消费者B"</span>), creQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).lockPath(<span class="hljs-string">"/example/lock"</span>).buildQueue();<br><br>        <span class="hljs-comment">// 消息队列启动</span><br>        queue.start();<br>        <span class="hljs-comment">// 消息队列2启动</span><br>        queue2.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">// 往消息队列中放数据</span><br>            queue.put(<span class="hljs-string">"Test-A-"</span> + i);<br>            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>            <span class="hljs-comment">// 往消息队列2中放数据</span><br>             queue2.put(<span class="hljs-string">"Test-B-"</span> + i);<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 关闭消息队列</span><br>        queue.close();<br>        <span class="hljs-comment">// 关闭消息队列2</span><br>        queue2.close();<br><br>        <span class="hljs-comment">// 客户端关闭</span><br>        client.close();<br>        <span class="hljs-comment">// 客户端2关闭</span><br>        client2.close();<br>        LOGGER.info(<span class="hljs-string">"程序执行结束！"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 定义队列消费者<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-comment">/**<br>             * 消费消息时调用的方法<br>             * <span class="hljs-doctag">@param</span> message<br>             * <span class="hljs-doctag">@throws</span> Exception<br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"&#123;&#125; 消费消息：&#123;&#125;"</span>, name, message);<br>            &#125;<br><br>            <span class="hljs-comment">/**<br>             * 状态改变时调用的方法<br>             * <span class="hljs-doctag">@param</span> client<br>             * <span class="hljs-doctag">@param</span> newState<br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"连接状态为：&#123;&#125;"</span>, newState.name());<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 队列消息序列化实现类<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">creQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-comment">/**<br>             * 序列化<br>             * <span class="hljs-doctag">@param</span> item<br>             * <span class="hljs-doctag">@return</span><br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-comment">/**<br>             * 反序列化<br>             * <span class="hljs-doctag">@param</span> bytes<br>             * <span class="hljs-doctag">@return</span><br>             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例子中定义了两个分布式队列和两个消费者，因为PATH是相同的，通常会存在消费者抢占消费消息的情况，但是我使用了 <code>lockPath(/example/lock)</code> 方法，所以不会，如果将该代码注释掉，然后方案前面注释的代码，就会出现消费者抢占消费消息的情况（但是我测试了 N 次，也没有出现这个这种情况）。</p>
<h3 id="带Id的分布式队列-DistributedIdQueue"><a href="#带Id的分布式队列-DistributedIdQueue" class="headerlink" title="带Id的分布式队列(DistributedIdQueue)"></a>带Id的分布式队列(DistributedIdQueue)</h3><p>DistributedIdQueue和上面的队列类似，<strong>但是可以为队列中的每一个元素设置一个ID</strong>。 可以通过ID把队列中任意的元素移除。 它涉及几个类：</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedQueue</li>
</ul>
<p>通过下面方法创建：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">builder.buildIdQueue()<br></code></pre></td></tr></table></figure>

<p>放入元素时：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.put(aMessage, messageId);<br></code></pre></td></tr></table></figure>

<p>移除元素时：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> numberRemoved = queue.remove(messageId);<br></code></pre></td></tr></table></figure>

<p>示例代码如：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.*;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 13:55<br> * <span class="hljs-doctag">@description</span> Test18App，带Id的分布式队列—DistributedIdQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test18App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test18App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-comment">/**<br>     * 测试方法<br>     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建队列对象</span><br>        DistributedIdQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(), createQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).buildIdQueue();<br>        <span class="hljs-comment">// 启动队列</span><br>        queue.start();<br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            queue.put(<span class="hljs-string">"Test-"</span> + i, <span class="hljs-string">"Id-"</span> + i);<br>            <span class="hljs-comment">/**<br>             * 往队列中放入一个数据后睡眠任意秒，该线程放弃 CPU 执行权。队列开始消费，如果该线程在睡眠任意秒后重新获得 CPU 执行权，但是队列的数据没有被消费，<br>             * 此时调用 queue.remove("Id-" + i) 方法把队列中的指定数据删除了，该消费就不会被消费了。<br>             */</span><br>            TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">2</span>));<br>            queue.remove(<span class="hljs-string">"Id-"</span> + i);<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！准备回收资源"</span>);<br><br>        CloseableUtils.closeQuietly(queue);<br>        CloseableUtils.closeQuietly(client);<br><br>        LOGGER.info(<span class="hljs-string">"资源回收完毕！"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建序列化和反序列化对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">createQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建消费者对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"消费的消息内容为：&#123;&#125;"</span>, message);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"当前连接的状态改变了，新状态为：&#123;&#125;"</span>, newState);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中， 有些元素还没有被消费者消费前就移除了，这样消费者不会收到删除的消息。</p>
<h3 id="优先级分布式队列-DistributedPriorityQueue"><a href="#优先级分布式队列-DistributedPriorityQueue" class="headerlink" title="优先级分布式队列(DistributedPriorityQueue)"></a>优先级分布式队列(DistributedPriorityQueue)</h3><p>优先级队列对队列中的元素按照优先级进行排序。 <strong>Priority越小， 元素越靠前， 越先被消费掉</strong>。 它涉及下面几个类：</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedPriorityQueue</li>
</ul>
<p>通过builder.buildPriorityQueue(minItemsBeforeRefresh)方法创建。 当优先级队列得到元素增删消息时，它会暂停处理当前的元素队列，然后刷新队列。minItemsBeforeRefresh指定刷新前当前活动的队列的最小数量。 主要设置你的程序可以容忍的不排序的最小值。</p>
<p>放入队列时需要指定优先级：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.put(aMessage, priority);<br></code></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.DistributedPriorityQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueBuilder;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueConsumer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueSerializer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 15:32<br> * <span class="hljs-doctag">@description</span> Test19App, 优先级分布式队列—DistributedPriorityQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test19App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test19App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-comment">/**<br>     * 测试方法<br>     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建优先级队列对象</span><br>        DistributedPriorityQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(), createQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).buildPriorityQueue(<span class="hljs-number">0</span>);<br>        queue.start();<br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> priority = random.nextInt(<span class="hljs-number">100</span>);<br>            LOGGER.info(<span class="hljs-string">"Test-"</span> + i + <span class="hljs-string">" priority: "</span> + priority);<br>            queue.put(<span class="hljs-string">"Test"</span> + i, priority);<br>            TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">2</span>));<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！开始回收资源"</span>);<br><br>        CloseableUtils.closeQuietly(queue);<br>        CloseableUtils.closeQuietly(client);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建序列化和反序列化对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">createQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建消费者对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"消费的消息内容为：&#123;&#125;"</span>, message);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"当前连接的状态改变了，新状态为：&#123;&#125;"</span>, newState);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有时候你可能会有错觉，优先级设置并没有起效。那是因为优先级是对于队列积压的元素而言，如果消费速度过快有可能出现在后一个元素入队操作之前前一个元素已经被消费，这种情况下DistributedPriorityQueue会退化为DistributedQueue。</p>
<h3 id="分布式延迟队列-DistributedDelayQueue"><a href="#分布式延迟队列-DistributedDelayQueue" class="headerlink" title="分布式延迟队列(DistributedDelayQueue)"></a>分布式延迟队列(DistributedDelayQueue)</h3><p>JDK中也有DelayQueue，不知道你是否熟悉。 DistributedDelayQueue也提供了类似的功能， 元素有个delay值， 消费者隔一段时间才能收到元素。 涉及到下面四个类。</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedDelayQueue</li>
</ul>
<p>通过下面的语句创建：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">QueueBuilder&lt;MessageType&gt;    builder = QueueBuilder.builder(client, consumer, serializer, path);<br>... more builder method calls as needed ...<br>DistributedDelayQueue&lt;MessageType&gt; queue = builder.buildDelayQueue();<br></code></pre></td></tr></table></figure>

<p>放入元素时可以指定<code>delayUntilEpoch</code>：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">queue.put(aMessage, delayUntilEpoch);<br></code></pre></td></tr></table></figure>

<p>注意<code>delayUntilEpoch</code>不是离现在的一个时间间隔， 比如20毫秒，而是未来的一个时间戳，如 System.currentTimeMillis() + 10秒。 如果delayUntilEpoch的时间已经过去，消息会立刻被消费者接收。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.DistributedDelayQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueBuilder;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueConsumer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.QueueSerializer;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.state.ConnectionState;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 15:53<br> * <span class="hljs-doctag">@description</span> Test20App, 分布式延迟队列—DistributedDelayQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test20App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test20App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建延时队列对象</span><br>        DistributedDelayQueue&lt;String&gt; queue = QueueBuilder.builder(client, createQueueConsumer(), createQueueSerializer(), <span class="hljs-string">"/example/queue"</span>).buildDelayQueue();<br>        queue.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            queue.put(<span class="hljs-string">"Test-"</span> + i, System.currentTimeMillis() + <span class="hljs-number">1000</span>);<br>        &#125;<br><br>        LOGGER.info(<span class="hljs-string">"所有的数据都已经放入了延时队列中！"</span>);<br><br>        <span class="hljs-comment">// 等待消费者消费完队列数据再释放资源</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 释放资源</span><br>        CloseableUtils.closeQuietly(queue);<br>        CloseableUtils.closeQuietly(client);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建序列化和反序列化对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueSerializer&lt;String&gt; <span class="hljs-title">createQueueSerializer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueSerializer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] serialize(String item) &#123;<br>                <span class="hljs-keyword">return</span> item.getBytes();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 创建消费者对象<br>     * <span class="hljs-doctag">@return</span><br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> QueueConsumer&lt;String&gt; <span class="hljs-title">createQueueConsumer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QueueConsumer&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumeMessage</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"消费的消息内容为：&#123;&#125;"</span>, message);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateChanged</span><span class="hljs-params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;<br>                LOGGER.info(<span class="hljs-string">"当前连接的状态改变了，新状态为：&#123;&#125;"</span>, newState);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基于JDK的分布式队列-SimpleDistributedQueue"><a href="#基于JDK的分布式队列-SimpleDistributedQueue" class="headerlink" title="基于JDK的分布式队列(SimpleDistributedQueue)"></a>基于JDK的分布式队列(SimpleDistributedQueue)</h3><p>前面虽然实现了各种队列，但是你注意到没有，这些队列并没有实现类似JDK一样的接口。 <code>SimpleDistributedQueue</code>提供了和JDK基本一致的接口(但是没有实现Queue接口)。 创建很简单：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleDistributedQueue</span><span class="hljs-params">(CuratorFramework client,String path)</span></span><br></code></pre></td></tr></table></figure>

<p>增加元素：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception</span><br></code></pre></td></tr></table></figure>

<p>删除元素：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] take() <span class="hljs-keyword">throws</span> Exception<br></code></pre></td></tr></table></figure>

<p>另外还提供了其它方法：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] peek() <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] poll(<span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] poll() <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] remove() <span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] element() <span class="hljs-keyword">throws</span> Exception<br></code></pre></td></tr></table></figure>

<p>没有<code>add</code>方法， 多了<code>take</code>方法。<code>take</code>方法在成功返回之前会被阻塞。 而<code>poll</code>方法在队列为空时直接返回null。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.queue.SimpleDistributedQueue;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.apache.curator.utils.CloseableUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 16:22<br> * <span class="hljs-doctag">@description</span> Test21App，SimpleDistributedQueue<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test21App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test21App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.getCuratorListenable().addListener((client1, event) -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">"监听客户端连接事件，事件名为：&#123;&#125;"</span>, event.getType().name());<br>        &#125;);<br>        client.start();<br><br>        <span class="hljs-comment">// 创建队列对象</span><br>        SimpleDistributedQueue queue = <span class="hljs-keyword">new</span> SimpleDistributedQueue(client, <span class="hljs-string">"/example/queue"</span>);<br><br>        <span class="hljs-comment">// 创建生产者和消费者对象</span><br>        Producer producer = <span class="hljs-keyword">new</span> Producer(queue);<br>        Consumer consumer = <span class="hljs-keyword">new</span> Consumer(queue);<br><br>        <span class="hljs-comment">// 启动生产者和消费者线程</span><br>        <span class="hljs-keyword">new</span> Thread(producer).start();<br>        <span class="hljs-keyword">new</span> Thread(consumer).start();<br><br>        <span class="hljs-comment">// 等待队列中的数据处理完毕</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 释放资源</span><br>        CloseableUtils.closeQuietly(client);<br><br>        LOGGER.info(<span class="hljs-string">"程序执行完毕！"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 消费者<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> SimpleDistributedQueue queue;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(SimpleDistributedQueue queue)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">this</span>.queue.take();<br>                    <span class="hljs-keyword">if</span> (bytes == <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    LOGGER.info(<span class="hljs-string">"消费一条消息成功：&#123;&#125;"</span>, <span class="hljs-keyword">new</span> String(bytes));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LOGGER.error(<span class="hljs-string">"程序出现异常!"</span>, e);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * 生产者<br>     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> SimpleDistributedQueue queue;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(SimpleDistributedQueue queue)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.queue = queue;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">this</span>.queue.offer((<span class="hljs-string">"test-"</span> + i).getBytes());<br>                    <span class="hljs-keyword">if</span> (flag) &#123;<br>                        LOGGER.info(<span class="hljs-string">"发送消息成功：&#123;&#125;"</span>, <span class="hljs-string">"test-"</span> + i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        LOGGER.info(<span class="hljs-string">"发送消息失败：&#123;&#125;"</span>, <span class="hljs-string">"test-"</span> + i);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序发生异常！"</span>, e);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="分布式栅栏-屏障-——Barrier"><a href="#分布式栅栏-屏障-——Barrier" class="headerlink" title="分布式栅栏(屏障)——Barrier"></a>分布式栅栏(屏障)——Barrier</h2><p>分布式Barrier是这样一个类： 它会阻塞所有节点上的等待进程，直到某一个被满足， 然后所有的节点继续进行。</p>
<p>比如赛马比赛中， 等赛马陆续来到起跑线前。 一声令下，所有的赛马都飞奔而出。</p>
<h3 id="DistributedBarrier"><a href="#DistributedBarrier" class="headerlink" title="DistributedBarrier"></a>DistributedBarrier</h3><p><code>DistributedBarrier</code>类实现了栅栏的功能。 它的构造函数如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DistributedBarrier</span><span class="hljs-params">(CuratorFramework client, String barrierPath)</span></span><br></code></pre></td></tr></table></figure>

<p>首先你需要设置栅栏，它将阻塞在它上面等待的线程:</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">setBarrier();<br></code></pre></td></tr></table></figure>

<p>然后需要阻塞的线程调用方法告诉栅栏等待放行:</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitOnBarrier</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>移除栅栏，所有等待的线程将继续执行：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">removeBarrier();<br></code></pre></td></tr></table></figure>

<p><strong>异常处理</strong> DistributedBarrier 会监控连接状态，当连接断掉时<code>waitOnBarrier()</code>方法会抛出异常。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.barriers.DistributedBarrier;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 17:30<br> * <span class="hljs-doctag">@description</span> Test22App, DistributedBarrier<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test22App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test22App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        <span class="hljs-comment">// 创建线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 创建栅栏对象</span><br>        <span class="hljs-keyword">final</span> DistributedBarrier barrier = <span class="hljs-keyword">new</span> DistributedBarrier(client, <span class="hljs-string">"/examples/barrier"</span>);<br>        <span class="hljs-comment">// 设置栅栏，在该栅栏上的所有线程都将阻塞</span><br>        barrier.setBarrier();<br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="hljs-number">3</span>));<br>                LOGGER.info(<span class="hljs-string">"客户端 #"</span> + index + <span class="hljs-string">"准备数据"</span>);<br><br>                <span class="hljs-comment">// 告诉栅栏对象，数据准备完毕</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    barrier.waitOnBarrier();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    LOGGER.error(<span class="hljs-string">"程序出现异常！"</span>, e);<br>                &#125;<br>                <span class="hljs-comment">// 栅栏对象放行后，执行</span><br>                LOGGER.info(<span class="hljs-string">"开始处理数据！"</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br>            executorService.submit(task);<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br><br>        LOGGER.info(<span class="hljs-string">"当所有线程数据准备完毕后，开始放行！"</span>);<br><br>        <span class="hljs-comment">// 放行栅栏</span><br>        barrier.removeBarrier();<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        executorService.shutdown();<br><br>        <span class="hljs-comment">// 和 executorService.shutdown() 组合使用，监控线程池是否已经关闭，如果线程池内之前提交的任务还没有完成，会一直监控到任务处理完成后。</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个例子创建了<code>controlBarrier</code>来设置栅栏和移除栅栏。 我们创建了5个线程，在此Barrier上等待。 最后移除栅栏后所有的线程才继续执行。</p>
<h3 id="双栅栏-DistributedDoubleBarrier"><a href="#双栅栏-DistributedDoubleBarrier" class="headerlink" title="双栅栏(DistributedDoubleBarrier)"></a>双栅栏(DistributedDoubleBarrier)</h3><p>双栅栏允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算， 当计算完成时，离开栅栏。 双栅栏类是<code>DistributedDoubleBarrier</code>。 构造函数为:</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DistributedDoubleBarrier</span><span class="hljs-params">(CuratorFramework client,<br>                                String barrierPath,<br>                                <span class="hljs-keyword">int</span> memberQty)</span></span><br></code></pre></td></tr></table></figure>

<p><code>memberQty</code>是成员数量，当<code>enter()</code>方法被调用时，成员被阻塞，直到所有的成员都调用了<code>enter()</code>。 当<code>leave()</code>方法被调用时，它也阻塞调用线程，直到所有的成员都调用了<code>leave()</code>。 就像百米赛跑比赛， 发令枪响， 所有的运动员开始跑，等所有的运动员跑过终点线，比赛才结束。</p>
<p>DistributedDoubleBarrier会监控连接状态，当连接断掉时<code>enter()</code>和<code>leave()</code>方法会抛出异常。</p>
<p>示例代码如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zgy.test;<br><br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.barriers.DistributedDoubleBarrier;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**<br> * <span class="hljs-doctag">@author</span> ZGY<br> * <span class="hljs-doctag">@date</span> 2020/1/8 18:07<br> * <span class="hljs-doctag">@description</span> Test23App, 双栅栏—DistributedDoubleBarrier<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test23App</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Test23App<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">20000</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">5000</span>, <span class="hljs-number">3</span>));<br>        client.start();<br><br>        <span class="hljs-comment">// 创建线程池</span><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 创建栅栏对象</span><br>            <span class="hljs-keyword">final</span> DistributedDoubleBarrier doubleBarrier = <span class="hljs-keyword">new</span> DistributedDoubleBarrier(client, <span class="hljs-string">"/examples/barrier"</span>, <span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br>            Callable&lt;Void&gt; task = () -&gt; &#123;<br>                TimeUnit.MILLISECONDS.sleep(random.nextInt(<span class="hljs-number">3</span>));<br>                LOGGER.info(<span class="hljs-string">"客户端 #"</span> + index + <span class="hljs-string">"进入栅栏"</span>);<br>                doubleBarrier.enter();<br><br>                <span class="hljs-comment">// 当所有线程都进入栅栏后，执行下面的代码</span><br>                LOGGER.info(<span class="hljs-string">"执行代码"</span>);<br>                TimeUnit.SECONDS.sleep(random.nextInt(<span class="hljs-number">3</span>));<br><br>                doubleBarrier.leave();<br>                LOGGER.info(<span class="hljs-string">"客户端 #"</span> + index + <span class="hljs-string">"离开栅栏"</span>);<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;;<br>            executorService.submit(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        executorService.shutdown();<br><br>        <span class="hljs-comment">// 和 executorService.shutdown() 组合使用，监控线程池是否已经关闭，如果线程池内之前提交的任务还没有完成，会一直监控到任务处理完成后。</span><br>        executorService.awaitTermination(<span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>源代码：<a href="https://github.com/ZGYSYY/spring-boot-seckill/blob/master/src/test/java/com/zgy/test" target="_blank" rel="noopener">https://github.com/ZGYSYY/spring-boot-seckill/blob/master/src/test/java/com/zgy/test</a></p>
<blockquote>
<p>本文参考自：<a href="http://throwable.coding.me/2018/12/16/zookeeper-curator-usage/" target="_blank" rel="noopener">http://throwable.coding.me/2018/12/16/zookeeper-curator-usage/</a></p>
</blockquote>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/Zookeeper/" rel="tag"><i class="fas fa-tags"></i>Zookeeper</a>
        
        <a class="post-tag button" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="tag"><i class="fas fa-tags"></i>分布式锁</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2020/01/03/ZooKeeper%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/" rel="next" title="ZooKeeper详解（一）"><i class="fas fa-angle-left"></i><span class="nav-title">ZooKeeper详解（一）</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2020/01/15/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" rel="prev" title="Git使用教程"><span class="nav-title">Git使用教程</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.png" alt="ZGY">
  
  <h1 class="author-name">ZGY</h1>
  <h2 class="author-description">不逼逼自己，都不知道自己到底有多LOW！(¬､¬)</h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">16</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">13</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">24</a></div>
    </div>
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#Curator的基本Api"><span class="toc-text">Curator的基本Api</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#创建会话"><span class="toc-text">创建会话</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#数据节点基本操作（增删改查）"><span class="toc-text">数据节点基本操作（增删改查）</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#事务"><span class="toc-text">事务</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#异步接口"><span class="toc-text">异步接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#Curator-高级特性"><span class="toc-text">Curator 高级特性</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#缓存"><span class="toc-text">缓存</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Path-Cache"><span class="toc-text">Path Cache</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Node-Cache"><span class="toc-text">Node Cache</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Tree-Cache"><span class="toc-text">Tree Cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#Leader选举"><span class="toc-text">Leader选举</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#LeaderLatch"><span class="toc-text">LeaderLatch</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#LeaderSelector"><span class="toc-text">LeaderSelector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#分布式锁"><span class="toc-text">分布式锁</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#可重入共享锁-Shared-Reentrant-Lock"><span class="toc-text">可重入共享锁 Shared Reentrant Lock</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#不可重入共享锁-Shared-Lock"><span class="toc-text">不可重入共享锁 Shared Lock</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#可重入读写锁-Shared-Reentrant-Read-Write-Lock"><span class="toc-text">可重入读写锁 Shared Reentrant Read Write Lock</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#信号量-Shared-Semaphore"><span class="toc-text">信号量 Shared Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#多共享锁对象-Multi-Shared-Lock"><span class="toc-text">多共享锁对象 Multi Shared Lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#分布式计数器"><span class="toc-text">分布式计数器</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#分布式int计数器-SharedCount"><span class="toc-text">分布式int计数器(SharedCount)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#分布式long计数器-DistributedAtomicLong"><span class="toc-text">分布式long计数器(DistributedAtomicLong)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#分布式队列"><span class="toc-text">分布式队列</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#分布式队列-DistributedQueue"><span class="toc-text">分布式队列(DistributedQueue)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#带Id的分布式队列-DistributedIdQueue"><span class="toc-text">带Id的分布式队列(DistributedIdQueue)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#优先级分布式队列-DistributedPriorityQueue"><span class="toc-text">优先级分布式队列(DistributedPriorityQueue)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#分布式延迟队列-DistributedDelayQueue"><span class="toc-text">分布式延迟队列(DistributedDelayQueue)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#基于JDK的分布式队列-SimpleDistributedQueue"><span class="toc-text">基于JDK的分布式队列(SimpleDistributedQueue)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#分布式栅栏-屏障-——Barrier"><span class="toc-text">分布式栅栏(屏障)——Barrier</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#DistributedBarrier"><span class="toc-text">DistributedBarrier</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#双栅栏-DistributedDoubleBarrier"><span class="toc-text">双栅栏(DistributedDoubleBarrier)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#结束"><span class="toc-text">结束</span></a></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fas fa-envelope"></i><a href="mailto:3030392760@qq.com" target="_blank">E-Mail</a></li>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/zgysyy" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">ZGY</span><span class="year"><i class="far fa-copyright"></i>2019年12月31日 - 2020</span><span class="creative-commons"><i class="fab fa-creative-commons"></i><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">BY-NC-ND 4.0</a></span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
