<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="ZGYSYY, 我不是老司机, 后端开发, Java技术文章, Spring, SpringCloud, JVM调优, 程序员, 高并发编程, IT网站, 分布式, 中间件, 微服务, 个人技术博客">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="我不是老司机" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          // $(e).before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" aria-label=\"复制\"><i class=\"far fa-copy\"></i></button>",
              "</div>",
              "<div class=\"titlebar-center\">",
                "code",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          // $(e).parent().before("<button class=\"copy button\">复制</button>");
          $(e).before([
            "<div class=\"code-titlebar\">",
              "<div class=\"titlebar-left\">",
                "<button class=\"copy\" aria-label=\"复制\"><i class=\"far fa-copy\"></i></button>",
              "</div>",
              "<div class=\"titlebar-center\">",
                "code",
              "</div>",
              "<div class=\"titlebar-right\">",
                "<button class=\"button-dot dot-minimize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-maximize\" aria-label=\"Decoration\"></button>",
                "<button class=\"button-dot dot-close\" aria-label=\"Decoration\"></button>",
              "</div>",
            "</div>"
          ].join(""));
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              return trigger.parentNode.parentNode.nextElementSibling;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "<i class=\"far fa-check-square\"></i>";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "<i class=\"far fa-copy\"></i>";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>Disruptor——详解 | 我不是老司机 - I am not an old driver ! </title>
  <meta name="generator" content="Hexo 4.2.0"></head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">我不是老司机</a></h1>
        <h2 class="subtitle">I am not an old driver ! </h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://zgysyy.github.io/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="ZGY">
       <meta itemprop="description" content="不逼逼自己，都不知道自己到底有多LOW！(¬､¬)">
       <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="我不是老司机">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">Disruptor——详解</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2020-01-02T17:48:12+08:00">2020-01-02 17:48:12</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%90%8E%E7%AB%AF/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h1 id="资料一（基础概念-简单demo）"><a href="#资料一（基础概念-简单demo）" class="headerlink" title="资料一（基础概念+简单demo）"></a>资料一（基础概念+简单demo）</h1><p><strong>背景</strong></p>
<p>高并发是指通过设计保证系统能够同时并行处理很多请求。虽然我在工作中经常听到高并发，QPS之类的术语。其实，我对高并发也是一知半解，知道Java里面可以用Lock，Synchronized，ArrayBlockingQueue之类的来进行高并发的处理。我个人觉得，高并发领域更多的依靠的是经验的累积。今天想跟大家分享的是一个高性能的并发框架Disruptor。</p>
<a id="more"></a>

<p><strong>Disruptor概述</strong></p>
<p>Disruptor是一个异步并发处理框架。是由LMAX公司开发的一款高效的无锁内存队列。它使用无锁的方式实现了一个环形队列，非常适合于实现生产者和消费者模式，比如事件和消息的发布。</p>
<p>Disruptor最大特点是高性能，其LMAX架构可以获得每秒6百万订单，用1微秒的延迟获得吞吐量为100K+。</p>
<p><strong>一个官网的简单的demo</strong></p>
<p>1.maven依赖<br>maven引入Disruptor的jar包，Disruptor版本为3.2.1</p>
<figure class="hljs highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lmax<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>disruptor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2.创建数据实体类LongEvent</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代表数据的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEvent</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.创建工厂类LongEventFactory</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//产生LongEvent的工厂类，它会在Disruptor系统初始化时，构造所有的缓冲区中的对象实例（预先分配空间）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventFactory</span>&lt;<span class="hljs-title">LongEvent</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LongEvent <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LongEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4.创建消费者类LongEventHandler</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//消费者实现为WorkHandler接口，是Disruptor框架中的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">LongEvent</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//onEvent()方法是框架的回调用法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(LongEvent event, <span class="hljs-keyword">long</span> sequence, <span class="hljs-keyword">boolean</span> endOfBatch)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Event: "</span> + event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5.创建生产者类LongEventProducer</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//消费者实现为WorkHandler接口，是Disruptor框架中的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventProducer</span> </span>&#123;<br>    <span class="hljs-comment">//环形缓冲区,装载生产好的数据；</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LongEventProducer</span><span class="hljs-params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ringBuffer = ringBuffer;<br>    &#125;<br><br>    <span class="hljs-comment">//将数据推入到缓冲区的方法：将数据装载到ringBuffer</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onData</span><span class="hljs-params">(ByteBuffer bb)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> sequence = ringBuffer.next();<br><br>        <span class="hljs-comment">// Grab the next sequence //获取下一个可用的序列号</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            LongEvent event = ringBuffer.get(sequence);<br><br>            <span class="hljs-comment">// Get the entry in the Disruptor //通过序列号获取空闲可用的LongEvent</span><br><br>            <span class="hljs-comment">// for the sequence</span><br>            event.set(bb.getLong(<span class="hljs-number">0</span>));<br><br>            <span class="hljs-comment">// Fill with data //设置数值</span><br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            ringBuffer.publish(sequence);<br><br>            <span class="hljs-comment">//数据发布，只有发布后的数据才会真正被消费者看见</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>6.创建测试类 LongEventMain</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongEventMain</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 创建线程池</span><br>        Executor executor = Executors.newCachedThreadPool();<br>        <span class="hljs-comment">// 事件工厂</span><br>        LongEventFactory factory = <span class="hljs-keyword">new</span> LongEventFactory();<br>        <span class="hljs-comment">// ringBuffer 的缓冲区的大小是1024</span><br>        <span class="hljs-keyword">int</span> bufferSize = <span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">// 创建一个disruptor, ProducerType.MULTI:创建一个环形缓冲区支持多事件发布到一个环形缓冲区</span><br>        Disruptor&lt;LongEvent&gt; disruptor = <span class="hljs-keyword">new</span> Disruptor&lt;&gt;(factory, bufferSize, executor, ProducerType.MULTI, <span class="hljs-keyword">new</span> BlockingWaitStrategy());<br>        <span class="hljs-comment">// 创建一个消费者</span><br>        disruptor.handleEventsWith(<span class="hljs-keyword">new</span> LongEventHandler());<br>        <span class="hljs-comment">// 启动并初始化disruptor</span><br>        disruptor.start();<br>        <span class="hljs-comment">// 获取已经初始化好的ringBuffer</span><br>        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();<br><br>        <span class="hljs-comment">// 生产数据</span><br>        LongEventProducer producer = <span class="hljs-keyword">new</span> LongEventProducer(ringBuffer);<br>        ByteBuffer bb = ByteBuffer.allocate(<span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> l = <span class="hljs-number">0</span>; <span class="hljs-keyword">true</span>; l++) &#123;<br>            bb.putLong(<span class="hljs-number">0</span>, l);<br>            producer.onData(bb);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>7.demo结果输出</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/image-20191218180407076.png" class="">

<p><strong>Disruptor的一些核心介绍</strong></p>
<p><strong>1.RingBuffer</strong></p>
<p>RingBuffer是其核心，生产者向RingBuffer中写入元素，消费者从RingBuffer中消费元素。</p>
<p>随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。</p>
<p>槽的个数是2的N次方更有利于基于二进制的计算机进行计算。（注：2的N次方换成二进制就是1000，100，10，1这样的数字， sequence &amp; （array length－1） = array index，比如一共有8槽，3&amp;（8－1）=3，HashMap就是用这个方式来定位数组元素的，这种方式比取模的速度更快。）</p>
<p>会预先分配内存,可以做到完全的内存复用。在系统的运行过程中，不会有新的空间需要分配或者老的空间需要回收。因此，可以大大减少系统分配空间以及回收空间的额外开销。</p>
<p>关于RingBuffer可以直观的看一下下面的这幅图片（网上copy的），表示取到编号为4的数据。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/image-20191218180458585.png" class="">

<p><strong>2.消费者等待策略</strong></p>
<p>BlockingWaitStrategy：这是默认的策略。使用锁和条件进行数据的监控和线程的唤醒。因为涉及到线程的切换，是最节省CPU，但在高并发下性能表现最糟糕的一种等待策略。</p>
<p>SleepingWaitStrategy:会自旋等待数据，如果不成功，才让出cpu，最终进行线程休眠，以确保不占用太多的CPU数据，因此可能产生比较高的平均延时。比较适合对延时要求不高的场合，好处是对生产者线程的影响最小。典型的应用场景是异步日志。</p>
<p>YieldingWaitStrategy:用于低延时的场合。消费者线程不断循环监控缓冲区变化，在循环内部，会使用Thread.yield()让出cpu给别的线程执行时间。</p>
<p>BusySpinWaitStrategy:开启的是一个死循环监控，消费者线程会尽最大努力监控缓冲区变化，因此，CPU负担比较大</p>
<p><strong>3.Disruptor的应用场景</strong></p>
<p>Disruptor号称能够在一个线程里每秒处理 6 百万订单,实际上我也没有测试过。Disruptor实际上内部是使用环形队列来实现的，所以一般来说，在消费者和生产者的场景中都可以考虑使用Disruptor。比如像日志处理之类的。实际上，我个人觉得Disruptor就像是Java里面的ArrayBlockingQueue的替代者，因为Disruptor可以提供更高的并发度和吞吐量。从下面这幅官网的图就可以直观的感受到Disruptor和ArrayBlockingQueue之间的效率的对比。(注意这是一个对数对数尺度，不是线性的。)</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640.webp" class="">

<h1 id="资料二（Disruptor为什么这么快？）"><a href="#资料二（Disruptor为什么这么快？）" class="headerlink" title="资料二（Disruptor为什么这么快？）"></a>资料二（Disruptor为什么这么快？）</h1><p><strong>Padding Cache Line，体验高速缓存的威力</strong></p>
<p>我们先来看看 Disruptor 里面一段神奇的代码。这段代码里，Disruptor 在 RingBufferPad 这个类里面定义了 p1，p2 一直到 p7 这样 7 个 long 类型的变量。</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RingBufferPad</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5, p6, p7;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721121761.webp" class="">

<p>面临这样一个情况，Disruptor 里发明了一个神奇的代码技巧，这个技巧就是缓存行填充。Disruptor 在 RingBufferFields 里面定义的变量的前后，分别定义了 7 个 long 类型的变量。前面的 7 个来自继承的 RingBufferPad 类，后面的 7 个则是直接定义在 RingBuffer 类里面。这 14 个变量没有任何实际的用途。我们既不会去读他们，也不会去写他们。</p>
<p>而 RingBufferFields 里面定义的这些变量都是 final 的，第一次写入之后不会再进行修改。所以，一旦它被加载到 CPU Cache 之后，只要被频繁地读取访问，就不会再被换出 Cache 了。这也就意味着，对于这个值的读取速度，会是一直是 CPU Cache 的访问速度，而不是内存的访问速度。</p>
<p><strong>使用 RingBuffer，利用缓存和分支预测</strong></p>
<p>其实这个利用 CPU Cache 的性能的思路，贯穿了整个 Disruptor。Disruptor 整个框架，其实就是一个高速的生产者 - 消费者模型（Producer-Consumer）下的队列。生产者不停地往队列里面生产新的需要处理的任务，而消费者不停地从队列里面处理掉这些任务。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721233410.webp" class="">

<p>如果你熟悉算法和数据结构，那你应该非常清楚，如果要实现一个队列，最合适的数据结构应该是链表。我们只要维护好链表的头和尾，就能很容易实现一个队列。生产者只要不断地往链表的尾部不断插入新的节点，而消费者只需要不断从头部取出最老的节点进行处理就好了。我们可以很容易实现生产者 - 消费者模型。实际上，Java 自己的基础库里面就有 LinkedBlockingQueue 这样的队列库，可以直接用在生产者 - 消费者模式上。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721247878.webp" class="">

<p>不过，Disruptor 里面并没有用 LinkedBlockingQueue，而是使用了一个 RingBuffer 这样的数据结构，这个 RingBuffer 的底层实现则是一个固定长度的数组。比起链表形式的实现，数组的数据在内存里面会存在空间局部性。</p>
<p>就像上面我们看到的，数组的连续多个元素会一并加载到 CPU Cache 里面来，所以访问遍历的速度会更快。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个 Cache Line 加载后数据连续从高速缓存里面被访问到的优势。</p>
<p>除此之外，数据的遍历访问还有一个很大的优势，就是 CPU 层面的分支预测会很准确。这可以使得我们更有效地利用了 CPU 里面的多级流水线，我们的程序就会跑得更快。</p>
<p><strong>总结延伸</strong></p>
<p>好了，不知道讲完这些，你有没有体会到 Disruptor 这个框架的神奇之处呢？</p>
<p>CPU 从内存加载数据到 CPU Cache 里面的时候，不是一个变量一个变量加载的，而是加载固定长度的 Cache Line。如果是加载数组里面的数据，那么 CPU 就会加载到数组里面连续的多个数据。所以，数组的遍历很容易享受到 CPU Cache 那风驰电掣的速度带来的红利。</p>
<p>对于类里面定义的单独的变量，就不容易享受到 CPU Cache 红利了。因为这些字段虽然在内存层面会分配到一起，但是实际应用的时候往往没有什么关联。于是，就会出现多个 CPU Core 访问的情况下，数据频繁在 CPU Cache 和内存里面来来回回的情况。而 Disruptor 很取巧地在需要频繁高速访问的变量，也就是 RingBufferFields 里面的 indexMask 这些字段前后，各定义了 7 个没有任何作用和读写请求的 long 类型的变量。</p>
<p>这样，无论在内存的什么位置上，这些变量所在的 Cache Line 都不会有任何写更新的请求。我们就可以始终在 Cache Line 里面读到它的值，而不需要从内存里面去读取数据，也就大大加速了 Disruptor 的性能。</p>
<p>这样的思路，其实渗透在 Disruptor 这个开源框架的方方面面。作为一个生产者 - 消费者模型，Disruptor 并没有选择使用链表来实现一个队列，而是使用了 RingBuffer。RingBuffer 底层的数据结构则是一个固定长度的数组。这个数组不仅让我们更容易用好 CPU Cache，对 CPU 执行过程中的分支预测也非常有利。更准确的分支预测，可以使得我们更好地利用好 CPU 的流水线，让代码跑得更快。</p>
<h1 id="资料三（Disruptor无锁框架为啥这么快）"><a href="#资料三（Disruptor无锁框架为啥这么快）" class="headerlink" title="资料三（Disruptor无锁框架为啥这么快）"></a>资料三（Disruptor无锁框架为啥这么快）</h1><p><strong>1.1 CPU缓存</strong></p>
<p>在现代计算机当中，CPU是大脑，最终都是由它来执行所有的运算。而内存(RAM)则是血液，存放着运行的数据；但是，由于CPU和内存之间的工作频率不同，CPU如果直接去访问内存的话，系统性能将会受到很大的影响，所以在CPU和内存之间加入了三级缓存，分别是L1、L2、L3。</p>
<p>当CPU执行运算时，它首先会去L1缓存中查找数据，找到则返回；如果L1中不存在，则去L2中查找，找到即返回；如果L2中不存在，则去L3中查找，查到即返回。如果三级缓存中都不存在，最终会去内存中查找。对于CPU来说，走得越远，就越消耗时间，拖累性能。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721576044.webp" class="">

<p>在三级缓存中，越靠近CPU的缓存，速度越快，容量也越小，所以L1缓存是最快的，当然制作的成本也是最高的，其次是L2、L3。</p>
<p>CPU频率，就是CPU运算时的工作的频率（1秒内发生的同步脉冲数）的简称，单位是Hz。主频由过去MHZ发展到了当前的GHZ（1GHZ=10^3MHZ=10^6KHZ= 10^9HZ）。</p>
<p>内存频率和CPU频率一样，习惯上被用来表示内存的速度，内存频率是以MHz（兆赫）为单位来计量的。目前较为主流的内存频率1066MHz、1333MHz、1600MHz的DDR3内存，2133MHz、2400MHz、2666MHz、2800MHz、3000MHz、3200MHz的DDR4内存。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721594437.webp" class="">

<p>可以看得出，如果CPU直接访问内存，是一件相当耗时的操作。</p>
<p><strong>1.2 缓存行</strong></p>
<p>当数据被加载到三级缓存中，它是以缓存行的形式存在的，不是一个单独的项，也不是单独的指针。</p>
<p>在CPU缓存中，数据是以缓存行(cache line)为单位进行存储的，每个缓存行的大小一般为32—256个字节，常用CPU中缓存行的大小是64字节；CPU每次从内存中读取数据的时候，会将相邻的数据也一并读取到缓存中，填充整个缓存行；</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721623615.webp" class="">

<p>可想而知，当我们遍历数组的时候，CPU遍历第一个元素时，与之相邻的元素也会被加载到了缓存中，对于后续的遍历来说，CPU在缓存中找到了对应的数据，不需要再去内存中查找，效率得到了巨大的提升；</p>
<p>但是，在多线程环境中，也会出现伪共享的情况，造成程序性能的降低，堪称无形的性能杀手。</p>
<p><strong>1.2.1 缓存命中</strong></p>
<p>通过具体的例子，来阐述缓存命中和未命中之间的效率：</p>
<p>测试代码：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheHit</span> </span>&#123;<br><br>    <span class="hljs-comment">//二维数组：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span>[][] longs;<br><br>    <span class="hljs-comment">//一维数组长度：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> length = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建二维数组,并赋值：</span><br>        longs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[length][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span> ;x &lt; length;x++)&#123;<br>            longs[x] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">6</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span> ;y&lt;<span class="hljs-number">6</span>;y++)&#123;<br>                longs[x][y] = <span class="hljs-number">1L</span>;<br>            &#125;<br>        &#125;<br>        cacheHit();<br>         cacheMiss();<br>    &#125;<br>    <span class="hljs-comment">//缓存命中：</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheHit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>; x &lt; length; x++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;<span class="hljs-number">6</span>;y++)&#123;<br>                sum += longs[x][y];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">"命中耗时："</span>+(System.nanoTime() - start));<br>    &#125;<br>    <span class="hljs-comment">//缓存未命中：</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheMiss</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x &lt; <span class="hljs-number">6</span>;x++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y &lt; length;y++)&#123;<br>                sum += longs[y][x];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">"未命中耗时："</span>+(System.nanoTime() - start));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">未命中耗时：<span class="hljs-number">43684518</span><br>命中耗时：<span class="hljs-number">19244507</span><br></code></pre></td></tr></table></figure>

<p>在Java中，一个long类型是8字节，而一个缓存行是64字节，因此一个缓存行可以存放8个long类型。但是，在内存中的布局中，对象不仅包含了实例数据(long类型变量)，还包含了对象头。对象头在32位系统上占用8字节，而64位系统上占用16字节。</p>
<p>所以，在上面的例子中，笔者向二维数组中填充了6个元素，占用了48字节。</p>
<p>在cacheHit()的例子中，当第一次遍历的时候，获取longs[0][0]，而longs[0][0]—longs[0][5]也同时被加载到了缓存行中，接下来获取longs[0][1]，已存在缓存行中，直接从缓存中获取数据，不用再去内存中查找，以此类推；</p>
<p>在cacheMiss()的例子中，当第一次遍历的时候，也是获取longs[0][0]的数据，longs[0][0]—longs[0][5]也被加载到了缓存行中，接下来获取long[1][0]，不存在缓存行中，去内存中查找，以此类推；</p>
<p>以上的例子可以充分说明缓存在命中和未命中的情况下，性能之间的差距。</p>
<p><strong>1.2.2 伪共享</strong></p>
<p>由于CPU加载机制，某个数据被加载的同时，其相邻的数据也会被加载到CPU当中。在得到CPU免费加载的同时，也产生了不好的情况；俗话说得好，凡事都有利有弊。</p>
<p>在我们的java程序中，当多个线程修改两个独立变量的时候，如果这两个变量存在于一个缓存行中，那么就有很大的概率产生伪共享。</p>
<p>这是为什么呢？</p>
<p>现如今，CPU都是多核处理器，一般为2核或者4核，当我们程序运行时，启动了多个线程。例如：核心1启动了1个线程，核心2启动了1个线程，这2个线程分别要修改不同的变量，其中核心1的线程要修改x变量，而核心2的线程要修改y变量，但是x、y变量在内存中是相邻的数据，他们被加载到了同一个缓存行当中，核心1的缓存行有x、y，核心2的缓存行也有x、y。</p>
<p>那么，只要有一个核心中的线程修改了变量，另一个核心的缓存行就会失效，导致数据需要被重新到内存中读取，无意中影响了系统的性能，这就是伪共享。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721831140.webp" class="">

<p>cpu的伪共享问题本质是：几个在内存中相邻的数据，被CPU的不同核心加载在同一个缓存行当中，数据被修改后，由于数据存在同一个缓存行当中，进而导致缓存行失效，引起缓存命中降低。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721844773.webp" class="">

<p>代码例子：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FalseShare</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-comment">//线程数、数组大小：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_THREADS = <span class="hljs-number">4</span>; <span class="hljs-comment">// change</span><br><br>    <span class="hljs-comment">//数组迭代的次数：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> ITERATIONS = <span class="hljs-number">500L</span> * <span class="hljs-number">1000L</span> * <span class="hljs-number">1000L</span>;<br><br>    <span class="hljs-comment">//线程需要处理的数组元素角标：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> handleArrayIndex;<br><br>    <span class="hljs-comment">//操作数组：</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> VolatileLong[] longs = <span class="hljs-keyword">new</span> VolatileLong[NUM_THREADS];<br><br>    <span class="hljs-comment">//对数组的元素进行赋值：</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; longs.length; i++) &#123;<br>            longs[i] = <span class="hljs-keyword">new</span> VolatileLong();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FalseShare</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> handleArrayIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.handleArrayIndex = handleArrayIndex;<br>    &#125;<br><br>    <span class="hljs-comment">//启动线程，每一个线程操作一个数组的元素，一一对应：</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//程序睡眠必须加上：</span><br>        Thread.sleep(<span class="hljs-number">10000</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = System.nanoTime();<br><br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[NUM_THREADS];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> FalseShare(i));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : threads) &#123;<br>            t.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread t : threads) &#123;<br>            t.join();<br>        &#125;<br>        System.out.println(System.nanoTime() - start);<br>    &#125;<br><br>    <span class="hljs-comment">//对数组的元素进行操作：</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> i = ITERATIONS;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> != --i) &#123;<br>            longs[handleArrayIndex].value = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//数组元素：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileLong</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value = <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5; <span class="hljs-comment">//代码1</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> p6;<span class="hljs-comment">//代码1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果：（纳秒）</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">未注释代码<span class="hljs-number">1</span>：<span class="hljs-number">19830512</span>      <span class="hljs-number">18472356</span>     <span class="hljs-number">19993249</span>    <span class="hljs-number">19841462</span><br>注释代码<span class="hljs-number">1</span>：  <span class="hljs-number">21141471</span>      <span class="hljs-number">25611265</span>     <span class="hljs-number">19939633</span>    <span class="hljs-number">29976847</span><br></code></pre></td></tr></table></figure>

<p>通过测试结果，可以看出，在注释掉代码后，性能明显下降。让我们来阐述下原因：</p>
<p>通过代码，我们可以看出来，程序模拟的情况就是每一个线程操作数组中的一个元素，例如：线程1操作longs[0]，线程2操作longs[1]，线程3操作longs[2]…以此类推；之前说过，CPU缓存中是以缓存行为单位来进行存储的，一个缓存行大小为64字节。在程序中VolatileLong对象，正好满足64字节，为什么这么说？</p>
<p>在Java程序中，对象在内存中的分布：对象头（Header），实例数据（Instance Data），对齐填充（Padding）；</p>
<p>其中，对象头在32位系统上占用8字节，64位系统上占用16字节；实例数据也就是我们平常是所用到的基本类型和引用类型；对齐填充是对象在内存区域内的补充，jvm要求对象在内存区域的大小必须是8的整数倍，所以当对象头+实例数据的和不是8的整数倍时，就需要用到对齐填充，少多少就填充多少无效数据；</p>
<p>综上所述，VolatileLong=对象头(12字节)+value(8字节)+p1-p5(40字节)+p6(4字节) = 64字节，正好填充满整个缓存行；</p>
<p>当我们没有注释掉代码的时候，数组的各个元素将分布在不同的缓存行当中；而当注释掉代码的时候，数组的元素有很大的几率分布在同一个缓存行当中；当不同线程操作元素的时候，就会产生冲突，产生伪共享，影响系统性能；</p>
<p>经过上面的叙述，你大概对伪共享有了一定的了解，但是你会不会有这样的疑问？为什么其中1个核心缓存行的数据被修改了，其余核心中的缓存行就失效了？是什么机制产生了这样的情况？</p>
<p>以下，我们就来简单的介绍CPU的一致性协议MESI，就是这个协议保证了Cache的一致性；</p>
<p><strong>1.2.3 MESI协议</strong></p>
<p>多核理器中，每个核心都有自己的cache，内存中的数据可以同时处于不同的cache中，若各个核心独立修改自己的cache，就会出现不一致问题。为了解决一致性问题，MESI协议被引入。</p>
<p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的支持写回策略的缓存一致性协议，该协议最早被应用在Intel奔腾系列的CPU中。</p>
<p>其实，MESI协议就是规定了缓存行的4种状态，以及这4种状态之间的流转，以来保证不同核心中缓存的一致；每种状态在缓存行中用2个bit位来进行描述，分别是修改态（M）、独享态（E）、共享态（S）、无效态（I）；</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721907495.webp" class="">

<ul>
<li>E(Exclusive)：x变量只存在于core1中；</li>
</ul>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721931430.webp" class="">

<ul>
<li>S(Shared):x变量存在于core1 core2 core3中</li>
</ul>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721944728.webp" class="">

<ul>
<li>M(Modified)：core1修改了x变量，core2 core3的缓存行被置为无效状态</li>
</ul>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721956301.webp" class="">

<p>在CPU中，每个核心不但控制着自己缓存行的读写操作，而且还监听这其他核心中缓存行的读写操作；每个缓存行的状态受到本核心和其他核心的双重影响；</p>
<p>下面，我们就阐述下这4中状态的流转：</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576721967959.webp" class="">

<figure class="hljs highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sas">(1)I--本地读请求：CPU读取变量<span class="hljs-meta">x</span>，如果其他核中的缓存有变量<span class="hljs-meta">x</span>，且缓存行的状态为M，则将该核心的变量<span class="hljs-meta">x</span>更新到内存，本核心的再从内存中读取取数据，加载到缓存行中，两个核心的缓存行状态都变成S；如果其他核心的缓存行状态为S或者E，本核心从内存中杜取数据，之后所有核心中的包含变量<span class="hljs-meta">x</span>的缓存行状态都变成S。<br><br>(2)I--本地读请求：CPU读取变量<span class="hljs-meta">x</span>，如果其他核中的缓存没有变量<span class="hljs-meta">x</span>，则本核心从内存中读取变量<span class="hljs-meta">x</span>，存入本核心的缓存行当中，该缓存行状态变成E；<br><br>(3)I--本地写请求：CPU读取写入变量<span class="hljs-meta">x</span>，如果其他核中没有此变量，则从内存中读取，在本核心中修改，此缓存行状态变为M；如果其他缓存行中有变量<span class="hljs-meta">x</span>，并且状态为M,则需要先将其他核心中的变量<span class="hljs-meta">x</span>写回内存，本核心再从内存中读取；如果其他缓存行中有变量<span class="hljs-meta">x</span>，并且状态为E/S，则将其他核心中的缓存行状态置为I，本核心在从内存中读取变量<span class="hljs-meta">x</span>，之后将本核心的缓存行置为M；<br><br>注意，一个缓存除在Invalid状态外都可以满足CPU的读请求，一个invalid的缓存行必须从主存中读取（变成S或者 E状态）来满足该CPU的读请求。<br><br>(4)S--远程写请求：多个核心共享变量<span class="hljs-meta">X</span>，其他核心将变量<span class="hljs-meta">x</span>修改，本核心中的缓存行不能使用，状态变为I；<br><br>(5)S--本地读请求：多个核心共享变量<span class="hljs-meta">X</span>，本核心读取本缓存中的变量<span class="hljs-meta">x</span>，状态不变；<br><br>(6)S--远程读请求：多个核心共享变量<span class="hljs-meta">X</span>，其他核心要读取变量<span class="hljs-meta">X</span>，从主内存中读取变量<span class="hljs-meta">x</span>，状态置为S，本核心状态S不变；<br><br>(7)S--本地写请求：多个核心共享变量<span class="hljs-meta">X</span>，本核心修改本缓存行中的变量<span class="hljs-meta">x</span>，必须先将其他核心中所拥有变量<span class="hljs-meta">x</span>的缓存行状态变成I，本核心缓存行状态置为M；该操作通常使用RequestFor Ownership (RFO)广播的方式来完成；<br><br>(8)E--远程读请求：只有本核心拥有变量<span class="hljs-meta">x</span>，其他核心也要读取变量<span class="hljs-meta">x</span>,从内存中读取变量<span class="hljs-meta">x</span>，并将所有拥有变量<span class="hljs-meta">x</span>的缓存行置为S状态；<br><br>(9)E--本地读请求：只有本核心拥有变量<span class="hljs-meta">x</span>，本核心需要读取变量<span class="hljs-meta">x</span>，读取本地缓存行中的变量<span class="hljs-meta">x</span>即可，状态不变依旧为E；<br><br>(10)E--远程写请求：只有本核心拥有变量<span class="hljs-meta">x</span>，其他核心需要修改变量<span class="hljs-meta">x</span>，其他核心从内存中读取变量<span class="hljs-meta">x</span>，进行修改，状态变成M，而本核心中缓存行变为状态I；<br><br>(11)E--本地写请求：只有本核心拥有变量<span class="hljs-meta">x</span>，本核心修改本缓存行中的变量<span class="hljs-meta">x</span>，状态置为M；<br><br>(12)M--本地写请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，本核心进行修改<span class="hljs-meta">x</span>操作，缓存行状态不变；<br><br>(13)M--本地读请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，本核心进行读取<span class="hljs-meta">x</span>操作，缓存行状态不变；<br><br>(14)M--远程读请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，其他核心需要读取变量<span class="hljs-meta">x</span>,先将本核心中的变量<span class="hljs-meta">x</span>写回到内存中，在将本缓存行状态置为S，其他核心拥有变量<span class="hljs-meta">x</span>的缓存行状态也变为S；<br><br>(15)M--远程写请求：只有本核心中拥有变量<span class="hljs-meta">x</span>，其他和核心需要修改变量<span class="hljs-meta">x</span>，先将本核心中的变量<span class="hljs-meta">x</span>写回内存，再将本核心中缓存行置为I。其他核心的在从缓存行中读取变量<span class="hljs-meta">x</span>，修改后置为M；<br></code></pre></td></tr></table></figure>

<p>以上就是MESI协议的状态流转；如果对状态流转还有疑问的话，还可以结合以下图例进行学习：</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722004805.webp" class="">

<p><strong>1.3 CAS</strong></p>
<p>那么，CAS是什么呢？</p>
<p>在Java中，多线程之间如何保证数据的一致性？想必大部分都会异口同声地说出锁—-synchronized锁。在JDK1.5之前，的确是使用synchronized锁来保证数据的一致性。但是，synchronized锁是一种比较重的锁，俗称悲观锁。在较多线程的竞争下，加锁、释放锁会对系统性能产生很大的影响，而且一个线程持有锁，会导致其他线程的挂起，直至锁的释放。</p>
<p>那么，有没有比较轻的锁呢，答案是有的！与之相对应的是乐观锁！乐观锁虽然名称中带有锁，但实际在代码中是不加锁的，乐观锁大多实现体现在数据库sql层面，通常是的做法是：为数据增加一个版本标识，在表中增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<figure class="hljs highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> XXX_TABLE <span class="hljs-keyword">SET</span> MONEY = <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">VERSION</span> = <span class="hljs-number">11</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">ID</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">VERSION</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p>这就是乐观锁！</p>
<p>上面说到了数据库层面的乐观锁，那么代码层面有没有类似的实现？答案是，有的！那就是我们本小节的主角—CAS；</p>
<p>CAS是一个CPU级别的指令，翻译为Compare And Swap比较并交换；</p>
<p>CAS是对内存中共享数据操作的一种指令，该指令就是用乐观锁实现的方式，对共享数据做原子的读写操作。原子本意是“不能被进一步分割的最小粒子”，而原子操作意为”不可被中断的一个或一系列操作”。原子变量能够保证原子性的操作，意思是某个任务在执行过程中，要么全部成功，要么全部失败回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。</p>
<p>CAS有3个操作数，内存中的值V，预期内存中的值A，要修改成的值B。当内存值V和预期值相同时，就将内存值V修改为B，否则什么都不做。</p>
<p>例如：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CasTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> memoryValue = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expectValue;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> updateValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CasTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expectValue,<span class="hljs-keyword">int</span> updateValue)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.expectValue = expectValue;<br>        <span class="hljs-keyword">this</span>.updateValue = updateValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(memoryValue==expectValue)&#123;<br>            <span class="hljs-keyword">this</span>.memoryValue = updateValue;<br>            System.out.println(<span class="hljs-string">"修改成功"</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">"修改失败"</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] agrs)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CasTest casTest1 = <span class="hljs-keyword">new</span> CasTest(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(casTest1);<br>        t1.start();<br><br>        Thread t2= <span class="hljs-keyword">new</span> Thread(casTest1);<br>        t2.start();<br><br>        t1.join();<br>        t2.join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Java中，主要使用了Unsafe类来实现CAS操作，利用JNI来完成CPU指令的调用。JNI：java native interface为java本地调用，也就是说允许java调用其他计算机语言（例如：C、C++等）；</p>
<p>在java.util.concurrent.atomic包下(AtomicInteger为例)：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6214790243416807050L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, valueOffset, expect, update);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际最终调用了sun.misc.Unsafe类：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4, <span class="hljs-keyword">int</span> var5)</span></span>;<br></code></pre></td></tr></table></figure>

<p>可以看到Unsafe的compareAndSwapInt方法，使用了native修饰符，是一个本地方法调用，最终由C++代码来操作CPU。至于具体实现，有兴趣的朋友可以去参考openJDK中Unsafe类；</p>
<p>与synchronized锁相比较而言，CAS最大的优势就是非阻塞，在代码层面，多线程情况下不阻塞其他线程的执行，从而达到既保证数据的安全，又提高了系统的性能。</p>
<p><strong>1.4 Disruptor中的运用</strong></p>
<p>上面，说了分别说了CAS、缓存行、伪共享。接下来，就来看看再Disruptor中是如何使用的！</p>
<p>在多生产者的环境下，更新下一个可用的序列号地方，我们使用CAS（Compare And Swap）操作。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722127388.webp" class="">

<p>Disruptor中多生产者情况下，获取下一个可用序列号的实现:</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiProducerSequencer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequencer</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>        &#125;<br>        <span class="hljs-keyword">long</span> current;<br>        <span class="hljs-keyword">long</span> next;<br>        <span class="hljs-keyword">do</span>&#123;<br>            current = cursor.get();<br>            next = current + n;<br>            <span class="hljs-keyword">long</span> wrapPoint = next - bufferSize;<br>            <span class="hljs-keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();<br>            <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current)&#123;<br>                <span class="hljs-keyword">long</span> gatingSequence = Util.getMinimumSequence(gatingSequences, current);<br><br>                <span class="hljs-keyword">if</span> (wrapPoint &gt; gatingSequence)&#123;<br>                    waitStrategy.signalAllWhenBlocking();<br>                    LockSupport.parkNanos(<span class="hljs-number">1</span>); <span class="hljs-comment">// TODO, should we spin based on the wait strategy?</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                gatingSequenceCache.set(gatingSequence);<br><br>            <span class="hljs-comment">//对current,next进行compareAndSet，cursor就是序列号对象：</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cursor.compareAndSet(current, next))&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Disruptor通过缓存行填充的方式来解决伪共享：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LhsPadding</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5, p6, p7;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LhsPadding</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> value;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RhsPadding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Value</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> p9, p10, p11, p12, p13, p14, p15;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sequence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RhsPadding</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>Sequence是Disruptor中序列号对象，value是对象具体的序列值，通过上面的方式，value不会与其他需要操作的变量存在同一个缓存行中。</p>
<h1 id="资料四（Disruptor之概览）"><a href="#资料四（Disruptor之概览）" class="headerlink" title="资料四（Disruptor之概览）"></a>资料四（Disruptor之概览）</h1><p><strong>概述</strong></p>
<p>“多核危机”驱动了并发编程的复兴，然后并发编程和一般的系统相比，复杂性有个很大梯度的上升。多线程开发很大困难在于：多个线程间存在依赖关系时，如何进行协调。依赖一方面是执行顺序的依赖，如某个线程执行需要依赖其他线程执行或其它线程的某些阶段执行结果，Java为我们提供的解决方案是：wait/notify、lock/condition、join、yield、Semaphore、CountDownLatch、CyclicBarrier以及JDK7新增的一个Phaser等；数据依赖主要是多个线程对同一资源并发修改导致的数据状态不一致问题，Java中主要依靠Lock和CAS两种方案，也就是我们熟知的悲观锁、乐观锁。</p>
<p>然而，当你在并发编程方面慢慢有些经验并开始在项目中使用时，你会发现仅仅依赖JDK提供的上面所说开发工具类是远远不够的， JDK提供的工具类都只能解决一个个功能“点”的问题。并发编程复杂性一个体现就是：多个顺序执行流在多核CPU中同时并行执行与我们已经习惯的单个数据顺序流执行的方式产生了很大的冲突。</p>
<p>好比：现在你开车从A地到B地去，传统的开发模式就像从A地到B地之间只存在一条公路，你只需要延着这个公路一直开下去就可以达到B地；假如经过多年发展，现在A地到B地横起有10条公路，纵起有10条公路，它们之间相互交叉形成错综复杂的公路网，你再开车从A地到B地就会存在太多的选择，可能从东南西北任何方向出发最终都能到达B地。这就体现了并发编程和传统编程复杂性的对比：传统编程由于只存在一个顺序执行流，可以很好的预判程序的执行流程；而并发编程存在太多的顺序执行流导致很难准确的预判出它们真正的执行流程，一旦出现问题也很难排查，就好比上面的例子第二种情况，你很难预判你开车的真正路线，而且可能存在每次路线都不一样情况。</p>
<p>我认为一个并发编程项目好坏其中一个关键核心就是：项目的整体结构是否清晰。很简单的一个例子，调用notify()方法唤醒挂起在指定对象上的休眠线程，如果没有一个清晰简单的架构设计，可能会导致在该对象上进行休眠的对象散落到系统中各处代码上，很难把控具体唤醒的是哪个线程从而与你的业务逻辑发生偏差导致bug的出现。当然，项目结构清晰在传统编程中也是非常看重的，只有结构清晰的架构才会让人易于理解，同时和他人沟通探讨时方便描述，但是在并发编程中这点尤为重要，因为并发编程的复杂性更高，没有一个清晰的结构设计，你可能经过大量测试修改暂时做出了一个看似没有bug的项目，但是后期需求变更或者是其他人来维护这个项目时，很难下手导致后期会引入大量的bug，而且不利于项目功能的扩展。</p>
<p>常用的并发编程使用的模型有并行模型、流水线模型、生产者/消费者模型、Actor模型等，采用模型设计一方面是因为这些模型都是大牛们经过长时间实际生产经验的积累总结出的并发编程方面一些好的解决方案；另一方面，采用模型设计可以解决相关人员之间沟通信息不对等问题，降低沟通学习成本。</p>
<p>并行模型是JDK8中Stream所采用的实现并发编程的方式，并行模型非常简单，就是为每个任务分配一个线程直到该任务执行结束，示意图如下：</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722373615.webp" class="">

<p>并行模型太过简单导致对任务的精细化控制不足，一个任务可能会被分解为多个阶段，而每个阶段的子任务特性可能差别很大，这时并行模型就无能为力了。并行模型只适合于CPU密集型且任务中不含IO阻塞等情况的任务。这时，就演进出流水线模型，示意图如下：</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722417189.webp" class="">

<p>流水线模型在实际的并发编程中使用比较常见，我们所说的Pipeline设计模型、Netty框架等都是这一思想的体现。</p>
<p>生产者/消费者模型在并发编程中也是使用频度非常高的一个模型，生产者/消费者模型可以很容易地将生产和消费进行解耦，优化系统整体结构，并且由于存在缓冲区，可以缓解两端性能不匹配的问题。</p>
<p>Actor模型其典型代表就是Akka，基于Akka可以轻松实现一个分布式异步数据处理集群系统，非常强大，后期我们有机会可以再深入讨论下Akka。</p>
<p>好了，说了这么多，终于要开始正题：Disruptor，官方宣传基于该框架构建的系统单线程可以支撑每秒处理600万订单，此框架真乃惊为天人。Disruptor在生产者/消费者模型上获得尽量高的吞吐量和尽量低的延迟，其目标就是在性能优化方面做到极致。国内国外都存在大量的知名项目在广泛使用，比如我们所熟知的strom底层就依赖Disruptor的实现，其在并发、缓存区、生产者/消费者模型、事务处理等方面都存在一些性能优秀的方案，因此是非常值得深入研究的。</p>
<p><strong>生产者/消费者模型</strong></p>
<p>生产者/消费者模型在编程中使用频度非常高的一个模型，生产者/消费者模型可以很容易地将生产和消费进行解耦，优化系统整体结构，并且由于存在缓冲区，可以缓解两端性能不匹配的问题。生产者/消费者和我们所熟悉的设计模式中的观察者模型很相似，生产者类似于被观察者，消费者类似于观察者，被观察者的任何变动都以事件的方式通知到观察者；同理，生产者生产的数据都要传递给消费者最终都要被消费者处理。</p>
<p>一般项目开发中，我们可以使用JDK提供的阻塞队列BlockingQueue很简单的实现一个生产者/消费者模型，其中生产者线程负责提交需求，消费者线程负责处理任务，二者之间通过共享内存缓冲区进行通信。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722441766.webp" class="">

<p>BlockingQueue实现类主要有两个：ArrayBlockingQueue和LinkedBlockingQueue，底层实现一个是基于数组的，一个是基于链表的，这种实现方式的差异导致了它们使用场景的不一样。在生产者/消费者模型中的缓存设计上肯定优先使用ArrayBlockingQueue，但是查看ArrayBlockingQueue底层源码会发现，读写操作通过重入锁实现同步，而且读写操作使用的是同一把锁，并没有实现读写锁分离；另外，锁本身的成本还是比较高的，锁容易导致线程上下文频繁的发生切换，了解CPU核存储硬件架构的可能会知道，每核CPU都会存在一个独享的高速缓存L1，假如线程切换到其它CPU上执行会导致之前CPU高速缓存L1中的数据不能再被使用，降低了高速缓存使用效率。因此，在高并发场景下，性能不是很优越。</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//向Queue中写入数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       checkNotNull(e);<br>       <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>       lock.lockInterruptibly();<span class="hljs-comment">//可中断方式获取锁，实现同步</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == items.length)<br>               notFull.await();<br>           insert(e);<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>&#125;<br><br><span class="hljs-comment">//从Queue中取出数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>       lock.lockInterruptibly();<span class="hljs-comment">//可中断方式获取锁，实现同步</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>               notEmpty.await();<br>           <span class="hljs-keyword">return</span> dequeue();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Disruptor消息生产模型</strong></p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576722855401.webp" class="">

<p>Producer生产出一个消息事件Event，需要放入到RingBuffer中，流程大致如下：</p>
<p>1、首先调用Sequencer.next()方法，获取RingBuffer上可用的序号用于将新生成的消息事件放入；</p>
<p>2、Sequencer首先对nextValue+1代表当前需要申请的RingBuffer序号(nextValue标记了之前已经申请过的序号,nextValue+1就是下一个可申请的序号)，但是nextValue+1指向的RingBuffer槽位存放的消息可能并没有被消费，如果直接返回这个序号给生产者，就会导致生产一方将该槽位的消息事件重新填充覆盖导致之前数据丢失，这里就需要一个判断：判断申请的RingBuffer序号代表的槽位之前的消息事件是否已被消费，判断逻辑如下：</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//n表示此次生产者期望获取多少个序号，通常是1</span><br>    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>    &#125;<br>    <span class="hljs-keyword">long</span> nextValue = <span class="hljs-keyword">this</span>.nextValue;<br>    <span class="hljs-comment">//这里n一般是1，代表申请1个可用槽位，nextValue+n就代表了期望申请的可用槽位序号</span><br>    <span class="hljs-keyword">long</span> nextSequence = nextValue + n;<br>    <span class="hljs-comment">//减掉RingBuffer的bufferSize值，用于判断是否出现‘绕圈覆盖’</span><br>    <span class="hljs-keyword">long</span> wrapPoint = nextSequence - bufferSize;<br>    <span class="hljs-comment">//cachedValue缓存之前获取的最慢消费者消费到的槽位序号</span><br>    <span class="hljs-keyword">long</span> cachedGatingSequence = <span class="hljs-keyword">this</span>.cachedValue;<br>    <span class="hljs-comment">//如果申请槽位序号-bufferSize比最慢消费者序号还大，代表生产者绕了一圈后又追赶上了消费者，这时候就不能继续生产了，否则把消费者还没消费的消息事件覆盖</span><br>    <span class="hljs-keyword">if</span>(wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123;<br>        <span class="hljs-comment">/**<br>         cursor代表当前已经生产完成的序号，了解多线程可见性可能会知道：<br>         1、CPU和内存间速度不匹配，硬件架构上一般会在内存和CPU间还会存在L1、L2、L3三级缓存<br>         2、特别是L1高速缓存是CPU间相互独立不能共享的，线程操作可以看着基于L1缓存进行操作，就会导致线程间修改不会立即被其它线程感知，只有L1缓存的修改写入到主存然后其它线程将主存修改刷新到自己的L1缓存，这时线程1的修改才会被其它线程感知到<br>         3、线程修改对其它线程不能立即可见特别是在高并发下可能会带来些问题，JAVA中使用volatile可以解决可见性问题<br>         4、这里就是采用UNSAFE.putLongVolatile()插入一个StoreLoad内存屏障，具体可见JMM模型，主要保证cursor的真实值对所有的消费线程可见，避免不可见下消费线程无法消费问题<br>         */</span><br>        cursor.setVolatile(nextValue);<br>        <span class="hljs-keyword">long</span> minSequence;<br>        <span class="hljs-comment">//Util.getMinimumSequence(gatingSequences, nextValue)获取当前时刻所有消费线程中，消费最慢的序号</span><br>        <span class="hljs-comment">//上面说过cachedValue是缓存的消费者最慢的序号</span><br>        <span class="hljs-comment">//这样做目的：每次都去获取真实的最慢消费线程序号比较浪费资源，而是获取一批可用序号后，生产者只有使用完后，才继续获取当前最慢消费线程最小序号，重新获取最新资源</span><br>        <span class="hljs-keyword">while</span>(wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue))) &#123;<br>            <span class="hljs-comment">//如果获取最新最慢消费线程最小序号后，依然没有可用资源，做两件事：</span><br>            <span class="hljs-comment">//    1、唤醒waitStrategy上所有休眠线程，这里即是消费线程(避免因消费线程休眠而无法消费消息事件导致生产线程一直获取不到资源情况)</span><br>            <span class="hljs-comment">//    2、自旋休眠1纳秒</span><br>            <span class="hljs-comment">//可以看到，next()方法是一个阻塞接口，如果一直获取不到可用资源，就会一直阻塞在这里</span><br>            waitStrategy.signalAllWhenBlocking();<br>            LockSupport.parkNanos(<span class="hljs-number">1</span> L);<br>        &#125;<br>        <span class="hljs-comment">//有可用资源时，将当前最慢消费线程序号缓存到cachedValue中，下次再申请时就可不必再进入if块中获取真实的最慢消费线程序号，只有这次获取到的被生产者使用完才会继续进入if块</span><br>        <span class="hljs-keyword">this</span>.cachedValue = minSequence;<br>    &#125;<br>    <span class="hljs-comment">//申请成功，将nextValue重新设置，下次再申请时继续在该值基础上申请</span><br>    <span class="hljs-keyword">this</span>.nextValue = nextSequence;<br>    <span class="hljs-comment">//返回申请到RingBuffer序号</span><br>    <span class="hljs-keyword">return</span> nextSequence;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、申请到可用序号后，提取RingBuffer中该序号中的Event，并重置Event状态为当前最新事件状态</p>
<p>4、重置完成后，调用Sequencer.publish()提交序号，提交序号主要就是修改cursor值，cursor标记已经生产完成序号，这样消费线程就可以来消费事件了</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-comment">//修改cursor序号，消费者就可以进行消费</span><br>    cursor.set(sequence);<br>    <span class="hljs-comment">//唤醒消费线程，比如消费线程消息到无可用消息时可能会进入休眠状态，当放入新消息就需要唤醒休眠的消费线程</span><br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结：消息事件生产主要包含三个步骤：</p>
<p>1、申请序号：表示从RingBuffer上获取可用的资源</p>
<p>2、填充事件：表示获取到RingBuffer上可用资源后，将新事件放入到该资源对应的槽位上</p>
<p>3、提交序号：表示第二部新事件放入到RingBuffer槽位全部完成，提交序号可供消费线程开始消费</p>
<p><strong>Disruptor消息处理模型</strong></p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576723548323.webp" class="">

<p>消息处理端需要从RingBuffer中提取可用的消息事件，并注入到用户的业务逻辑中进行处理，流程大致如下：</p>
<p>1、消费端核心类是EventProcessor，它实现了Runnable接口，Disruptor在启动的时候会将所有注册上来的EventProcessor提交到线程池中执行，因此，一个EventProcessor可以看着一个独立的线程流用于处理RingBuffer上的数据</p>
<p>2、EventProcessor通过调用SequenceBarrier.waitFor()方法获取可用消息事件的序号，其实SequenceBarrier内部还是调用WaitStrategy.waitFor()方法，WaitStrategy等待策略主要封装如果获取消息时没有可用消息时如何处理的逻辑信息，是自旋、休眠、直接返回等，不同场景需要使用不同策略才能实现最佳的性能</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* ProcessingSequenceBarrier中核心方法只有一个：waitFor(long sequence)，传入希望消费得到起始序号，返回值代表可用于消费处理的序号，一般返回可用序号&gt;=sequence，但也不一定，具体看WaitStrategy实现<br>* 总结：<br>*      1、sequence：EventProcessor传入的需要进行消费的起始sequence<br>*      2、这里并不保证返回值availableSequence一定等于given sequence，他们的大小关系取决于采用的WaitStrategy<br>*          a.YieldingWaitStrategy在自旋100次尝试后，会直接返回dependentSequence的最小seq，这时并不保证返回值&gt;=given sequence<br>*          b.BlockingWaitStrategy则会阻塞等待given sequence可用为止，可用并不是说availableSequence == given sequence，而应当是指 &gt;=<br>*          c.SleepingWaitStrategy:首选会自旋100次，然后执行100次Thread.yield()，还是不行则LockSupport.parkNanos(1L)直到availableSequence &gt;= given sequence<br>*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span><br><span class="hljs-keyword">throws</span> AlertException, InterruptedException, TimeoutException </span>&#123;<br>    checkAlert();<br>    <span class="hljs-comment">//调用WaitStrategy获取RingBuffer上可用消息序号，无可消费消息是该接口可能会阻塞，具体逻辑由WaitStrategy实现</span><br>    <span class="hljs-keyword">long</span> availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span>(availableSequence &lt; sequence) &#123;<br>        <span class="hljs-keyword">return</span> availableSequence;<br>    &#125;<br>    <span class="hljs-comment">//获取消费者可以消费的最大的可用序号，支持批处理效应，提升处理效率。</span><br>    <span class="hljs-comment">//当availableSequence &gt; sequence时，需要遍历 sequence --&gt; availableSequence，找到最前一个准备就绪，可以被消费的event对应的seq。</span><br>    <span class="hljs-comment">//最小值为：sequence-1</span><br>    <span class="hljs-keyword">return</span> sequencer.getHighestPublishedSequence(sequence, availableSequence);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、通过waitFor()返回的是一批可用消息的序号，比如申请消费7好槽位，waitFor()返回的可能是8表示从6到8这一批数据都已生产完毕可以进行消费</p>
<p>4、EventProcessor按照顺序从RingBuffer中取出消息事件，然后调用EventHandler.onEvent()触发用户的业务逻辑进行消息处理</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//读取可消费消息序号</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);<br>        <span class="hljs-keyword">if</span>(batchStartAware != <span class="hljs-keyword">null</span>) &#123;<br>            batchStartAware.onBatchStart(availableSequence - nextSequence + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(nextSequence &lt;= availableSequence) &#123;<br>            <span class="hljs-comment">//循环提取所有可供消费的消息事件</span><br>            event = dataProvider.get(nextSequence);<br>            <span class="hljs-comment">//将提取的消息事件注入到封装用户业务逻辑的Handler中</span><br>            eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);<br>            nextSequence++;<br>        &#125;<br>        sequence.set(availableSequence);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5、当这批次的消息处理完成后，继续重复上面操作调用waitFor()继续获取可用的消息序号，周而复始</p>
<p>好了，这节主要对Disruptor的生产模型和消费模型进行了一个简单的介绍，后面会逐渐对Disruptor涉及到的每个核心组件进行分析，了解它们优秀的设计思想。</p>
<h1 id="资料五（Disruptor源码解析-实战）"><a href="#资料五（Disruptor源码解析-实战）" class="headerlink" title="资料五（Disruptor源码解析 + 实战）"></a>资料五（Disruptor源码解析 + 实战）</h1><p><strong>juc下的队列</strong></p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576725625080.webp" class="">

<p>1：从上图可以看出，juc下的队列基本采用加锁方式保证线程安全。通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在限定的范围）。而加锁的方式可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列。</p>
<p>2：加锁的方式通常严重影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。</p>
<p>3：有界队列通常采用数组实现。但是采用数组实现又会引发另外一个问题false sharing(伪共享)。关于什么是伪共享之前的文章已经讲解。</p>
<p><strong>Disruptor</strong></p>
<p><strong>Disruptor是什么</strong></p>
<p>1：Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）</p>
<p>2：Disruptor实现对了队列的功能并且是一个有界队列。可以用于生产者-消费者模型。</p>
<p><strong>Disruptor为什么快</strong></p>
<p>1：数据结构采用ringbuffer。其实可以理解成一个数组entries。每一个slot存储一个事件对象。初始化时，就已经分配好内存，而且新发布的数据只会覆盖，所以更少的GC。</p>
<p>2：Disruptor采用缓存行填充机制的形式解决了fasle sharing。保证读取变量的时候从cache line读取。</p>
<p>3：Disroptor中维护了一个long类型的sequence(序列)。每次根据位运算操作可以快速定位到实际slot，sequece&amp;(entries.length-1)=index，比如一共有4槽，9&amp;(8-1)=1。提示：队列的大小必须要2^n。</p>
<p>4：线程同时访问，由于他们都通过sequence访问ringBuffer，通过CAS取代了加锁，这也是并发编程的原则：把同步块最小化到一个变量上。这个sequence一直采用自增的形式。</p>
<p><strong>Disruptor核心类</strong></p>
<p>1：RingBuffer：Disruptor最主要的组件，仅仅负责存储和更新事件对象。</p>
<p>2：Sequence：Disruptor使用Sequence来表示一个特殊组件处理的序号。和Disruptor一样，每一个消费者（EventProcessor）都维持着一个Sequence。大部分的并发代码依赖这这个值。这个类维护了一个long类型的value，采用的unsafe进行的更新操作。</p>
<p>3：Sequencer：这是Disruptor真正的核心。实现了这个接口的两种生产者（单生产者和多生产者）均实现了所有的并发算法，为了在生产者和消费者之间进行准确快速的数据传递。</p>
<p>4：SequenceBarrier：由Sequencer生成，并且包含了已经发布的Sequence的引用，这些Sequence源于Sequencer和一些独立的消费者的Sequence。它包含了决定是否有供消费者消费的Event的逻辑。用来权衡当消费者无法从RingBuffer里面获取事件时的处理策略。（例如：当生产者太慢，消费者太快，会导致消费者获取不到新的事件会根据该策略进行处理，默认会堵塞）</p>
<p>5：WaitStrategy：决定一个消费者将如何等待生产者将Event置入Disruptor的策略。用来权衡当生产者无法将新的事件放进RingBuffer时的处理策略。（例如：当生产者太快，消费者太慢，会导致生产者获取不到新的事件槽来插入新事件，则会根据该策略进行处理，默认会堵塞）</p>
<p>6：Event：从生产者到消费者过程中所处理的数据单元。Disruptor中没有代码表示Event，因为它完全是由用户定义的。</p>
<p>7：EventProcessor：主要事件循环，处理Disruptor中的Event，并且拥有消费者的Sequence。它有一个实现类是BatchEventProcessor，包含了event loop有效的实现，并且将回调到一个EventHandler接口的实现对象。</p>
<p>8：EventHandler：由用户实现并且代表了Disruptor中的一个消费者的接口。</p>
<p>9：WorkHandler：在work模式下使用。由用户实现并且代表了Disruptor中的多个消费者的接口。</p>
<p>10：WorkProcessor：确保每个sequence只被一个processor消费，在同一个WorkPool中的处理多个WorkProcessor不会消费同样的sequence。</p>
<p>11：WorkerPool：一个WorkProcessor池，其中WorkProcessor将消费Sequence，所以任务可以在实现WorkHandler接口的worker之间移交</p>
<p>12：LifecycleAware：当BatchEventProcessor启动和停止时，实现这个接口用于接收通知。</p>
<p><strong>Sequence(序列)</strong></p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576725694032.webp" class="">

<p>1：Sequence是用来标记事件发布者和事件消费者的位置。</p>
<p>2：Sequence真正计数的是value，采用缓冲行填充防止false sharing。在value的前后各有7个long型的填充值，这些值在这里的作用是做cpu cache line填充，防止发生伪共享。最坏的情况就是value位于cache line的头或者尾。</p>
<p><strong>框架类结构关系图</strong></p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576725713396.webp" class="">

<p><strong>Cursored  获取当前序列值</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cursored</span></span>&#123;<br>    <span class="hljs-comment">/**<br>     * 获取当前序列值<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getCursor</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>1：Cursored接口只提供了一个获取当前序列值的方法。</p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sequenced</span></span>&#123;<br>    <span class="hljs-comment">//获取队列的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBufferSize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//判断队列中是否还有可用的容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAvailableCapacity</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> requiredCapacity)</span></span>;<br>    <span class="hljs-comment">//获取队列中剩余的有效容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">remainingCapacity</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//申请下一个sequence，用于事件发布者发布数据，申请失败则自旋</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//申请n个sequence，用于事件发布者发布数据，申请失败则自旋</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br>    <span class="hljs-comment">//尝试获取一个sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">tryNext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InsufficientCapacityException</span>;<br>    <span class="hljs-comment">//尝试获取n个sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">tryNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> <span class="hljs-keyword">throws</span> InsufficientCapacityException</span>;<br>    <span class="hljs-comment">//发布sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>    <span class="hljs-comment">//批量发布sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lo, <span class="hljs-keyword">long</span> hi)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Sequencer</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sequencer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cursored</span>, <span class="hljs-title">Sequenced</span></span>&#123;<br>    <span class="hljs-comment">//游标初始值</span><br>    <span class="hljs-keyword">long</span> INITIAL_CURSOR_VALUE = -<span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">//初始化RingBuffer为指定的sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">claim</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>    <span class="hljs-comment">//消费者调用，判断sequence是否可以消费</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAvailable</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>    <span class="hljs-comment">//将sequence添加到gating sequences中</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addGatingSequences</span><span class="hljs-params">(Sequence... gatingSequences)</span></span>;<br>    <span class="hljs-comment">//从gating sequences中移除指定的sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeGatingSequence</span><span class="hljs-params">(Sequence sequence)</span></span>;<br>    <span class="hljs-comment">//事件处理者用来追踪ringBuffer中可以用的sequence</span><br>    <span class="hljs-function">SequenceBarrier <span class="hljs-title">newBarrier</span><span class="hljs-params">(Sequence... sequencesToTrack)</span></span>;<br>    <span class="hljs-comment">//事件发布者获取gating sequence中最小的sequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getMinimumSequence</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//消费者用来获取从nextSequence到availableSequence之间最大的sequence。如果是多线程生产者判断nextSequence是否可用，否则返回nextSequence-1。单线程直接返回availableSequence</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getHighestPublishedSequence</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nextSequence, <span class="hljs-keyword">long</span> availableSequence)</span></span>;<br>    <span class="hljs-comment">//我也不知道干啥的</span><br>    &lt;T&gt; <span class="hljs-function">EventPoller&lt;T&gt; <span class="hljs-title">newPoller</span><span class="hljs-params">(DataProvider&lt;T&gt; provider,Sequence... gatingSequences)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>1：Sequencer中的方法大多是给事件发布者使用。newBarrier()给事件处理者使用。</p>
<p><strong>AbstractSequencer 管理事件处理者序列和事件发布者发布序列。</strong></p>
<figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java">public abstract class AbstractSequencer implements Sequencer &#123;<br>    //用来对gatingSequences做原子操作的。Sequence[]里面存储的是事件处理者处理到的序列。<br>    //如果不懂AtomicReferenceFieldUpdater请www.google.com<br>    private static final AtomicReferenceFieldUpdater&lt;AbstractSequencer, Sequence[]&gt; SEQUENCE_UPDATER =<br>        AtomicReferenceFieldUpdater.newUpdater(AbstractSequencer.class, Sequence[].class, "gatingSequences");<br>    //队列大小<br>    protected final int bufferSize;<br>    //等待策略<br>    protected final WaitStrategy waitStrategy;<br>    //事件发布者的已经发布到的sequence       <br>    protected final Sequence cursor = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);<br>    //事件处理者处理到的序列对象<br>    protected volatile Sequence[] gatingSequences = new Sequence[0];<br><br>    /**<br>     *检查队列大小是否是2^n，判断buffersize大小<br>     */<br>    public AbstractSequencer(int bufferSize, WaitStrategy waitStrategy) &#123;<br>        if (bufferSize &lt; 1) &#123;<br>            throw new IllegalArgumentException("bufferSize must not be less than 1");&#125;<br>        if (Integer.bitCount(bufferSize) != 1) &#123;<br>            throw new IllegalArgumentException("bufferSize must be a power of 2"); &#125;<br>        this.bufferSize = bufferSize;<br>        this.waitStrategy = waitStrategy;<br>    &#125;<br><br>    /**<br>     * 获取事件发布者的序列<br>     */<br>    @Override<br>    public final long getCursor() &#123;<br>        return cursor.get();<br>    &#125;<br><br>    /**<br>     * 获取大小<br>     */<br>    @Override<br>    public final int getBufferSize() &#123;<br>        return bufferSize;<br>    &#125;<br><br>    /**<br>     * 把事件消费者序列维护到gating sequence<br>     */<br>    @Override<br>    public final void addGatingSequences(Sequence... gatingSequences) &#123;<br>        SequenceGroups.addSequences(this, SEQUENCE_UPDATER, this, gatingSequences);<br>    &#125;<br><br>    /**<br>     *  从gating sequence移除序列<br>     */<br>    @Override<br>    public boolean removeGatingSequence(Sequence sequence) &#123;<br>        return SequenceGroups.removeSequence(this, SEQUENCE_UPDATER, sequence);<br>    &#125;<br><br>    /**<br>     * 获取gating sequence中事件处理者处理到最小的序列值<br>     */<br>    @Override<br>    public long getMinimumSequence() &#123;<br>        return Util.getMinimumSequence(gatingSequences, cursor.get());<br>    &#125;<br><br>    /**<br>     * 创建了一个序列栅栏<br>     */<br>    @Override<br>    public SequenceBarrier newBarrier(Sequence... sequencesToTrack) &#123;<br>        return new ProcessingSequenceBarrier(this, waitStrategy, cursor, sequencesToTrack);<br>    &#125;<br><br>    /**<br>     * 这个方法不解释，我也不知道目前用来干嘛的。有知道的大佬可以赐教一下。谢谢<br>     */<br>    @Override<br>    public &lt;T&gt; EventPoller&lt;T&gt; newPoller(DataProvider&lt;T&gt; dataProvider, Sequence... gatingSequences) &#123;<br>        return EventPoller.newInstance(dataProvider, this, new Sequence(), cursor, gatingSequences);<br>    &#125;<br>    //重写toString<br>    @Override<br>    public String toString() &#123;<br>        return "AbstractSequencer&#123;" +<br>            "waitStrategy=" + waitStrategy +<br>            ", cursor=" + cursor +<br>            ", gatingSequences=" + Arrays.toString(gatingSequences) +<br>            '&#125;';<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>SingleProducerSequencer 单线程事件发布者。</strong></p>
<p>1：从上面的图可以看出SingleProducerSequencer间接继承了AbstractSequencer。</p>
<p>2：SingleProducerSequencerFields维护事件发布者发布的序列和事件处理者处理到的最小序列。</p>
<p>3：SingleProducerSequencerPad缓冲行填充，防止false sharing。</p>
<p><strong>next()申请序列</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//该方法是事件发布者申请序列</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>    &#125;<br>     <span class="hljs-comment">//获取事件发布者发布到的序列值</span><br>    <span class="hljs-keyword">long</span> nextValue = <span class="hljs-keyword">this</span>.nextValue;<br>    <span class="hljs-keyword">long</span> nextSequence = nextValue + n;<br>    <span class="hljs-comment">//wrap 代表申请的序列绕一圈以后的位置</span><br>    <span class="hljs-keyword">long</span> wrapPoint = nextSequence - bufferSize;<br>    <span class="hljs-comment">//获取事件处理者处理到的序列值</span><br>    <span class="hljs-keyword">long</span> cachedGatingSequence = <span class="hljs-keyword">this</span>.cachedValue;<br>    <span class="hljs-comment">/** 1.事件发布者要申请的序列值大于事件处理者当前的序列值且事件发布者要申请的序列值减去环的长度要小于事件处理者的序列值。<br>      * 2.满足(1)，可以申请给定的序列。<br>      * 3.不满足(1)，就需要查看一下当前事件处理者的最小的序列值(可能有多个事件处理者)。如果最小序列值大于等于<br>      * 当前事件处理者的最小序列值大了一圈，那就不能申请了序列(申请了就会被覆盖)，<br>      * */</span><br>    <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123;<br>        <span class="hljs-comment">//wrapPoint &gt; cachedGatingSequence 代表绕一圈并且位置大于事件处理者处理到的序列</span><br>        <span class="hljs-comment">//cachedGatingSequence &gt; nextValue 说明事件发布者的位置位于事件处理者的屁股后面</span><br>        <span class="hljs-comment">//维护父类中事件生产者的序列</span><br>        cursor.setVolatile(nextValue);<br>        <span class="hljs-keyword">long</span> minSequence;<br>        <span class="hljs-comment">//如果事件生产者绕一圈以后大于事件处理者的序列，那么会在此处自旋</span><br>        <span class="hljs-keyword">while</span> (wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue))) &#123;<br>            LockSupport.parkNanos(<span class="hljs-number">1L</span>);<br>        &#125;<br>        <span class="hljs-comment">//缓存最小值</span><br>        <span class="hljs-keyword">this</span>.cachedValue = minSequence;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.nextValue = nextSequence;<br>    <span class="hljs-keyword">return</span> nextSequence;<br>&#125;<br><br><span class="hljs-comment">//事件发布调用的方法。唤醒阻塞的消费者</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    cursor.set(sequence);<br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>实战单线程生产者</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">/**<br>     * Create a new Disruptor.<br>     * <span class="hljs-doctag">@param</span> eventFactory 事件对象的数据<br>     * <span class="hljs-doctag">@param</span> ringBufferSize 数组大小，必须是2^n<br>     * <span class="hljs-doctag">@param</span> threadFactory 线程工厂<br>     * <span class="hljs-doctag">@param</span> producerType 生产者策略。ProducerType.SINGLE和ProducerType.MULTI 单个生产者还是多个生产者.<br>     * <span class="hljs-doctag">@param</span> waitStrategy 等待策略。用来平衡事件发布者和事件处理者之间的处理效率。提供了八种策略。默认是BlockingWaitStrategy<br>     */</span><br>    <span class="hljs-comment">//初始化的逻辑大概是创建根据ProducerType初始化创造SingleProducerSequencer或MultiProducerSequencer。</span><br>    <span class="hljs-comment">//初始化Ringbuffer的时候会根据buffsiz把事件对象放入entries数组。</span><br>    Disruptor&lt;TradeBO&gt; disruptor = <span class="hljs-keyword">new</span> Disruptor&lt;&gt;(() -&gt; <span class="hljs-keyword">new</span> TradeBO(), <span class="hljs-number">2</span>,<br>                                                   r -&gt; &#123;<br>                                                       Thread thread = <span class="hljs-keyword">new</span> Thread(r);<br>                                                       thread.setName(<span class="hljs-string">"实战单线程生产者"</span>);<br>                                                       <span class="hljs-keyword">return</span> thread;<br>                                                   &#125;, ProducerType.SINGLE, <span class="hljs-keyword">new</span> BlockingWaitStrategy());<br>    <span class="hljs-comment">//关联事件处理者。初始化BatchEventProcessor。把事件处理者加入gating sequence</span><br>    disruptor.handleEventsWith(<span class="hljs-keyword">new</span> ConsumerA());<br>    disruptor.handleEventsWith(<span class="hljs-keyword">new</span> ConsumerB());<br>    <span class="hljs-comment">//启动消费者线程。BatchEventProcessor间接实现了Runnable。所以这一步就是启动线程。如果事件发布太快，消费太慢会根据不同的waitstrategy等待。</span><br>    disruptor.start();<br>    <span class="hljs-comment">//发布事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> finalI = i;<br>        <span class="hljs-comment">//初始化了EventTranslator。意思就是给最开始初始化的对象赋值</span><br>        EventTranslator eventTranslator = (EventTranslator&lt;TradeBO&gt;) (event, sequence) -&gt; &#123;<br>            event.setId(finalI);<br>            event.setPrice((<span class="hljs-keyword">double</span>) finalI);<br>        &#125;;<br>        <span class="hljs-comment">//发布首先要申请序列，如果申请不到会自旋。</span><br>        disruptor.publishEvent(eventTranslator);<br>    &#125;<br>    disruptor.shutdown();<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">TradeBO</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(TradeBO event, <span class="hljs-keyword">long</span> sequence,<br>                        <span class="hljs-keyword">boolean</span> endOfBatch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"ConsumerB id="</span> + event.getId() + <span class="hljs-string">"price="</span> + event.getPrice());<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">TradeBO</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(TradeBO event, <span class="hljs-keyword">long</span> sequence,<br>                        <span class="hljs-keyword">boolean</span> endOfBatch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">"ConsumerB id="</span> + event.getId() + <span class="hljs-string">"   price="</span> + event.getPrice());<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TradeBO</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> Double price;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>MultiProducerSequencer</strong></p>
<p><strong>成员变量</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取unsafe</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE = Util.getUnsafe();<br><span class="hljs-comment">//获取int[]的偏移量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> BASE = UNSAFE.arrayBaseOffset(<span class="hljs-keyword">int</span>[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><span class="hljs-comment">//获取元素的大小，也就是int的大小4个字节</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> SCALE = UNSAFE.arrayIndexScale(<span class="hljs-keyword">int</span>[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br><span class="hljs-comment">//gatingSequenceCache是gatingSequence。用来标识事件处理者的序列</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequence gatingSequenceCache = <span class="hljs-keyword">new</span> Sequence(Sequencer.INITIAL_CURSOR_VALUE);<br><span class="hljs-comment">//availableBuffer用来追踪每个槽的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] availableBuffer;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> indexMask;<br><span class="hljs-comment">//转了几圈</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> indexShift;<br></code></pre></td></tr></table></figure>

<p><strong>构造函数</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiProducerSequencer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> bufferSize, <span class="hljs-keyword">final</span> WaitStrategy waitStrategy)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化父类</span><br>    <span class="hljs-keyword">super</span>(bufferSize, waitStrategy);<br>    <span class="hljs-comment">//初始化availableBuffer</span><br>    availableBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bufferSize];<br>    indexMask = bufferSize - <span class="hljs-number">1</span>;<br>    indexShift = Util.log2(bufferSize);<br>    <span class="hljs-comment">//这个逻辑是。计算availableBuffer中每个元素的偏移量</span><br>    <span class="hljs-comment">//定位数组每个值的地址就是(index * SCALE) + BASE</span><br>    initialiseAvailableBuffer();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialiseAvailableBuffer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = availableBuffer.length - <span class="hljs-number">1</span>; i != <span class="hljs-number">0</span>; i--) &#123;<br>        setAvailableBufferValue(i, -<span class="hljs-number">1</span>);<br>    &#125;<br>    setAvailableBufferValue(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAvailableBufferValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> bufferAddress = (index * SCALE) + BASE;<br>    <span class="hljs-comment">//修改内存偏移地址为bufferAddress的值，改为flag</span><br>    UNSAFE.putOrderedInt(availableBuffer, bufferAddress, flag);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>next()申请序列</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"n must be &gt; 0"</span>);<br>    &#125;<br>    <span class="hljs-keyword">long</span> current;<br>    <span class="hljs-keyword">long</span> next;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//获取事件发布者发布序列</span><br>        current = cursor.get();<br>        <span class="hljs-comment">//新序列位置</span><br>        next = current + n;<br>        <span class="hljs-comment">//wrap 代表申请的序列绕一圈以后的位置</span><br>        <span class="hljs-keyword">long</span> wrapPoint = next - bufferSize;<br>        <span class="hljs-comment">//获取事件处理者处理到的序列值</span><br>        <span class="hljs-keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();<br>        <span class="hljs-comment">/** 1.事件发布者要申请的序列值大于事件处理者当前的序列值且事件发布者要申请的序列值减去环的长度要小于事件处理者的序列值。<br>         * 2.满足(1)，可以申请给定的序列。<br>         * 3.不满足(1)，就需要查看一下当前事件处理者的最小的序列值(可能有多个事件处理者)。如果最小序列值大于等于<br>         * 当前事件处理者的最小序列值大了一圈，那就不能申请了序列(申请了就会被覆盖)，<br>         * */</span><br>        <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current) &#123;<br>            <span class="hljs-comment">//wrapPoint &gt; cachedGatingSequence 代表绕一圈并且位置大于事件处理者处理到的序列</span><br>            <span class="hljs-comment">//cachedGatingSequence &gt; current 说明事件发布者的位置位于事件处理者的屁股后面</span><br><br>            <span class="hljs-comment">//获取最小的事件处理者序列</span><br>            <span class="hljs-keyword">long</span> gatingSequence = Util.getMinimumSequence(gatingSequences, current);<br>            <span class="hljs-keyword">if</span> (wrapPoint &gt; gatingSequence) &#123;<br>                LockSupport.parkNanos(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//赋值</span><br>            gatingSequenceCache.set(gatingSequence);<br>            <span class="hljs-comment">//通过cas修改</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cursor.compareAndSet(current, next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>publish()事件发布</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-comment">//这里的操作逻辑大概是修改数组中的序列值</span><br>    setAvailable(sequence);<br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAvailable</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    setAvailableBufferValue(calculateIndex(sequence), calculateAvailabilityFlag(sequence));<br>&#125;<br><span class="hljs-comment">//计算数组中位置 sequence&amp;(buffsize-1)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateIndex</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">int</span>) sequence) &amp; indexMask;<br>&#125;<br><span class="hljs-comment">//计算数组中的存储的数据</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateAvailabilityFlag</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (sequence &gt;&gt;&gt; indexShift);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAvailableBufferValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> bufferAddress = (index * SCALE) + BASE;<br>    UNSAFE.putOrderedInt(availableBuffer, bufferAddress, flag);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>MultiProducerSequencer和SingleProducerSequencer区别</strong></p>
<p>1：SingleProducerSequencer内部维护cachedValue(事件消费者序列)，nextValue(事件发布者序列)。并且采用padding填充。这个类是线程不安全的。<br>2：MultiProducerSequencer每次获取序列都是从Sequence中获取的。Sequence中针对value的操作都是原子的。</p>
<p><strong>RingBuffer</strong></p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576726006366.webp" class="">

<p><strong>EventSequencer</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个接口是一个空方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventSequencer</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">DataProvider</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Sequenced</span></span>&#123;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>DataProvider</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DataProvider 提供了根据序列获取对应的对象</span><br><span class="hljs-comment">//有两个地方调用。这个Event对象需要被生产者获取往里面填充数据。第二个是在消费时，获取这个Event对象用于消费。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DataProvider</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>EventSink  这个类提供了各种发布的姿势。</strong></p>
<p>1：EventSink接口是用来发布Event的，在发布的同时，调用绑定的Translator来初始化并填充Event。</p>
<p>2：填充Event是通过实现EventTranslator，EventTranslatorOneArg，EventTranslatorTwoArg，EventTranslatorThreeArg，EventTranslatorVararg这些EventTranslator来做的。</p>
<p>3：发布流程：申请下一个序列-&gt;申请成功则获取对应槽的Event-&gt;利用translator初始化并填充对应槽的Event-&gt;发布Event 。translator用户实现，用于初始化Event。</p>
<p><strong>RingBufferPad  用于缓存行填充</strong></p>
<p><strong>RingBufferFields 这个类的逻辑比较重要，讲解了event在数组中存储位置</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RingBufferFields</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">com</span>.<span class="hljs-title">lmax</span>.<span class="hljs-title">disruptor</span>.<span class="hljs-title">RingBufferPad</span> </span>&#123;<br>    <span class="hljs-comment">//Buffer数组填充</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BUFFER_PAD;<br>    <span class="hljs-comment">//Buffer数组起始基址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> REF_ARRAY_BASE;<br>    <span class="hljs-comment">//数组引用每个引用占用的大小=2^REF_ELEMENT_SHIFT</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REF_ELEMENT_SHIFT;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE = Util.getUnsafe();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//获取Object[]引用大小。我本机4字节</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scale = UNSAFE.arrayIndexScale(Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">4</span> == scale) &#123;<br>            REF_ELEMENT_SHIFT = <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">8</span> == scale) &#123;<br>            REF_ELEMENT_SHIFT = <span class="hljs-number">3</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unknown pointer size"</span>);<br>        &#125;<br>        <span class="hljs-comment">//填充32或者16</span><br>        BUFFER_PAD = <span class="hljs-number">128</span> / scale;<br>        <span class="hljs-comment">// 计算Buffer数组起始基址。我本机是从32开始</span><br>        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>) + (<span class="hljs-title">BUFFER_PAD</span> &lt;&lt; <span class="hljs-title">REF_ELEMENT_SHIFT</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> indexMask;<br>    <span class="hljs-comment">//保存了RingBuffer每个槽的Event对象。这个entries不会被修改。ps:引用不会被修改</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] entries;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bufferSize;<br>    <span class="hljs-comment">//sequencer=SingleProducerSequencer or MultiProducerSequencer的引用</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Sequencer sequencer;<br><br>    RingBufferFields(<br>        EventFactory&lt;E&gt; eventFactory,<br>        Sequencer sequencer) &#123;<br>        <span class="hljs-keyword">this</span>.sequencer = sequencer;<br>        <span class="hljs-keyword">this</span>.bufferSize = sequencer.getBufferSize();<br><br>        <span class="hljs-keyword">if</span> (bufferSize &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"bufferSize must not be less than 1"</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Integer.bitCount(bufferSize) != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"bufferSize must be a power of 2"</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.indexMask = bufferSize - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">this</span>.entries = <span class="hljs-keyword">new</span> Object[sequencer.getBufferSize() + <span class="hljs-number">2</span> * BUFFER_PAD];<br>        fill(eventFactory);<br>    &#125;<br>    <span class="hljs-comment">//填充entries</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(EventFactory&lt;E&gt; eventFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bufferSize; i++) &#123;<br>            entries[BUFFER_PAD + i] = eventFactory.newInstance();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> E <span class="hljs-title">elementAt</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>SequenceBarrier接口 消费者使用</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SequenceBarrier</span> </span>&#123;<br><br>    <span class="hljs-comment">/**<br>         * 等待一个序列变为可用，然后消费这个序列。消费线程中使用<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">long</span> sequence)</span> <span class="hljs-keyword">throws</span> AlertException, InterruptedException, TimeoutException</span>;<br><br>    <span class="hljs-comment">/**<br>         * 获取当前可以读取的序列值。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">getCursor</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**<br>         * 当前栅栏是否发过通知。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlerted</span><span class="hljs-params">()</span></span>;           <br>    <span class="hljs-comment">/**<br>         * 通知消费者状态变化，然后停留在这个状态上，直到状态被清除。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alert</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**<br>         * 清楚通知状态。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearAlert</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">/**<br>         * 检测是否发生了通知，如果已经发生了抛出AlertException异常。<br>         */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkAlert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> AlertException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ProcessingSequenceBarrier</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessingSequenceBarrier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SequenceBarrier</span> </span>&#123;<br><span class="hljs-comment">//等待策略</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WaitStrategy waitStrategy;<br><span class="hljs-comment">//当消费者之前没有依赖关系的时候，那么dependentSequence=cursorSequence</span><br><span class="hljs-comment">//存在依赖关系的时候，dependentSequence 里存放的是一组依赖的Sequence，get方法得到的是最小的序列值</span><br><span class="hljs-comment">//所谓的依赖关系是有两个消费者A、B，其中B需要在A之后进行消费，这A的序列就是B需要依赖的序列，因为B的消费速度不能超过A。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequence dependentSequence;<br><span class="hljs-comment">//判断是否执行shutdown</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> alerted = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">//cursorSequence 代表的是写指针。代表事件发布者发布到那个位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequence cursorSequence;<br><span class="hljs-comment">//sequencer=SingleProducerSequencer or MultiProducerSequencer的引用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sequencer sequencer;<br><br>ProcessingSequenceBarrier(<br>        <span class="hljs-keyword">final</span> Sequencer sequencer,<br>        <span class="hljs-keyword">final</span> WaitStrategy waitStrategy,<br>        <span class="hljs-keyword">final</span> Sequence cursorSequence,<br>        <span class="hljs-keyword">final</span> Sequence[] dependentSequences) &#123;<br>    <span class="hljs-keyword">this</span>.sequencer = sequencer;<br>    <span class="hljs-keyword">this</span>.waitStrategy = waitStrategy;<br>    <span class="hljs-keyword">this</span>.cursorSequence = cursorSequence;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == dependentSequences.length) &#123;<br>        dependentSequence = cursorSequence;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dependentSequence = <span class="hljs-keyword">new</span> FixedSequenceGroup(dependentSequences);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span><br>        <span class="hljs-keyword">throws</span> AlertException, InterruptedException, TimeoutException </span>&#123;<br>    <span class="hljs-comment">//检查是否中断</span><br>    checkAlert();<br>    <span class="hljs-comment">//根据不同的策略获取可用的序列</span><br>    <span class="hljs-keyword">long</span> availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">//判断申请的序列和可用的序列大小</span><br>    <span class="hljs-keyword">if</span> (availableSequence &lt; sequence) &#123;<br>        <span class="hljs-keyword">return</span> availableSequence;<br>    &#125;<br>    <span class="hljs-comment">//如果是单线程生产者直接返回availableSequence</span><br>    <span class="hljs-comment">//多线程生产者判断是否可用，不可用返回sequence-1</span><br>    <span class="hljs-keyword">return</span> sequencer.getHighestPublishedSequence(sequence, availableSequence);<br>&#125;<br><span class="hljs-comment">//获取当前序列</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCursor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dependentSequence.get();<br>&#125;<br><span class="hljs-comment">//判断是否中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlerted</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> alerted;<br>&#125;<br><span class="hljs-comment">//中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alert</span><span class="hljs-params">()</span> </span>&#123;<br>    alerted = <span class="hljs-keyword">true</span>;<br>    waitStrategy.signalAllWhenBlocking();<br>&#125;<br><span class="hljs-comment">//清除中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearAlert</span><span class="hljs-params">()</span> </span>&#123;<br>    alerted = <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">//检查是否中断</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAlert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> AlertException </span>&#123;<br>    <span class="hljs-keyword">if</span> (alerted) &#123;<br>        <span class="hljs-keyword">throw</span> AlertException.INSTANCE;<br>     &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>事件处理 EventProcessor</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">//获取事件处理器使用的序列引用。 </span><br>    <span class="hljs-function">Sequence <span class="hljs-title">getSequence</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//中断</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">halt</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//判断是否运行</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>BatchEventProcessor event模式单线程处理</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//重点讲run方法，其它方法都比较简单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchEventProcessor</span>&lt;<span class="hljs-title">T</span>&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title">EventProcessor</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//启动任务</span><br>        <span class="hljs-keyword">if</span> (running.compareAndSet(IDLE, RUNNING)) &#123;<br>            <span class="hljs-comment">//清除中断状态</span><br>            sequenceBarrier.clearAlert();<br>            <span class="hljs-comment">//判断一下消费者是否实现了LifecycleAware ,如果实现了这个接口，那么此时会发送一个启动通知</span><br>            notifyStart();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//判断任务是否启动</span><br>                <span class="hljs-keyword">if</span> (running.get() == RUNNING) &#123;<br>                    <span class="hljs-comment">//处理事件</span><br>                    processEvents();<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//判断一下消费者是否实现了LifecycleAware ,如果实现了这个接口，那么此时会发送一个停止通知</span><br>                notifyShutdown();<br>                <span class="hljs-comment">//重新设置状态</span><br>                running.set(IDLE);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 线程已经启动</span><br>            <span class="hljs-keyword">if</span> (running.get() == RUNNING) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Thread is already running"</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//这里就是  notifyStart();notifyShutdown();</span><br>                earlyExit();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processEvents</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//定义一个event</span><br>        T event = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//获取要申请的序列</span><br>        <span class="hljs-keyword">long</span> nextSequence = sequence.get() + <span class="hljs-number">1L</span>;<br>        <span class="hljs-comment">//循环处理事件。除非超时或者中断。</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//根据等待策略来等待可用的序列值。 </span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);<br>                <span class="hljs-keyword">if</span> (batchStartAware != <span class="hljs-keyword">null</span>) &#123;<br>                    batchStartAware.onBatchStart(availableSequence - nextSequence + <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-comment">//根据可用的序列值获取事件。批量处理nextSequence到availableSequence之间的事件。</span><br>                <span class="hljs-keyword">while</span> (nextSequence &lt;= availableSequence) &#123;<br>                    <span class="hljs-comment">//获取事件</span><br>                    event = dataProvider.get(nextSequence);<br>                    <span class="hljs-comment">//触发事件</span><br>                    eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);<br>                    nextSequence++;<br>                &#125;<br>                <span class="hljs-comment">//设置事件处理者处理到的序列值。事件发布者会根据availableSequence判断是否发布事件 </span><br>                sequence.set(availableSequence);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> TimeoutException e) &#123;<br>                <span class="hljs-comment">//超时异常</span><br>                notifyTimeout(sequence.get());<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> AlertException ex) &#123;<br>                <span class="hljs-comment">//中断异常</span><br>                <span class="hljs-keyword">if</span> (running.get() != RUNNING) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable ex) &#123;<br>                <span class="hljs-comment">//这里可能用户消费者事件出错。如果自己实现了ExceptionHandler那么就不会影响继续消费</span><br>                exceptionHandler.handleEventException(ex, nextSequence, event);<br>                <span class="hljs-comment">//如果出现异常则设置为nextSequence</span><br>                sequence.set(nextSequence);<br>                nextSequence++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>WorkProcessor  work模式多线程处理</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//判断线程是否启动</span><br>    <span class="hljs-keyword">if</span> (!running.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Thread is already running"</span>);<br>    &#125;<br>    <span class="hljs-comment">//清除中断状态</span><br>    sequenceBarrier.clearAlert();<br>    <span class="hljs-comment">//判断一下消费者是否实现了LifecycleAware ,如果实现了这个接口，那么此时会发送一个启动通知</span><br>    notifyStart();<br>    <span class="hljs-comment">//事件处理标志</span><br>    <span class="hljs-keyword">boolean</span> processedSequence = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">long</span> cachedAvailableSequence = Long.MIN_VALUE;<br>    <span class="hljs-keyword">long</span> nextSequence = sequence.get();<br>    T event = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//判断上一个事件是否已经处理完毕。  </span><br>            <span class="hljs-keyword">if</span> (processedSequence) &#123;<br>                <span class="hljs-comment">//置为false</span><br>                processedSequence = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-comment">//获取下一个序列</span><br>                    nextSequence = workSequence.get() + <span class="hljs-number">1L</span>;<br>                    <span class="hljs-comment">//更新当前已经处理到的</span><br>                    sequence.set(nextSequence - <span class="hljs-number">1L</span>);<br>                &#125;<br>            <span class="hljs-comment">//多个WorkProcessor共享一个workSequence，可以实现互斥消费，因为只有一个线程可以CAS更新成功</span><br>                <span class="hljs-keyword">while</span> (!workSequence.compareAndSet(nextSequence - <span class="hljs-number">1L</span>, nextSequence));<br>            &#125;<br>           <span class="hljs-comment">//检查序列值是否需要申请。</span><br>            <span class="hljs-keyword">if</span> (cachedAvailableSequence &gt;= nextSequence) &#123;<br>                <span class="hljs-comment">//获取事件</span><br>                event = ringBuffer.get(nextSequence);<br>               <span class="hljs-comment">//交给workHandler处理事件。  </span><br>                workHandler.onEvent(event);<br>               <span class="hljs-comment">//设置事件处理完成标识</span><br>                processedSequence = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//申请可用序列</span><br>                cachedAvailableSequence = sequenceBarrier.waitFor(nextSequence);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> TimeoutException e) &#123;<br>            notifyTimeout(sequence.get());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> AlertException ex) &#123;<br>            <span class="hljs-keyword">if</span> (!running.get()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable ex) &#123;<br>            <span class="hljs-comment">//设置异常事件处理</span><br>            exceptionHandler.handleEventException(ex, nextSequence, event);<br>            processedSequence = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//同上</span><br>    notifyShutdown();<br>    <span class="hljs-comment">//停止</span><br>    running.set(<span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>WorkerPool</strong></p>
<p>1：多个WorkProcessor组成一个WorkerPool。<br>2：维护workSequence事件处理者处理的序列。</p>
<p><strong>waitStrategy 等待策略</strong></p>
<p>BlockingWaitStrategy：默认的等待策略。利用锁和等待机制的WaitStrategy，CPU消耗少，但是延迟比较高</p>
<p>BusySpinWaitStrategy：自旋等待。这种策略会利用CPU资源来避免系统调用带来的延迟抖动，当线程可以绑定到指定CPU(核)的时候可以使用这个策略。</p>
<p>LiteBlockingWaitStrategy：实现方法也是阻塞等待</p>
<p>SleepingWaitStrategy：是另一种较为平衡CPU消耗与延迟的WaitStrategy，在不同次数的重试后，采用不同的策略选择继续尝试或者让出CPU或者sleep。这种策略延迟不均匀。</p>
<p>TimeoutBlockingWaitStrategy：实现方法是阻塞给定的时间，超过时间的话会抛出超时异常。</p>
<p>YieldingWaitStrategy：实现方法是先自旋(100次)，不行再临时让出调度(yield)。和SleepingWaitStrategy一样也是一种高性能与CPU资源之间取舍的折中方案，但这个策略不会带来显著的延迟抖动。</p>
<p>PhasedBackoffWaitStrategy：实现方法是先自旋(10000次)，不行再临时让出调度(yield)，不行再使用其他的策略进行等待。可以根据具体场景自行设置自旋时间、yield时间和备用等待策略。</p>
<p><strong>实战多线程消费者</strong></p>
<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个RingBuffer，注意容量是2。</span><br>    RingBuffer&lt;TradeBO&gt; ringBuffer = RingBuffer.createSingleProducer(() -&gt; <span class="hljs-keyword">new</span> TradeBO(), <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//创建2个WorkHandler其实就是创建2个WorkProcessor</span><br>    WorkerPool&lt;TradeBO&gt; workerPool =<br>        <span class="hljs-keyword">new</span> WorkerPool&lt;TradeBO&gt;(ringBuffer, ringBuffer.newBarrier(),<br>                                <span class="hljs-keyword">new</span> IgnoreExceptionHandler(),<br>                                <span class="hljs-keyword">new</span> ConsumerC(), <span class="hljs-keyword">new</span> ConsumerD());<br>    <span class="hljs-comment">//将WorkPool的工作序列集设置为ringBuffer的追踪序列。</span><br>    ringBuffer.addGatingSequences(workerPool.getWorkerSequences());<br>    <span class="hljs-comment">//创建一个线程池用于执行Workhandler。</span><br>    Executor executor = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//启动WorkPool。</span><br>    workerPool.start(executor);<br>    <span class="hljs-comment">//往RingBuffer上发布事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-keyword">int</span> finalI = i;<br>        EventTranslator eventTranslator = (EventTranslator&lt;TradeBO&gt;) (event, sequence) -&gt; &#123;<br>            event.setId(finalI);<br>            event.setPrice((<span class="hljs-keyword">double</span>) finalI);<br>        &#125;;<br>        ringBuffer.publishEvent(eventTranslator);<br>        System.out.println(<span class="hljs-string">"发布["</span> + finalI + <span class="hljs-string">"]"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//程序执行结果。可以看出，多个线程消费者处理位于不同位置的事件</span><br>	发布[<span class="hljs-number">0</span>]<br>    ConsumerC id=<span class="hljs-number">0</span>   price=<span class="hljs-number">0.0</span><br>    发布[<span class="hljs-number">1</span>]<br>    发布[<span class="hljs-number">2</span>]<br>    ConsumerC id=<span class="hljs-number">2</span>   price=<span class="hljs-number">2.0</span><br>    ConsumerD id=<span class="hljs-number">1</span>   price=<span class="hljs-number">1.0</span><br>    ConsumerC id=<span class="hljs-number">3</span>   price=<span class="hljs-number">3.0</span><br>    发布[<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>

<p><strong>DSL</strong></p>
<p>1:所谓DSL我的理解就是消费者这里相互依赖。</p>
<img src="/2020/01/02/Disruptor-%E8%AF%A6%E8%A7%A3/640-1576726329157.webp" class="">

<figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">dw.consumeWith(handler1a, handler2a);<br>dw.after(handler1a).consumeWith(handler1b);<br>dw.after(handler2a).consumeWith(handler2b);<br>dw.after(handler1b, handler2b).consumeWith(handler3);<br>ProducerBarrier producerBarrier = dw.createProducerBarrier();<br></code></pre></td></tr></table></figure>
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/Disruptor/" rel="tag"><i class="fas fa-tags"></i>Disruptor</a>
        
        <a class="post-tag button" href="/tags/%E9%AB%98%E6%95%88%E9%98%9F%E5%88%97/" rel="tag"><i class="fas fa-tags"></i>高效队列</a>
        
        <a class="post-tag button" href="/tags/%E4%BC%AA%E5%85%B1%E4%BA%AB/" rel="tag"><i class="fas fa-tags"></i>伪共享</a>
        
        <a class="post-tag button" href="/tags/CAS/" rel="tag"><i class="fas fa-tags"></i>CAS</a>
        
        <a class="post-tag button" href="/tags/DSL/" rel="tag"><i class="fas fa-tags"></i>DSL</a>
        
        <a class="post-tag button" href="/tags/MESI-%E5%8D%8F%E8%AE%AE/" rel="tag"><i class="fas fa-tags"></i>MESI 协议</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2019/12/31/%E4%BB%80%E4%B9%88%E6%98%AFZooKeeper/" rel="next" title="什么是ZooKeeper"><i class="fas fa-angle-left"></i><span class="nav-title">什么是ZooKeeper</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2020/01/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3/" rel="prev" title="TCP三次握手和四次挥手详解"><span class="nav-title">TCP三次握手和四次挥手详解</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.png" alt="ZGY">
  
  <h1 class="author-name">ZGY</h1>
  <h2 class="author-description">不逼逼自己，都不知道自己到底有多LOW！(¬､¬)</h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">16</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">13</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">24</a></div>
    </div>
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#资料一（基础概念-简单demo）"><span class="toc-text">资料一（基础概念+简单demo）</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#资料二（Disruptor为什么这么快？）"><span class="toc-text">资料二（Disruptor为什么这么快？）</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#资料三（Disruptor无锁框架为啥这么快）"><span class="toc-text">资料三（Disruptor无锁框架为啥这么快）</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#资料四（Disruptor之概览）"><span class="toc-text">资料四（Disruptor之概览）</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#资料五（Disruptor源码解析-实战）"><span class="toc-text">资料五（Disruptor源码解析 + 实战）</span></a></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fas fa-envelope"></i><a href="mailto:3030392760@qq.com" target="_blank">E-Mail</a></li>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/zgysyy" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">ZGY</span><span class="year"><i class="far fa-copyright"></i>2019年12月31日 - 2020</span><span class="creative-commons"><i class="fab fa-creative-commons"></i><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">BY-NC-ND 4.0</a></span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
