---
title: 小甲鱼汇编学习笔记
date: 2020-03-19 12:12:58
tags:
- 汇编
categories:
- 后端
- 汇编
---

<center><h1>day01（2020年2月28日）</h1></center>

# 视频01

1、汇编语言的主体是汇编指令。
2、汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式，汇编指令是机器指令的助记符。
3、寄存器，寄存器是cpu中可以存储数据的器件，相当于嵌入到cpu中的内存，处理数据的速度仅次于cpu。一个cpu中有很多个寄存器，AX是其中一个寄存器的代号，BX也是其中一个寄存器的代号。
4、查看某个软件的汇编指令工具可以使用Ollydbg软件。

<!-- more -->

# 视频02

1、汇编语言由3部分组成，分别是： 

- 汇编指令：机器码的助记符。
- 伪指令：由编译器执行。
- 其他符号：由编译器识别。

2、存储器

- CPU是计算机的核心部件，它控制整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供`指令`和`数据`。
- 指令和数据都是存储在存储器中，我们通常说的存储器其实就是内存。
- 在一台PC机中内存的作用仅次于CPU，离开了内存，再强悍的CPU也没有什么用。磁盘不同于内存，磁盘的读写速度比较慢，通常将磁盘的数据读取到内存中，然后CPU和内存进行数据交互。

3、指令和数据

- 指令和数据是应用上的概率，在内存或磁盘上，指令和数据之间没有任何的区别，都是二进制信息。所以定义指令和数据是由程序员决定的。

4、存储单元

- 存储器被划分为若干个存储单元，存储单元从0开始顺序编号。例如，一个存储器有128个存储单元，编号就是0~127。

5、CPU对存储器的读写

- CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息交互：

- 存储单元的地址。（地址信息）
- 器件的选择，读或写命令。（控制信息）
- 读或写的数据。（数据信息）
  CPU读数据的步骤为：
  1. 获取地址信息。
  2. 确定是读操作操作。
  3. 将数据从指定地址中读取出来。

- CPU写数据的步骤为：
  1. 获取地址信息。
  2. 确定是写操作操作。
  3. 将数据写入指定地址中。

6、CPU是通过什么将地址、数据和控制信息传到存储芯片上的。

CPU传输数据实质上是通过电信号传输的，电信号传输需要导线，通常将CPU和其它芯片之间的连接的导线称为`总线`。总线物理上其实就是一个导线的集合，逻辑上可以分为3类，如下：

1. 地址总线：确定地址。
2. 数据总线：确定传输数据。
3. 控制总线：确定是读还是写。

# 视频03
1、地址总线
一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元。
2、数据总线
数据总线的宽度决定了CPU和外界的数据传输速度，宽度越大，速度越快；反之，速度越慢。
3、8088CPU和8086CPU的区别
8088CPU一次能处理的数据为8位，8086CPU一次能处理的数据为16位，所以8086CPU比8088CPU快。
4、控制总线
有多少根控制总线，就意味着CPU提供了对外部器件有多少种控制，一位代表一种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。

# 视频04

1、小结

1. 汇编指令是机器指令的助记符，同机器指令一一对应。
2. 每一种CPU都有自己的汇编指令集。
3. CPU可以直接使用的信息在存储器中存放。
4. 在存储器中指令和数据没有任何区别，都是二进制信息。

<center><h1>day02（2020年3月1日）</h1></center>

# 视频05

1、内存地址空间
一个CPU的地址线宽度为10，那么可以寻址2的10次方即1024个内存单元，这1024个内存单元就构成了这个CPU的内存地址空间。
2、主板
在每台PC机中，都有一个主板，主板上有核心器件和一些主要器件。这些器件通过总线（地址总线、数据总线、控制总线）相连。
3、接口卡
CPU对外部设备不能直接控制，如显示器、音响、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。
4、各类存储器芯片

- 从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）。
- 从功能和连接上可以分为三类：随机存储器（RAM），装有BOIS的ROM，接口卡上的RAM。
- RAM就是我们常说的内存，只读存储器就是一些硬件在出厂时，厂家用特殊手段将程序刷进ROM的存储器，该存储器一般是只能读不能写的，所以称为只读存储器，比如BOIS就是在ROM中的一个程序，是厂家出厂时刷进去的。

5、对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制，这个逻辑存储器就是我们所说的内存地址空间。

# 视频06

1、一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。
2、内部总线和外部总线的区别如下：

- 内部总线实现CPU内部各个器件之间的联系。
- 外部总线实现CPU和主板上其它器件的联系。



3、8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。
4、8086CPU所有的寄存器都是16位的，可以存放两个字节（一个字节是8位）。
5、AX、BX、CX、DX通常用来存放一般性数据，所以被称为通用寄存器。
6、一个16位寄存器能存储的数据的最大值为2的16次方减1。
7、因为8086上一代CPU中的寄存器都是8位的，为了保证兼容性，8086CPU上的寄存器16位可以分成两个8位来使用，左边8位称为高8位，右边8位称为低8位。所以有如下表示法：

- AX可以分为AH和AL。H表示高，L表示低，下面的意思也相同。
- BX可以分为BH和BL。
- CX可以分为CH和CL。
- DX可以分为DH和DL。

# 视频07
1、一个字可以储存在一个16位寄存器中，这个字的`高位字节`和`低位字节`自然就存在这个寄存器的高8位寄存器和低8位寄存器中。
2、由于一个内存单元可以存放8位数据，CPU中的寄存器又可以存放n个8位数据。也就是说，计算机中的大多数数据是由1~n个8位数据构成的。
3、用十六进制来表示数据可以直观的看出这个数据是由哪些8位数据构成的。每两位对应一个8位数据（一个16进制占4位）。3位能表示一个8进制（2的3次方等于8），4位能表示一个16进制（2的4次方等于16）。
4、几条汇编指令

- mov ax,18：将18送入AX寄存器中。 ax = 8。
- mov ah,78：将78送入AH寄存器中。 ah = 78。
- add ax,8：将AX寄存器中的值加上8。 ax = ax + 8。
- mov ax,bx：将BX寄存器中的值送入AX寄存器中。 ax = bx。
- add ax,bx：将AX寄存器中的值加上BX寄存器中的值。 ax = ax + bx。

5、存在数据丢失，值得是进制位不能再8位寄存器中保存，但是CPU并不是正真的丢弃了这个进位值。

# 视频08
1、物理地址：CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成一个一维的线性空间。我们将这个唯一的地址称为物理地址。
2、16位CPU具有以下几个方面的特征：
- 运算器一次最多可以处理16位的数据。
- 寄存器最大宽度为16位。
- 寄存器和运算器之间的通路是16位。

3、8086CPU一次能处理20位数据，可以传送20位地址，寻址能力为1M（2的20次方）。但是8086CPU的寄存器只能处理16位数据，因此它的寻址能力为64K（2的16次方）。为了让其能达到1M的寻址能力，8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。
4、将两个16位地址加工成20位的步骤如下：

1. CPU内部提供两个16位的地址，把第一个16位地址称为`段地址`，另一个称为`偏移地址`。
2. 将段地址和偏移地址通过内部总线送入一个称为地址加法器的部件。
3. 地址加法器将两个16位地址合并成一个20位地址。

5、地址加法器工作原理：物理地址 = 段地址 * 16 + 偏移地址。（以16进制算就是数据向左移动一位，以2进制算就是数据向左移动4位，因为2的4次方等于16）
6、通过观察移位次数和各种形式数据的关系如下：

- 一个数据的二进制形式左移1位，相当于该数据乘以2。
- 一个数据的二进制形式左移N位，相当于该数据乘以2的N次方。

7、十六进制移位关系如下：

- 一个十六进制形式左移1位，相当于该数据乘以16。
- 一个十六进制形式左移N位，相当于该数据乘以16的N次方。

8、段地址和偏移地址的比喻：一个数为2080，但是我一次只能写3个数字，所以不够，然后我就将第一位乘以1000表示段地址，后面三位数字表示偏移地址，当地址加法器拿到数据后，就会将段地址的第一位乘以1000，然后加上偏移地址，于是就有，物理地址 = 段地址 * 进制位 + 偏移地址。

# 视频09

1、段的概念：内存并没有分段，段的划分来自于CPU，由于8086CPU用“段地址 * 16 + 偏移地址 = 服务地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用 段地址*16 定位段的起始地址也称基础地址，用偏移地址定位段中内存单元。
2、注意两点

1. 因为 段地址*16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数。
2. 偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k。

3、CPU可以用不同的段地址和偏移地址形成同一个物理地址。
4、如果给定一个段地址，仅通过变化偏移地址来寻址，最多可以定位64K个内存单元，因为偏移地址占16位，2的16次方等于64K。
5、数据在21F60H内存单元中，8086PC机的两种描述：

1. 数据存储在内存2000：1F60单元中。
2. 数据存储在内存的2000段中的1F60单元中。

<center><h1>day03（2020年3月2日）</h1></center>

# 视频10

1. 段寄存器就是提供段地址的寄存器，8086CPU有4个段寄存器。分别为：CS、DS、SS、ES。当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。

2. CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取的指令地址。CS为代码寄存器，IP为指令指针数据。

3. 8086CPU工作过程的简要描述

   1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器。
   2. IP = IP + 所读取指令的长度，从而指向下一条指令。
   3. 执行指令。跳转到步骤1，重复这个过程。

4. 在8086CPU加电启动或复位后（即CPU刚开始工作的时候），CS和IP被置为CS=FFFFH，IP=0000H。即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行。所以FFFF0H单元中的指令就是8086PC开机后执行的第一条指令。

5. 在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。

6. 修改CS、IP的指令

   - 同时CS、IP的内容，使用`jmp`指令，格式为：<code>jmp 段地址 : 偏移地址</code>，例如：jmp 2AE3:3。
   - 只修改IP的内容，首相将要设置的值使用指令`mov`将其送入到一个合法寄存器中，然后再使用指令`jmp`后边跟那个被设置值得寄存器，例如：mov AX,2AE3H 然后 jmp AX。

7. 对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。可以将长度为N（N<=64KB）的一组代码，存在一组<b>地址连续</b>、<b>起始地址为16的倍数</b>的内存单元中，这段内存是用来存放代码的，从而定义一个代码段。

   例如，假如有一串汇编指令，占用10个字节，他们存在123B0H\~123B9H的一组内存单元中，我们就可以认为，123B0H\~123B9H这段内存单元是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10字节。

# 视频11

1. 使用Debug调试汇编。常用命令如下：
   - R命令查看、改变CPU寄存器的内容。
   - D命令查看内存中的内容。
   - E命令改写内存中的内容。
   - U命令将内存中的机器指令翻译成汇编指令。
   - T命令执行一条机器命令。
   - A命令以汇编指令的格式在内存中写入一条机器指令。

<center><h1>day04（2020年3月3日）</h1></center>

# 视频13（第三章 寄存器（内存访问一））

1. 任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它看成两个内存单元，也可以看成一个地址为N的`字单元`中高位字节单元和地位字节单元。

2. 8086CPU中有一个DS寄存器，通常用来存放要访问的数据的<b>段地址</b>。例子如下：

   要读取10000H单元的内容，可以用如下程序段进行：

   1. mov bx,1000H
   2. mov ds,bx
   3. mov al,[0]

   上面三条指令将10000H（1000:0）中的数据读取到了AL寄存器中。

3. mov现在的功能如下：

   1. 将数据直接送入寄存器。
   2. 将一个寄存器中的内容送入另一个寄存器中。
   3. 将一个内存单元中的内容送入一个寄存器。

4. 如何从内存单元地址为10000H中读取数据到寄存器中，步骤如下：

   1. 10000H表示为1000:0（段地址:偏移地址）。
   2. 将段地址1000H放入DS寄存器。
   3. 用mov al,[0]完成传送（mov指令中的\[\]说明操作对象是一个内存单元，\[\]中的0说明这个内存单元的偏移地址是0，它的段地址默认已经放入了DS寄存器中了）。

5. 如何把内存单元地址10000H中的数据送入DS中？

   8086CPU不支持将数据直接送入段寄存器，所以<code>mov ds,1000H</code>是错误的，正确的方法是，将地址1000H中的数据送入通用寄存器，然后将通用寄存器中的数据送入段寄存器（数据 --> 通用寄存器 --> 段寄存器）。

6. 将al中的数据送入地址为10000H的内存单元中。

   1. mov bx,1000H; 将段地址送入通用寄存器BX中。
   2. mov ds,bs；将通用寄存器中的地址送入段寄存器DS中。
   3. mov [0],al；将AL通用低位寄存器中的偏移地址送入内存单元。

7. 字的概念

   16位等于2个字节等于一个字。在8086CPU中，该CPU是一个16位结构，有16根数据线，所以一次性要传送16位的数据，也就是一次性传送一个字。

   所以，当使用汇编指令<code>mov ax,[0]</code>时，指定的是AX而不是AL或者AH，这时，数据是16位，即一个字。当为AL或则AH时，数据是8位，即一个字节。

# 视频14（第三章 寄存器（内存访问二）

> 视频13的练习题讲解。

# 视频15（第三章 寄存器（内存访问三））

> 视频13和视频14的总结。

1. mov指令的几种形式：
   - mov 寄存器,数据
   - mov 寄存器,寄存器
   - mov 寄存器,内存单元
   - mov 内存单元,寄存器
   - mov 段寄存器,寄存器
   - mov 寄存器,段寄存器
   - mov 内存单元,段寄存器
   - mov 段寄存器,内存单元
2. add、sub指令，用法和mov指令相同。
3. 小结
   1. 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。
   2. 计算机一个内存单元为一个字节。
   3. 用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。
   4. [address]表示一个偏移地址位address的内存单元。
   5. 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。
   6. mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。

# 视频16（第三章 寄存器（内存访问四））

> 讲述什么是栈，理解栈的结构，掌握栈的使用。

1. 栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

2. 栈有两个基本操作，即入栈和出栈。

   - 入栈：将一个新的元素放入栈顶。
   - 出栈：从栈顶取出一个元素。

   栈顶的元素总是最后入栈，需要出栈时，又最想被从栈中取出。我们称这种规则为LIFO（Last In First Out，后进先出）。

3. 如今的CPU都提供相关的指令来以栈的方式访问内存空间，这意味着，我们在基于8086CPU编程的时候，可以将一段内存当做栈来使用。

4. CPU提供入栈和出栈的指令（最基本的）：

   - push：入栈。push ax：将寄存器AX中的数据送入栈中。
   - pop：出栈。pop ax：从栈顶取出数据送入AX寄存器中。
   
5. 8086CPU入栈和出栈操作都是以字为单位进行的。

6. 8086CPU中，有两个寄存器：

   1. 段寄存器：SS，用来存放栈顶的段地址。
   2. 寄存器：SP，存放栈顶的偏移地址。

   在任意时刻，SS:SP指向栈顶元素。所以计算机用SS寄存器和SP寄存器来表示栈内存结构。

7. 栈结构数据是从内存地址大的内存单元开始存放数据的，push的时候，SP = SP - 2，pop的时候，SP = SP + 2。所以，如果我们将10000H~1000FH这段空间当作栈，初始状态为空的，此时，SS = 1000H，SP = 0010H（当栈中有一个数据时，SP = 000EH，数据为空，相当于在有一个数据的时候，使用pop，所以SP = SP + 2  = 000EH + 2H = 0010H）。

8. 任意时刻，SS:SP指向栈顶，当栈中只有一个元素时，SP = 000EH。在10000H ~ 1000FH这段空间用作栈来使用，并且该栈中只有一个元素时（一个元素是一个字，占16位，一个内存单元是8位），所以SP = 000EH。

<center><h1>day05（2020年3月8日）</h1></center>

# 视频17（第三章 寄存器（内存访问五））

> 讲解了pop指令的执行过程，栈超界问题，push和pop的指令格式。

1. pop指令的执行过程

   pop ax

   1. 将SS:SP指向的内存单元处的数据送入AX中。
   2. SP = SP + 2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

2. 注意

   1. 出栈后，pop操作前的栈顶元素是依然存在的，只是SP:SP指向的地址变成了SP + 2的地址，因此数据是可以恢复的，所以有磁盘恢复数据一说。
   2. 入栈后，push操作会覆盖以前pop操作但是没有真正删除的数据，所以要想数据不能被恢复，就是用专用的软件覆盖以前的数据。

3. 栈顶超界问题

   8086CPU现在没有记录栈顶超界的专用寄存器，所以8086CPU是允许栈顶超界的，在现在新的CPU应该是有专用的栈顶超界专用寄存器的。

   栈顶超界是一个相当危险的问题，可以通过栈顶超界获取到内存上的其它数据，导致数据泄露。

   我们在编程的时候要自己注意栈顶超界问题，要根据可以用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致超界。

   执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。

4. push和pop指令是可以在寄存器和内存之间传送数据的

   栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。

   push和pop的指令格式如下：

   1. 格式一

      - push 寄存器：将一个寄存器中的数据入栈。
      - pop 寄存器：出栈，用一个寄存器接收出栈的数据。

      例如：

      - push ax
      - pop bx

   2. 格式二

      - push 段寄存器：将一个段寄存器中的数据入栈。
      - pop 段寄存器：出栈，用一个段寄存器接收出栈的数据。

      例如：

      - push ds
      - pop es

   3. 格式三

      - push 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）。
      - pop 内存单元：出栈，用一个内存字单元接收出栈的数据

      例如：

      - push [0]
      - pop [2]

      指令执行时，CPU要知道内存单元的地址，可以在push，pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从DS寄存器中取得。

# 视频18（第三章 寄存器（内存访问六））

> 例题讲解，栈的总结

1. 8086CPU提供了栈操作机制，方案如下：

   在SS，SP中存放栈顶的段地址和偏移地址。

   提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元。

2. push指令的执行步骤

   1. SP = SP - 2 。
   2. 想 SS:SP指向的字单元中送入数据。

3. pop指令的执行步骤

   1. 从SS:SP指向的字单元中读取数据。
   2. SP = SP +2 。

4. 任意时刻，SS:SP指向栈顶元素。

5. 8086CPU只记录栈顶，栈空间的大小我们要自己管理。

6. 用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

7. push，pop实质上是一种内存传送指令，注意它们的灵活应用。

8. 栈是一种非常重要的机制，一定要深入理解，灵活掌握。

# 视频19（第三章 寄存器（内存访问七））

> 当用栈来存储数据的时候，SP的地址范围从 0000H~FFFFH的注意事项。

1. 当用10000H~1FFFFH当作栈时，栈段SS = 1000H，栈空间大小为64KB，如果栈为空，则SP = 0000F。我们可以这样理解，栈为空，实际就是栈中的唯一元素出栈，即SP = SP + 2，当栈中只有一个元素时，偏移地址为FFFE（一个内存单元是8位，能放2个十六进制数，但是栈的操作单位是字）。所以SP = FFFEH + 2H = 10000H，因为16位寄存器一次能存储4位十六进制，高位被舍弃，所以SP = 0000H。

2. 当SP的范围为0000H~FFFFH时，从栈空时候SP = 0000H，一直压栈操作，知道栈满的时候 SP 会从 0000H 到

   FFFEH 到 ... 到 0000H，最终形成一个循环，导致原来栈中的内容被新内容覆盖。

# 视频20（第四章 第一个程序01）

1. 一个汇编语言程序从写出到最终执行的简要过程为：

   1. 编写源代码。
   2. 编译和连接。
   3. 执行。

2. 汇编指令：编译器将对应的汇编指令一一对应成机器码。

3. 伪指令：是给编译器看的，告诉编译器如何编译源代码。

4. 定义一个段

   segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。格式为 <code>段名称 segment</code>，<code>段名称 ends</code>，例如：<code>code segment</code>，<code>段名称 ends</code>

5. end 伪指令，告诉编译器汇编程序的源代码在这个位置就结束了，就不需要编译了。

6. 一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。

7. 一个有意义的汇编程序中至少有一个段，这个段是用来存放代码的。

8. assume关键字的作用是将某一段寄存器和程序中的某个段相关联，例如<code>assume cs:code</code>，意思就是将 code 段与CS寄存器进行关联。

9. 汇编源代码是由<b>伪指令</b>和<b>汇编指令</b>组成的。

# 视频21（第四章 第一个程序02）

1. 放在伪指令`segment`前面的自定义字符串就是标号。

2. 程序返回值固定格式：

   ```asm
   mov ax,4c00H
   int 21H
   ```

3. 程序源代码如下：

   ```asm
   assume cs:abc
   abc segment
   	mov ax,2
   	add ax,ax
   	add ax,ax
   	mov ax,4c00H
   	int 21H
   abc ends
   end
   ```

4. 编译链接的作用

   - 当程序很大时，可以将它们分为多个源程序文件来编译，每个源程序编译成目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件。
   - 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件。
   - 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能用来直接生成可执行文件，连接程序将这些内容处理为最终可执行信息。所以在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。

# 视频22（第四章 第一个程序03）

1. 在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2，将P1从可执行文件中加载入内存，将CPU的控制权交给它，P1才得以运行。当P1运行完毕后，应该将CPU的控制权交还给使它得以运行的P2。

2. 操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作。

3. DOS中有一个程序command.com（cmd），这个程序在DOS中称为命令解释器，也就是DOS系统的shell。

4. 在执行demo.exe程序的时候，是正在运行的command程序将demo.exe中的程序加载入内存中，然后command程序设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序得以运行。

5. 汇编程序从写出到执行的过程如下

   1. 编辑源代码，文件名为demo.asm。
   2. 使用masm程序编译源代码，生成demo.obj文件。
   3. 使用link程序连接程序，生成demo.exe文件。
   4. 使用command程序将demo.exe加载入内存。
   5. CPU运行demo.exe程序。

6. 可以使用Debug程序来对我们写的的程序进行单步调试，格式为<code>debug demo.exe</code>。

7. 带入口地址的汇编程序

   ```asm
   assume cs:abc
   abc segment
   start:mov ax,2
   	add ax,ax
   	add ax,ax
   	mov ax,4c00H
   	int 21H
   abc ends
   end start
   ```

   `start`是可以任意定义的，注意`end`后面也要添加对应的相同的字符串。

8. CX寄存器中存放的是程序的长度，单位是字节。

9. DS寄存器是是存储数据的，程序加载后，DS中存放着程序所在内存区的段地址，本来DS应该和CS指向同一个地方，但是实际不是这样的，在DS中会用256个字节来存放PSP的数据，PSP可以理解为DOS要利用PSP来和被加载程序进行通信的区域。所以DS的内存地址是原地址 + 10H的地址，即用10H大小的内存来存储PSP，换算成物理地址是 256个字节来存储PSP。

10. 当程序执行到 `int 21`的时候表示程序即将运行结束，这个时候，在debug模式下不能使用T指令了，要用P指令，当使用P指令后，被调试程序退出，回到debug程序。

11. 需要注意，在DOS中运行程序时，是command将程序加入内存的。所以程序运行结束后会返回到command中，而使用debug将程序载入内存时，程序运行结束后要返回到debug中。

12. 在DOS中使用debug时，程序加载的顺序是：command加载debug，debug加载我们自己写的程序。

# 视频23（第五章 [bx]和loop指令01）

1. 当要完整的描述一个内存单元，需要两种信息：

   1. 内存单元地址。
   2. 内存单元的长度。

   我们用[0]表示一个内存单元时，0表示内存单元的偏移地址，段地址默认在DS中，单元长度可以由具体指令中其它操作对象（比如寄存器）指出，如AX表示一个字，AL表示一个字节。

2. [bx]的表示含义，[bx]同样也表示一个内存单元，只是它的偏移地址在BX寄存器中。之所以出现[bx]这种表示法，是因为在MSAM编译器中，无法识别<code>mov ax,[0]</code>，编译器会识别为<code>mov ax,0</code>，为了解决这个问题，我们可以修改为<code>mov bx,0</code>，然后<code>mov ax,[bx]</code>达到目的。

3. loop指令，该指令就是一个循环指令。

# 视频24（第五章 [bx]和loop指令02）

1. loop指令的格式为：loop:标号，CPU执行loop指令的时候，要进行如下两步操作：

   1. CX = CX - 1。

   2. 判断CX中的值，不为0则转至标号处执行程序，如果为0则向下执行。

   3. 通常我们用loop指令来实现循环功能，CX寄存器在没有使用loop指令的时候，存储的是运行程序的长度，单位为字节。当使用loop指令时，存储的是循环次数。

   4. 使用loop指令实现计算2的12次方的值

      ```asm
      assume cs:code
      code segment
      	start:mov ax,2
      	mov cx,11
      	s:add ax,ax
      	loop s
      	mov ax,4c00H
      	int 21H
      code ends
      end start
      ```

# 视频25（第五章 [bx]和loop指令03）

1. CX寄存器和loop指令相配合实现循环功能的三个要点如下：

   1. 在CX寄存器中存放循环次数。
   2. loop指令中的标号所标识的地址要在前面。
   3. 要循环执行的程序段，要写在标号loop指令的中间。

2. 在使用debug调试循环体的时候的技巧

   当循环次数过多时，我们不可能一次一次的去使用`t`来执行单步指令，这个时候可以使用`g 偏移地址`来实现指定偏移地址的跳转，从而跳过循环体。也可以使用`p`来跳出循环体。

3. 在给寄存器设置值的时候，如果值得第一位是英文字母，汇编是不会识别的，解决的办法就是在设置值得前面添加一个`0`。

4. 在汇编中进行数据运算时，一定要考虑计算后的值是否会超出内存的最多容量。

# 视频26（第五章 [bx]和loop指令04）

1. [bx]的作用：作为偏移地址与DS配合。[bx]在debug中的含义和在MASM中的含义。
2. loop和CX达到循环效果。
3. debug的`g`和`p`的作用。

<center><h1>day06（2020年3月11日）</h1></center>

# 视频27（第五章 [bx]和loop指令05）

1. 不能将位数不同的数据，进行计算。比如内存单元是8位，8086CPU的寄存器是16位，所以不能直接把内存单元中的数据直接与寄存器中的数据进行运算。解决办法是将内存单元中的数据先存入通用寄存器中，比如AX或者BX中，然后在用通用寄存器中的数据与8086CPU中的另一个寄存器进行运算，这样就间接成了两个寄存器进行运算，两个寄存器都是16位的，所以可以进行运算。

2. 利用通用寄存器，实现变量的自增或自减，结合loop指令来实现更为复杂的元素。比如用AX寄存器来存储一个内存单元地址，这样就可以把AX中存储的内存单元地址当作一个变量，我们可以随时更改AX中的内存单元的地址来改变值。

3. 段前缀的使用，在以前我们为了解决MASM编译不解析<code>mov ax,[0]</code>这种语法，而使用如下代码：

   ```asm
   mov bx,0
   mov ax,[bx]
   ```

   这种写法过于麻烦，因此我们可以使用段前缀来表示，代码如下：

   ```asm
   mov ax,ds:[0]
   ```

   上面代码中的`ds:`就是段前缀。

# 视频28（第五章 [bx]和loop指令06）

1. 我们需要向一段内存中写入内容的时候，这段内存空间不应存放系统或其它程序的数据或代码，否则写入操作很可能引发错误。
2. DOS方式下，一般情况，0000H:0200H~0000H:0:02FFH空间中没有系统或其它程序的数据或代码。
3. 在我们测试的时候，就可以用0000H:0200H~0000H:0:02FFH这段空间。
4. 利用ES寄存器和DS寄存器形成两个段寄存器加loop指令来实现将多个数据从一个地址一一复制到另一个地址。

# 视频29（第六章 包含多个段的程序01）

1. 使用一个段来实现8个数据相加的和，代码如下：

   ```asm
   assume cs:code
   code segment
   	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H
   	start:mov bx,0
   	mov ax,0
   	mov cx,8
   	s:add ax,cs:[bx]
   	add bx,2
   	loop s
   	mov ax,4cooH
   	int 21H
   code ends
   end start
   ```

   - dw命令的作用是定义字型数据，dw即define word。多个数据用`,`分开。

   - 上面的程序定义了8个数据，每个数据占用2个内存单元，所以一共占用16个内存单元，即16个字节。
   - 程序中<code>cs:code</code>表示程序的是存放在CS寄存器中的，所以用`dw`定义的数据也是存放在CS寄存器中的，因为`dw`是在代码开头定义的，所以对应的数据应该是从cs:0000H开始的，因为1个数据占用两个字节，所以每两字节单元表示一个数。所以偏移地址是0000H到0000EH表示这8个数据
   - 从程序中可以看出，end伪指令不仅可以告诉MSAM编译器程序到这里结束，还可告诉MASM编译器程序从哪个地方开始，就是从start标号处开始。为什么不是start来标识程序开始，因为start可以是其它任意字符串，编译器MASM并不认识，但是编译器MASM认识`end`伪指令。

2. 从上面的代码可以看出，用一个段的程序，十分麻烦，因为一个段既存有数据，又存有代码。

<center><h1>day07（2020年3月12日）</h1></center>

# 视频30（第六章 包含多个段的程序02）

1. 使用汇编语言，并用一个段来实现数据0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H的逆向存放。

   思路：程序运行时，定义数据存放在cs:0~cs:15的内存单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆向存放。

   问题是，我们首先要有一段可以当作栈的内存空间。这段空间应该由系统来分配。

   我们可以在程序中通过定义数据来获得一段空间，然后将这段空间当作栈空间来用。

   代码如下：

   ```asm
   assume cs:codesg; 设置codesg段为cs段。
   codesg segment
   	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H;用dw来定义8个字型数据，在程序加载后，将取得8个字的内存空间，并将定义的数据放入其中。
   	dw 0,0,0,0,0,0,0,0;与上面的注释相同，在后面的程序中我们将用这段空间来当作栈使用。
   	start:mov ax,cs
   	mov ss,ax
   	mov sp,32;设置栈底的偏移地址为32，因为前面定义了两组8个字型数据，占用30个字节，当栈为空时，sp = sp + 2，所以sp = 32。
   	mov bx,0
   	mov cx,8;循环8次
   	s:push cs:[bx]
   	add bx,2
   	loop s;循环将数据入栈
   	
   	mov bx,0
   	mov cx,8;
   	s2:pop cs:[bx]
   	add bx,2
   	loop s2
   	
   	mov ax,4c00H
   	int 21H
   codesg ends
   end start
   ```

   在代码中，<code>dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</code>，有两种说法：

   1. 定义了8个字型数据。
   2. 开辟了8个字的内存空间，这段空间中的每个字单元中的数据依次是：0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H。

2. 为什么要将数据、代码、栈放入不同的段中？

   因为将数据、代码、栈都放到一个段里面，我们在编程的时候，要注意何处是数据，何处是代码，何处是栈。这样就显然出现了两个问题：

   1. 把它们放到一个段中使程序显得混乱。
   2. 当程序处理的数据很大，导致不能放到一个段中的时候，就出现了问题。

3. 使用汇编语言，并用多个段来实现数据0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H的逆向存放。

   代码如下：

   ```asm
   assume cs:code,ds:data,ss:stack
   data segment
   	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H
   data ends
   
   stack segment
   	dw 0,0,0,0,0,0,0,0
   data ends
   
   code segment
   	start:mov ax,stack
   	mov ss,ax
   	mov sp,16
   	mov ax,data
   	mov ds,ax
   	mov bx,0
   	mov cx,8
   	s:push [bx]
   	add bx,2
   	loop s
   	
   	mov bx,0
   	mov cx,8
   	s2:pop [bx]
   	add bx,2
   	loop s2
   	
   	mov ax,4c00H
   	int 21H
   code ends
   end start
   ```

# 视频31（第六章 包含多个段的程序03）

1. 练习题和实践。

# 视频32（第七章 更灵活定位内存地址01）

1. and指令：逻辑与指令，按位进行与运算。

   如：mov al,01100011B

   ​		 and al,00111011B

   执行后：al=00100011B 

   即同为真为真，其余都是假。

   作用：可以将某个二进制数据指定位设置为0,如要把第3位设置为0，就and 11110111B。

2. or指令：逻辑或指令，按位进行或运算。

   如：mov al,01100011B

   ​		    or al,00111011B

   执行后：al=01111011B

   即同为假为假，其余都为真。

   作用：可以将某个二进制数据指定位设置为1，如要把第3位设置为1，就or 00001000B。

3. ASCII码，是计算机系统中被采用的通用编码，能将字符与2个16进制数进行一一对应，但是无法表示中文，要表示中文要用UNCODE码（另一种编码）。

4. 在ASCII码中，找到小写字母和大写字母之间的转化规律为：小写字母比大写字母大20H（十进制是32）。

5. 编译器能够直接将字符串，转化为对应的ASCII码，定义格式为：<code>db 'AB'</code>，等同于：<code>db 65H,66H</code>

6. 利用`or`和`and`来实现字母大小写的转化，将大写字母和对应小写字母对应ASCII码中的数字转化为二进制后，发现一个规律，大写字母的第六位是0，其余都不变，小写字母的第五位是1，其余都不变。

   因此，可以使用`or`指令将大写字母转化为小写字母，只需要大写字母的二进制数据<b>逻辑或</b>00100000B即可。

   可以使用`and`指令将小写字母转化为大写字母，只需要小写字母的二进制数据<b>逻辑与</b>11011111B即可。

7. 大小写字母转化例子，代码如下：

   ```asm
   assume cs:code,ds:data
   
   data segment
   	db 'BaSiC'
   	db 'aBc'
   data ends
   
   code segment
   	start:mov ax,data
   	mov ds,ax
   	
   	mov bx,0
   	mov cx,5
   	s:mov al,[bx]
   	and al,11011111B
   	mov [bx],al
   	inc bx
   	loop s
   	
   	mov bx,5
   	mov cx,3
   	s2:mov al,[bx]
   	or al,00100000B
   	mov [bx],al
   	inc bx
   	loop s2
   	
   	mov ax,4c00H
   	int 21H
   code ends
   end start
   ```

# 视频33（第七章 更灵活定位内存地址02）

1. 利用[bx + idata]表示一个内存单元，表示偏移地址是bx的值加上一个常量的值。

   例如：mov ax,[bx + 200]的含义为：将一个内存单元的内容送入AX，这个内存单元的长度为2字节（一个字单元），能存放一个字，偏移地址为bx中的数值加上200，段地址在DS中。

2. mov ax,[bx + 200]可以写成如下几种格式：

   - mov ax,[200 + bx]
   - mov ax,200[bx]
   - mov ax,[bx].200

3. 利用[bx + idata]代码示例，将定义的大写字符串转化为小写，将小写字符串转化为大写

   代码如下：

   ```asm
   assume cs:code,ds:data
   
   data segment
   	db 'BASIC'
   	db 'abcde'
   data ends
   
   code segment
   	start:mov ax,data
   	mov ds,ax
   	
   	mov bx,0
   	mov cx,5
   	s:mov al,[bx]
   	and al,11011111B
   	mov [bx],al
   	
   	mov al,[5+bx]
   	or al,00100000B
   	mov [5+bx],al
   	inc bx
   	loop s
   	
   	mov ax,4c00H
   	int 21H
   code ends
   end start
   ```

# 视频34（第七章 更灵活定位内存地址03）

1. SI和DI寄存器，SI和DI是8086CPU中和BX寄存器功能相近的寄存器，但是SI和DI不能够分成两个8位寄存器来使用。

   下面三组指令实现了相同的功能：

   1. 第一组

      ```asm
      mov bx,0
      mov ax,[bx+123]
      ```

    2.  第二组

        ```asm
        mov si,0
        mov ax,[si+123]
        ```

    3.  第三组

        ```asm
        mov di,0
        mov ax,[di+123]
        ```

2. [bx + si + idata]和[bx +di + idata]格式的灵活应用。

# 视频35（第七章 更灵活定位内存地址04）

1. 几种定位内存地址的方法，也称为寻址方式如下：

   1. [idata]用一个常量来表示地址，可用于直接定义一个内存单元。
   2. [bx]用一个变量来保存内存地址，可用于间接定位一个内存单元。
   3. [bx + idata]用一个变量和常量来表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元。
   4. [bx + si]用两个变量表示地址。
   5. [bx + si + idata]用两个变量和一个常量来表示地址。

2. [bx + idata]的示例，将程序中的数据段中的数据的第一个字母改成大写，其中每个字符串占16字节，代码如下：

   ```asm
   assume cs:code,ds:data
   data segment
   	db '1. file    '
   	db '2. edit    '
   	db '3. search  '
   	db '4. view    '
   	db '5. options '
   	db '6. help    '
   data ends
   
   code segment
   	start:mov ax,data
   	mov ds,ax
   	mov bx,0
   	
   	mov cx,6
   	s:mov al,[bx + 3]
   	and al,1101111B
   	mov [bx + 3],al
   	add bx,16
   	loop s
   	
   	mov ax,4c00H
   	int 21H
   code ends
   end start
   ```


<center><h1>day08（2020年3月13日）</h1></center>

# 视频36（第七章 更灵活定位内存地址05）

> 使用栈的数据结构来存储临时数据，用[bx + si]这种定位内存地址方法实现将程序中的数据段中的数据的所有字母改成大写，其中每个字符串占16字节。

1. 使用DX寄存器来临时保存CX中的值，代码如下：

   ```asm
   assume cs:code,ds:data
   data segment
   	db 'ibm.............'
   	db 'dec.............'
   	db 'dos.............'
   	db 'vax.............'
   	db 0
   data ends
   
   code segment
   	start:mov ax,data
   	mov ds,ax
   	
   	mov bx,0
   	mov cx,4
   	
   	s:mov ds:[40H],cx
   	mov si,0
   	mov cx,3
   	s2:mov al,[bx + si]
   	and al,11011111B
   	mov [bx + si],al
   	inc si
   	loop s2
   	mov cx,ds:[40H]
   	add bx,16
   	loop s
   	
   	mov ax,4c00H
   	int 21H
   code ends
   end start
   ```

2. 使用栈来临时保存CX中的值，代码如下：

   ```asm
   assume cs:code,ds:data,ss:stack
   data segment
   	db 'ibm.............'
   	db 'dec.............'
   	db 'dos.............'
   	db 'vax.............'
   	db 0
   data ends
   
   stack segment
   	db 0
   stack ends
   
   code segment
   	start:mov ax,data
   	mov ds,ax
   	
   	mov bx,0
   	mov cx,4
   	
   	s:push cx
   	mov si,0
   	mov cx,3
   	s2:mov al,[bx + si]
   	and al,11011111B
   	mov [bx + si],al
   	inc si
   	loop s2
   	pop cx
   	add bx,16
   	loop s
   	
   	mov ax,4c00H
   	int 21H
   code ends
   end start
   ```

# 视频37（第七章 更灵活定位内存地址06）

> 1. 使用[bx + idata + si]实现将数据段中的数据从指定位开始到后面4位字母改为大写字母。
> 2. 然后是第七章的总结。

1. 使用[bx + idata + si]实现将数据段中的数据从指定位开始到后面4位字母改为大写字母，代码如下：

   ```asm
   assume cs:code,ds:data,ss:stack
   data segment
   	db '1. dispaly......'
   	db '2. brows........'
   	db '3. replace......'
   	db '4. modify.......'
   data ends
   
   stack segment
   	db 0
   stack ends
   
   code segment
   	start:mov ax,data
   	mov ds,ax
   	mov ax,stack
   	mov ss,ax
   	mov sp,40H
   	mov bx,0
   	
   	mov cx,4
   	s:push cx
   	mov si,0
   	mov cx,4
   	s2:mov al,[bx + 3 + si]
   	and al,11011111B
   	mov [bx + 3 +si],al
   	inc si
   	loop s2
   	
   	add bx,16
   	pop cx
   	loop s
   	
   	mov ax,4c00H
   	int 21H
   code ends
   end start
   ```

2. 总结

   - 这一章中，我们主要学习了更灵活的寻址方式的应用和一些编程方法，主要内容有：
     - 寻址方式：[bx (或si、di) + idata]、[bx + si (或di)]、[bx + si (或di) + idata]。
     - 二重循环问题的处理。
     - 栈的应用。
     - 大小写转化技巧。

<center><h1>day09（2020年3月16日）</h1></center>

# 视频38（第八章 数据处理的两个基本问题01）

1. 通用寄存器包括：AX、BX、CX、DX、AH、AL、BH、BL、CH、CL、DH、DL、SP、BP、SI、DI。

2. 段寄存器包括：DS、SS、CS、ES。

3. 通用寄存器中，只有BX、BP、SI、DI这四个寄存器可以用在`[]`中来进行内存单元的寻址。

   {% asset_img image-20200316112740991.png %}

4. 在`[]`中，这四个寄存器(BX、BP、SI、DI)可以单个出现，也可以组合出现。

   {% asset_img image-20200316112917937.png %}

5. 只要在`[]`中使用寄存器BP，而指令中没有显性的给出段地址，段地址就默认在SS寄存器中。

6. 指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。

   {% asset_img image-20200316113407734.png %}

7. 寻址方式小结

   {% asset_img image-20200316113638510.png %}

# 视频39（第八章 数据处理的两个基本问题02）

1. 各种寻址方式的动画展示。

2. 告诉指令要处理的的数据有多长，即是字长度（16位）还字节长度（8位）。

   指定数据长度的三种方式：

   1. 通过寄存器名指明要处理的数据的尺寸，比如ax就是字，al就是字节。
   2. 在没有寄存器名的情况下，用操作符ptr指明内存单元的长度，比如<code>mov word ptr ds:[0],1</code>就是字，<code>mov byte ptr ds:[0],1</code>就是字节。
   3. 栈的pop和push命令默认就是以字为单位，需要注意。

# 视频40（第八章 数据处理的两个基本问题03）

1. 通过一个实例来理解寻址方式的综合应用。

# 视频41 （第八章 数据处理的两个基本问题04）

1. div是除法指令，使用div做除法的时候需要注意：

   - 被除数默认放在AX或DX和AX中。
   - 除数可以是8位的也可以是16位的，可以放在寄存器或者内存单元中。
   - 当除数是8位时，被除数应该是16位，放在AX中。当除数是16位时，被除数应该是32位，高16位放在DX中，低16位放在AX中。

2. div除法的结果分布如下：

   1. 如果除数是8位的时候（被除数为16位），商是存放在AL中的，余数是存放在AH中的。
   2. 如果除数是16位的时候（被除数为32位），商是存放在AX中的，余数是存放在DX中的。

3. div指令格式

   - div 寄存器。
   - div 内存单元。

   示例，除数为8位时：

   ```asm
   div byte ptr ds:[0]
   ```

   该程序的商表示方式为：(al) = (ax) / ((ds) * 16 + 0) 的商。

   该程序的余数表示方式为：(ah) =  (ax) / ((ds) * 16 + 0) 的余数。

   示例，除数为16位时：

   ```asm
   div word ptr es:[0]
   ```

   该程序的商表示方式为：(ax) =  [(dx) * 10000H + (ax)] / ((es) * 16 + 0) 的商。

   该程序的余数表示方式为：(dx) =  [(dx) * 10000H + (ax)] / ((es) * 16 + 0)    的余数。

   <b>重点理解一下，为什么要乘以10000H？</b>

   举个例子来理解，比如被除数是一个32位的数据，根据规定，把高16位放在DX寄存器中，把低16位放在AX寄存器中。假如一个数据是357896H，首先我们先将低16位寄存器填充完，即AX = 7896H，那么高16位寄存器DX = 0035H。现在如果要将数据还原为357896H，就应该是 DX * 16的4次方 + AX，16的4次方正好转化为16进制就是10000H。那么为什么是4次方，因为35相当于向左移动了4位，又因为数据是16进制的，所以是16的四次方。

   这和10进制是相同的道理，想一想，假如一个数是2456，如果用两位表示低位，用两位表示高位。那么低位就是56，高位就是24,当要还原数据时，其实就是24 * 10的2次方 + 56 = 2456。因为数据时10进制的，所以是10的2次方。

   通过上面的解释，就可以知道为什么有：段地址 * 16 + 偏移地址 = 物理地址。8086CPU一次能处理20位，但是一个寄存器能存储16位，为了让CPU不浪费资源，将两个16位寄存器组成一个20位。这样就有效利用了CPU的计算能力，但是这样其实是浪费了12个寄存器单元。因为CPU是处理数据的，而寄存器是存放数据的，所以选择了舍弃空间，来提升程序的速度效率更高。

4. 伪指令 dd，dd伪指令和db、dw含义一样，只是dd表示的是一个双字型数据的意思。即占32位。

5. 伪指令dup，dup是一个操作符，用来定义数据的重复。

   格式为：

   - db 重复的次数 dup（重复的字节型数据）。

   - dw 重复的次数 dup（重复的字型数据）。
   - dd 重复的次数 dup（重复的双字型数据）。

   例子如下：

   db 3 dup(0)：定义了3个字节，它们的值都为0。

   db 3 dup(0,1,2)：定义了9个字节，它们的值为：0、1、2、0、1、2、0、1、2。

# 视频42（第八章 数据处理的两个基本问题06）

1. 一个十分复杂的联系题。后面视频看完后，可以自己动手做一下。

# 视频43（第九章 转移指令的原理01）

1. 操作符offset，也是一个伪指令，在汇编语言中是由编译器处理的符号，它的功能是获取标号的<b>偏移地址</b>。

2. jmp指令，为无条件转移，可以只修改IP寄存器，也可以同时修改CS和IP寄存器。

3. jmp short 标号，<b>也称为段内短转移</b>，它对IP的修改范围为 -128 ~ 127，即向前最多能转移128个字节，向后最多能转移127个字节。作用是转到标号处执行指令。

4. jmp的实现原理详解

   {% asset_img image-20200316165826205.png %}

   ​	jmp short s 指令的读取和执行过程如下：

   1. 如上图所示，现在（CS）= 0BBDH，（IP）= 0006H，此时 jmp 000BH 对应的机器码为：EB03H。
   2. CPU将机器码EB03H读取到指令缓冲器。
   3. (IP) = (IP) + 2 = 0008H，这里加2是应为EB03H占用了两个字节，此时CS:IP指向汇编指令 add ax,0001H。
   4. CPU执行指令缓冲器中的指令 EB 03H，这里的EB对应汇编指令就是jmp。03H即在当前IP的值下加3，<b>如果是负数该值就是补码形式</b>。
   5. 指令执行 EB 03H 后，(IP) = 000BH，CS:IP指向汇编指令 inc ax。
   6. jmp near ptr 标号，<b>也称为段内近转移</b>，该指令和jmp short 标号作用相同，唯一不同就是，它对IP的修改范围是2个字节，即 -32768~32767。

# 视频44（第九章 转移指令的原理02）

1. jmp far ptr 标号，实现的是段间转移，又称为远转移。
2. 转移地址在内存中的jmp指令有两种格式，分别如下：
   1. jmp word ptr 内存单元地址，这是一种段内转移，它的功能是从内存单元地址处开始存放一个字，该字是转移的目的偏移地址。
   2. jmp dword ptr 内存单元地址，这是一种段间转移，它的功能是从内存单元地址处开始存放两个字，高地址处的字是转移的目的的段地址，低地址处的字是转移的目的的偏移地址。

# 视频45（第九章 转移指令的原理03）

1. jcxz为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为 -128~127。

   指令格式：jcxz 标号。这个指令和CX寄存器有联系，如果CX的值为0，则转移到标号处执行。当CX不为0时，程序会向下执行。

2. loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为 -128~127。

   指令格式：loop 标号。这个指令和CX寄存器有联系，如果CX的值不为0，就会一直循环到CX为0才会结束，每循环一次(cx) = (cx) - 1。

# 视频46（第九章 转移指令的原理04）

1. jmp short 标号、jmp near  ptr 标号、jcxz 标号、loop 标号，这几种汇编指令它们对IP的修改时根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。

2. 在段内转移为什么是用位移距离来达到转移效果？

   如果机器码中包含的是目的地址，则就对程序段在内存中的偏移地址有了严格的限制，某个程序的偏移地址被改变了，就意味着相应的转移会出现问题。

3. 注意，根据位移进行转移的指令，它们的转移范围收到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将会报错。

4. jmp 2000:0100 这种转移指令只能在debug程序中使用，汇编编译器并不认识，所以在源程序中这样使用，编译时会报错。

# 视频47（第九章  实验8和实验九详细讲解）

1. 分析实验8，理解位移。
2. 分析实验9，在显示屏上显示数据。

<center><h1>day10（2020年3月17日）</h1></center>

# 视频48（第十章 call和ret指令01）

1. call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。

2. ret指令用栈中的数据，修改IP的内容，从而实现<b>近转移</b>。

   CPU在执行ret指令的时候，进行下面两步操作：

   1. (IP) = ((ss) * 16 + (SP))：使IP的值为栈顶的值。
   2. (SP) = (SP) + 2：出栈一个字，偏移地址指向下一个字。

3. retf指令用栈中的数据，修改CS和IP的内容，从而实现<b>远转移</b>。

   CPU执行retf指令时，进行下面四步操作：

   1. (IP) = ((ss) * 16 + (SP))：使IP的值为栈顶的值。
   2. (SP) = (SP) + 2：出栈一个字，偏移地址指向下一个字。
   3. (CS) = ((ss) * 16 + (SP))：使CS的值为栈顶的值。
   4. (SP) = (SP) + 2：出栈一个字，偏移地址指向下一个字。

   retf指令会出现两次出栈的操作，第一次出栈是修改IP的内容，第二次出栈是修改CS的内容。

4. 可以看出，用汇编语言来解释ret和retf指令，就有：

   - CPU执行ret指令时，相当于进行

     ```asm
     pop IP
     ```

   - CPU执行retf指令时，相当于执行

     ```asm
     pop IP
     pop CS
     ```

5. call指令跟ret指令配合使用，因此CPU执行call指令，进行两部操作：

   1. 将当前IP或CS和IP压如栈中。
   2. 转移(jmp)。

6. call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令原理相同。

7. call指令格式为：call 标号。

   作用是将当前的IP压栈后，转到标号处执行指令。CPU在执行此种格式的call指令时，进行如下的操作：

   1. (SP) = (SP) - 2：进行压栈操作。
   2. (IP) = ((SS) * 16 + (IP))：将IP的偏移地址指向栈顶地址。
   3. (IP) = (IP) + 16位位移。16位位移 = `标号`处的地址 - call指令后的第一个字节的地址。16位位移的范围为-32768~32767，用补码表示。

8. CPU执行<code>call 标号</code>时，相当于进行了

   ```asm
   push IP
   jmp near ptr 标号
   ```

# 视频49（第十章 call和ret指令02）

1. 指令<code>call far ptr 标号</code>实现的是段间转移。CPU执行<code>call far ptr 标号</code>这种格式的call指令时的操作如下：

   1. (SP) = (SP) - 2：栈顶偏移地址减二。

      ((SS) * 16 + (SP)) = (CS)：将当前的段地址，保存在栈顶中。

      (SP) = (SP) - 2：栈顶偏移地址减二。

      ((SS) * 16 + (SP)) = (IP)：把当前指令的下一个指令的偏移地址，保存在栈顶中。

   2. 把CX的值变成标号所在的段地址。

      把IP的值变成标号所在的偏移地址。

   这样就形成了让标号处的代码先执行，然后再使用retf指令回到<code>call far ptr 标号</code>处，执行下一行代码。

   从汇编语言来解释<code>call far ptr 标号</code>,相当于进行如下操作：

   ```asm
   push CS
   push IP
   jmp far ptr 标号
   ```

2. 指令<code>call 16位寄存器</code>实现的是段内转移。CPU执行<code>call 16位寄存器</code>这种格式的call指令时的操作如下：

   1. (SP) = (SP) - 2：栈顶偏移地址减二。
   2. ((SS) * 16 + (SP)) = (IP)：把当前指令的下一个指令的偏移地址，保存在栈顶中。
   3. (IP) = 16位寄存器：将IP的值指向16位寄存器的值。

3. 转移地址在内存中的call指令有两种格式：

   1. call word ptr 内存单元地址。

      汇编语法解释为：

      ```asm
      push IP
      jmp word ptr 内存单元地址
      ```

   2. call dword ptr 内存单元地址。

      汇编语法解释为：

      ```asm
      push CS
      push IP
      jmp dword ptr 内存单元地址
      ```

# 视频50（第十章 call和ret指令03）

1. call指令后面的指令的地址将存储在栈中，所以可以在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。

2. 我们可以利用call和ret来实现子程序机制。

3. mul指令，mul指令时乘法指令，在使用mul做乘法的时候，需要注意：

   1. 相乘的两个数，要么都是8位，要么都是16位。
   2. 如果是8位相乘，结果就放在AX寄存器中；如果是16位相乘，高位放在DX中，低位放在AX中。

4. mul指令格式：

   1. mul 寄存器。
   2. mul 内存单元

5. 内存单元可以用不同的寻址方式给出。比如：

   - mul byte ptr ds:[0]：含义为，(AX) = (AL) * ((DS) * 16 + 0)。

   - mul word ptr [bx + si + 8]：含义为，(AX) = (AX) * ((DS) * 16 + (BX) + (SI) + 8)结果的低16位。

     (DX) = (AX) * ((DS) * 16 + (BX) + (SI) + 8)结果的高16位。

6. call与ret指令共同支持了汇编语言编程中模块化设计。在实际编程中，程序的模块化是必不可少的。因为现实的问题通常比较复杂，对现实问题进行分析时，把它转化成相互联系、不同层次的子问题，是必须的解决方法。

# 视频51（第十章 call和ret指令04）

1. 使用内存实现批量数据传递。
2. 编写3个复杂小程序，后面有时间可以看看。

# 视频52（第十章 call和ret指令05）

1. 前两个程序的实现与详解。

# 视频53（第十章 call和ret指令06）

# 视频54（第十一章 标志寄存器01）

1. 标志寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

2. 标志寄存器中的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何意义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义。

   {% asset_img image-20200317153516229.png %}

3. ZF位，称为<b>零标志位</b>。

   记录相关指令执行后的结果是否为0，如果为0，ZF = 1，否则，ZF = 0。

   add、sub、div、mul、inc、or、and这些指令的执行是会影响到该标志位的。

   mov、push、pop这些指令的执行是不会影响该标志位的。

4. PF位，称为<b>奇偶标志位</b>。

   记录相关指令执行后的二进制结果中1的个数为奇数还是偶数，如果为偶数，PF = 1，否则，PF = 0。

5. SF位，称为<b>符号标志位</b>。

   记录相关指令执行后的结果是正数还是负数。如果为正数，SF = 0，否则，SF = 1。

# 视频55（第十一章 标志寄存器02）

1. CF位，称为<b>进位标志位</b>。

   一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

   CPU在进行运算时，当出现了要向高位进位，但是位数又不足时，比如两个8位数相加，98H + 98H就存在进位问题，但是进位值无法再保存在8位数中，所以CPU就用标志寄存器中的CF位来记录这个进位值。

   {% asset_img image-20200317162221907.png %}

   另外一种情况，当连个数据做减法的时候，有可能向高位借位。比如，两个8位数据：97H - 98H，将产生借位的情况，借位后，相当于197H - 98H。

2. OF位，称为<b>溢出标志位</b>。

   在进行有符号数运算时，如结果超过了机器所能表示的范围称为溢出。

   什么是机器所能表示的范围？

   答：比如 add al,3，如果我们当做有符号运算时，最高位为符号位，即不能表示数据，所以范围就是-128~127。

   如果在进行有符号运算时，出现了溢出情况，那么运算的结果将不正确。

3. CF和OF的区别

   - CF是对无符号数运算有意义的标志位。
   - OF是对有符号数运算有意义的标志位。

4. 对于有无符号，计算机是分不清楚状况的，因此它必须两种都记载着，关于是有符号运算还是无符号元素，要看编写代码的人怎么理解，程序员认为是无符号运算就看CF标志位，程序员认为是有符号运算就看OF标志位。

   例如：

   ```asm
   mov al,98
   add al,99
   ```

   - 对于无符号运算来说，98 + 99 = 197 < 255，所以没有进位，所以CF = 0。
   - 对于有符号运算来说，98 + 99 = -59，数据不对，是应为结果被溢出了，所以OF = 1。

5. adc是带进位加法指令，它利用CF位上记录的进位值。

   格式：adc 操作对象一，操作对于二。

   功能：操作对象一 = 操作对象一 + 操作对象二 + CF。

   比如：adc ax,bx实现的功能是：(AX)  = (AX) + (BX) + CF。

# 视频56（第十一章 标志寄存器03）

1. sbb指令，sbb是带借位减法指令，它利用了CF位上记录的借位值。

   格式：sbb 操作对象一，操作对象二。

   功能：操作对象一 = 操作对象一 - 操作对象二 - CF。

   比如：sbb ax,bx实现的功能是：(AX) = (AX) - (BX) - CF

2. 利用sbb指令我们可以对任意大的数据进行减法运算。比如计算003E1000H - 00202000H，结果放在AX，BX中，程序如下：

   ```asm
   mov bx,1000H
   mov ax,003EH
   sub bx,2000H
   sbb ax,0020H
   ```

3. sbb和adc是基于同样的思路设计的两条指令，在应用思路上和adc类似。

4. cmp指令，是比较指令，功能相当于减法指令，只是不保存结果。cmp指令执行后，会对标志寄存器产生影响。这样，其他相关的指令通过识别标志寄存器中被影响的标志位就可以得到比较结果。

   格式：cmp 操作对象一，操作对象二。

   功能：操作对象一 - 操作对象二，但是并不保存结果，仅仅根据计算结果对标志寄存器进行设置。

   比如：cmp ax,ax。在做(AX) - (AX)的运算，结果为0，但并不在AX中保存，仅仅影响标志寄存器的相应位。

   指令在执行后：ZF = 1，PF = 1，SF = 0，CF = 0，OF = 0。

5. 通过cmp指令执行后，根据相关标志位的值就可以看出比较结果，例如：cmp ax,bx就可以得到下面的结论

   {% asset_img image-20200317175439473.png %}

6. cmp指令同add、sub指令一样，CPU在执行cmp指令时，也包含两种含义：

   1. 进行无符号数运算和进行有符号数运算。
   2. 利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较

<center><h1>day11（2020年3月19日）</h1></center>

# 视频57（第十一章 标志寄存器04）

1. 用cmp来进行有符号数比较时，我们需要注意哪些标志位。

   - 我们以cmp ah,bh为例进行说明：

     如果(ah) = (bh)，则(ah) - (bh) = 0，所以ZF = 1。

     如果(ah) != (bh)，则(ah) - (bh) != 0，所以ZF = 0。

     所以我们根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。

   - 如果(ah) < (bh)则可能发生什么情况？

     对于有符号的运算，在(ah) < (bh)的情况下，(ah) - (bh)显然可能引起SF = 1，即结果为负。

     比如 (ah) = 1，(bh) = 2，则 (ah) - (bh) = 0FFH，0FFH为-1的补码，这是SF = 1，所以结果为负，所以结果为-1。

   - 我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知结果是否溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。

   - 因为cmp指令可以进行两种比较，即无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即：

     1. 根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值。
     2. 根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF、ZF的值。

   - 检测比较结果的条件转移指令

     {% asset_img image-20200319110046468.png %}

     注意观察它们所检测的标志位，都是cmp指令进行无符号数比较时候，记录比较结果的标志位。

     比如je，检测ZF位，当ZF为1的时候进行转移，如果在je前面使用了cmp指令，那么je对ZF的检测，实际上就是间接的检测cmp的比较结果是否为两数相等。

# 视频58（第十一章 标志寄存器05）

1. 编程实现如下功能，如果(ah) = (bh)则(ah) = (ah) + (ah)，否则(ah) = (ah) + (bh)。

   核心代码如下：

   ```asm
   cmp ah,bh
   je s
   add ah,bh
   jmp short ok
   s:add ah,ah
   ok:ret
   ```

2. je检测的是ZF位置，不管je前面是什么指令，只要CPU执行je指令时，ZF = 1，那么就会发生转移。

   比如下面的代码：

   ```asm
   mov ax,0
   add ax,0
   je s
   inc ax
   s:inc ax
   ```

   代码执行后，(ax) = 1。add ax,0 使得ZF = 1，所以je指令将进行转移。

3. DF标志和串传送指令。

   标志寄存器的第10位是DF标志位，也称为<b>方向标志位</b>。在串处理指令中，控制每次操作后si，di的增减。

   DF = 0：每次操作后si，di递增。

   DF = 1：每次操作后si，di递减。

   - 格式：movsb。

     功能：以字节为单位传送，将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减。

     1. ((es) * 16 + (di)) = ((dx) * 16 + (si))
     2. 如果DF = 0，则(si) = (si) + 1，(di) = (di) + 1。如果DF = 1，则(si) = (si) - 1，(di) = (di) - 1。

   - 格式movsw

     功能：以字为单位传送，将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2。

4. movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式为：rep movsb。

   rep的作用是根据cx的值，重复执行后面的串传送指令。

   由于每一次执行movsb指令si和di都会递增或递减一个单元，则rep movsb就可以循环实现（cx）个字符的传送。

5. 由于DF位决定着串传送指令执行后，si和di的改变方向，所以CPU应该提供相应的指令来对DF位进行设置，从而使程序员能过决定传送的方向。

   8086CPU提供如下两条指令对DF位进行设置：

   1. cld指令：将DF的值设置为0。
   2. std指令：将DF的值设置为1。

# 视频59（第十一章 标志寄存器06）

1. pushf和popf
   - pushf：将标志寄存器的值压栈。
   - popf：从栈中弹出数据，送入标志寄存器中。